// find.ailang - Search for files in directory hierarchy
// Usage: find [path] [-name pattern] [-type f|d]

FixedPool.FindConfig {
    "name_pattern": Initialize=0
    "type_filter": Initialize=0
    "max_depth": Initialize=1000
}

FixedPool.FindConstants {
    "BUFFER_SIZE": Initialize=32768
    "MAX_PATH": Initialize=4096
    "AT_FDCWD": Initialize=-100
    "O_RDONLY": Initialize=0
    "O_DIRECTORY": Initialize=65536
    "DT_DIR": Initialize=4
    "DT_REG": Initialize=8
}

Function.WriteStdout {
    Input: str: Address
    Body: {
        len = StringLength(str)
        SystemCall(1, 1, str, len)
    }
}

Function.WriteStderr {
    Input: str: Address
    Body: {
        len = StringLength(str)
        SystemCall(1, 2, str, len)
    }
}

Function.GetUInt16 {
    Input: buffer: Address
    Input: offset: Integer
    Output: Integer
    Body: {
        ptr = Add(buffer, offset)
        byte0 = GetByte(ptr, 0)
        byte1 = GetByte(ptr, 1)
        value = Add(byte0, Multiply(byte1, 256))
        ReturnValue(value)
    }
}

Function.StrContains {
    Input: str: Address
    Input: pattern: Address
    Output: Integer
    Body: {
        str_len = StringLength(str)
        pattern_len = StringLength(pattern)
        
        IfCondition GreaterThan(pattern_len, str_len) ThenBlock: {
            ReturnValue(0)
        }
        
        i = 0
        max_pos = Subtract(str_len, pattern_len)
        
        WhileLoop LessEqual(i, max_pos) {
            match = 1
            j = 0
            
            WhileLoop LessThan(j, pattern_len) {
                IfCondition NotEqual(GetByte(str, Add(i, j)), GetByte(pattern, j)) ThenBlock: {
                    match = 0
                    BreakLoop
                }
                j = Add(j, 1)
            }
            
            IfCondition EqualTo(match, 1) ThenBlock: {
                ReturnValue(1)
            }
            
            i = Add(i, 1)
        }
        
        ReturnValue(0)
    }
}

Function.MatchesPattern {
    Input: str: Address
    Input: pattern: Address
    Output: Integer
    Body: {
        // Simple wildcard matching: supports * at start, end, or both
        pattern_len = StringLength(pattern)
        str_len = StringLength(str)
        
        // Check if pattern starts with *
        starts_with_star = EqualTo(GetByte(pattern, 0), 42)
        
        // Check if pattern ends with *
        ends_with_star = 0
        IfCondition GreaterThan(pattern_len, 0) ThenBlock: {
            ends_with_star = EqualTo(GetByte(pattern, Subtract(pattern_len, 1)), 42)
        }
        
        // Case 1: *pattern* - substring match
        IfCondition And(starts_with_star, ends_with_star) ThenBlock: {
            // Extract middle part (skip first and last *)
            IfCondition LessEqual(pattern_len, 2) ThenBlock: {
                // Just ** or * - matches everything
                ReturnValue(1)
            }
            middle_len = Subtract(pattern_len, 2)
            middle = Allocate(Add(middle_len, 1))
            i = 0
            WhileLoop LessThan(i, middle_len) {
                SetByte(middle, i, GetByte(pattern, Add(i, 1)))
                i = Add(i, 1)
            }
            SetByte(middle, middle_len, 0)
            result = StrContains(str, middle)
            Deallocate(middle, Add(middle_len, 1))
            ReturnValue(result)
        }
        
        // Case 2: *pattern - ends with match
        IfCondition EqualTo(starts_with_star, 1) ThenBlock: {
            suffix_len = Subtract(pattern_len, 1)
            IfCondition LessThan(str_len, suffix_len) ThenBlock: {
                ReturnValue(0)
            }
            // Compare suffix
            match = 1
            i = 0
            WhileLoop LessThan(i, suffix_len) {
                str_idx = Add(Subtract(str_len, suffix_len), i)
                pattern_idx = Add(i, 1)
                IfCondition NotEqual(GetByte(str, str_idx), GetByte(pattern, pattern_idx)) ThenBlock: {
                    match = 0
                    BreakLoop
                }
                i = Add(i, 1)
            }
            ReturnValue(match)
        }
        
        // Case 3: pattern* - starts with match
        IfCondition EqualTo(ends_with_star, 1) ThenBlock: {
            prefix_len = Subtract(pattern_len, 1)
            IfCondition LessThan(str_len, prefix_len) ThenBlock: {
                ReturnValue(0)
            }
            // Compare prefix
            match = 1
            i = 0
            WhileLoop LessThan(i, prefix_len) {
                IfCondition NotEqual(GetByte(str, i), GetByte(pattern, i)) ThenBlock: {
                    match = 0
                    BreakLoop
                }
                i = Add(i, 1)
            }
            ReturnValue(match)
        }
        
        // Case 4: No wildcards - exact match
        IfCondition NotEqual(str_len, pattern_len) ThenBlock: {
            ReturnValue(0)
        }
        match = 1
        i = 0
        WhileLoop LessThan(i, str_len) {
            IfCondition NotEqual(GetByte(str, i), GetByte(pattern, i)) ThenBlock: {
                match = 0
                BreakLoop
            }
            i = Add(i, 1)
        }
        ReturnValue(match)
    }
}

Function.BuildPath {
    Input: dir: Address
    Input: name: Address
    Output: Address
    Body: {
        dir_len = StringLength(dir)
        name_len = StringLength(name)
        
        // dir + "/" + name + null
        total_len = Add(Add(dir_len, name_len), 2)
        path = Allocate(total_len)
        
        // Copy directory
        i = 0
        WhileLoop LessThan(i, dir_len) {
            SetByte(path, i, GetByte(dir, i))
            i = Add(i, 1)
        }
        
        // Add slash if needed
        IfCondition NotEqual(GetByte(dir, Subtract(dir_len, 1)), 47) ThenBlock: {
            SetByte(path, i, 47)
            i = Add(i, 1)
        }
        
        // Copy name
        j = 0
        WhileLoop LessThan(j, name_len) {
            SetByte(path, i, GetByte(name, j))
            i = Add(i, 1)
            j = Add(j, 1)
        }
        
        SetByte(path, i, 0)
        ReturnValue(path)
    }
}

Function.ShouldPrint {
    Input: path: Address
    Input: is_dir: Integer
    Output: Integer
    Body: {
        // Type filter
        IfCondition EqualTo(FindConfig.type_filter, 1) ThenBlock: {
            // type=f, skip directories
            IfCondition EqualTo(is_dir, 1) ThenBlock: {
                ReturnValue(0)
            }
        }
        
        IfCondition EqualTo(FindConfig.type_filter, 2) ThenBlock: {
            // type=d, skip files
            IfCondition EqualTo(is_dir, 0) ThenBlock: {
                ReturnValue(0)
            }
        }
        
        // Name pattern filter - match against filename only, not full path
        IfCondition NotEqual(FindConfig.name_pattern, 0) ThenBlock: {
            // Find last '/' in path to get filename
            path_len = StringLength(path)
            last_slash = -1
            i = 0
            WhileLoop LessThan(i, path_len) {
                IfCondition EqualTo(GetByte(path, i), 47) ThenBlock: {
                    last_slash = i
                }
                i = Add(i, 1)
            }
            
            // Extract filename
            filename_start = Add(last_slash, 1)
            filename_len = Subtract(path_len, filename_start)
            filename = Allocate(Add(filename_len, 1))
            i = 0
            WhileLoop LessThan(i, filename_len) {
                SetByte(filename, i, GetByte(path, Add(filename_start, i)))
                i = Add(i, 1)
            }
            SetByte(filename, filename_len, 0)
            
            matches = MatchesPattern(filename, FindConfig.name_pattern)
            Deallocate(filename, Add(filename_len, 1))
            
            IfCondition EqualTo(matches, 0) ThenBlock: {
                ReturnValue(0)
            }
        }
        
        ReturnValue(1)
    }
}

Function.ProcessDirectory {
    Input: dir_path: Address
    Input: depth: Integer
    Body: {
        // Check depth limit
        IfCondition GreaterThan(depth, FindConfig.max_depth) ThenBlock: {
            ReturnValue(0)
        }
        
        // Only print directory on first call (depth 0)
        IfCondition EqualTo(depth, 0) ThenBlock: {
            should_print = ShouldPrint(dir_path, 1)
            IfCondition EqualTo(should_print, 1) ThenBlock: {
                WriteStdout(dir_path)
                WriteStdout("\n")
            }
        }
        
        // Open directory using openat (syscall 257)
        flags = BitwiseOr(FindConstants.O_RDONLY, FindConstants.O_DIRECTORY)
        dir_fd = SystemCall(257, FindConstants.AT_FDCWD, dir_path, flags, 0)
        
        IfCondition LessThan(dir_fd, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        // Allocate buffer for getdents64
        buffer = Allocate(FindConstants.BUFFER_SIZE)
        
        // Read ALL directory entries (may require multiple calls)
        WhileLoop 1 {
            // getdents64: syscall 217
            bytes_read = SystemCall(217, dir_fd, buffer, FindConstants.BUFFER_SIZE)
            
            IfCondition LessEqual(bytes_read, 0) ThenBlock: {
                BreakLoop
            }
            
            // Parse directory entries
            pos = 0
            
            WhileLoop LessThan(pos, bytes_read) {
                // struct linux_dirent64:
                // d_ino (8 bytes at offset 0)
                // d_off (8 bytes at offset 8)
                // d_reclen (2 bytes at offset 16)
                // d_type (1 byte at offset 18)
                // d_name (variable, starts at offset 19)
                
                d_reclen = GetUInt16(buffer, Add(pos, 16))
                d_type = GetByte(buffer, Add(pos, 18))
                name_start = Add(pos, 19)
                
                // Extract name (null-terminated)
                name_len = 0
                WhileLoop 1 {
                    ch = GetByte(buffer, Add(name_start, name_len))
                    IfCondition EqualTo(ch, 0) ThenBlock: {
                        BreakLoop
                    }
                    name_len = Add(name_len, 1)
                }
                
                // Copy name to new buffer
                name = Allocate(Add(name_len, 1))
                i = 0
                WhileLoop LessThan(i, name_len) {
                    SetByte(name, i, GetByte(buffer, Add(name_start, i)))
                    i = Add(i, 1)
                }
                SetByte(name, name_len, 0)
                
                // Skip "." and ".."
                is_dot = And(EqualTo(name_len, 1), EqualTo(GetByte(name, 0), 46))
                is_dotdot = And(EqualTo(name_len, 2), And(EqualTo(GetByte(name, 0), 46), EqualTo(GetByte(name, 1), 46)))
                
                IfCondition Not(Or(is_dot, is_dotdot)) ThenBlock: {
                    // Build full path
                    full_path = BuildPath(dir_path, name)
                    
                    is_dir = EqualTo(d_type, FindConstants.DT_DIR)
                    
                    // Print if matches filters
                    should_print = ShouldPrint(full_path, is_dir)
                    IfCondition EqualTo(should_print, 1) ThenBlock: {
                        WriteStdout(full_path)
                        WriteStdout("\n")
                    }
                    
                    // Recurse into subdirectories
                    IfCondition EqualTo(is_dir, 1) ThenBlock: {
                        ProcessDirectory(full_path, Add(depth, 1))
                    }
                    
                    Deallocate(full_path, 0)
                }
                
                Deallocate(name, Add(name_len, 1))
                
                // Move to next entry
                pos = Add(pos, d_reclen)
            }
        }
        
        Deallocate(buffer, FindConstants.BUFFER_SIZE)
        SystemCall(3, dir_fd)
    }
}

Function.GetArgs {
    Output: Address
    Body: {
        fd = SystemCall(257, -100, "/proc/self/cmdline", 0, 0)
        IfCondition LessThan(fd, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        buffer = Allocate(4096)
        bytes_read = SystemCall(0, fd, buffer, 4096)
        SystemCall(3, fd)
        
        IfCondition LessEqual(bytes_read, 0) ThenBlock: {
            Deallocate(buffer, 4096)
            ReturnValue(0)
        }
        
        ReturnValue(buffer)
    }
}

SubRoutine.Main {
    args_buffer = GetArgs()
    
    IfCondition EqualTo(args_buffer, 0) ThenBlock: {
        WriteStderr("find: usage: find [path] [-name pattern] [-type f|d]\n")
        SystemCall(60, 1)
    }
    
    // Skip program name
    pos = 0
    WhileLoop NotEqual(GetByte(args_buffer, pos), 0) {
        pos = Add(pos, 1)
    }
    pos = Add(pos, 1)
    
    // Default: search current directory
    search_path = "."
    
    // Parse arguments
    WhileLoop LessThan(pos, 4096) {
        ch = GetByte(args_buffer, pos)
        IfCondition EqualTo(ch, 0) ThenBlock: {
            BreakLoop
        }
        
        first = GetByte(args_buffer, pos)
        
        IfCondition EqualTo(first, 45) ThenBlock: {
            arg_start = pos
            arg_len = 0
            
            WhileLoop And(LessThan(pos, 4096), NotEqual(GetByte(args_buffer, pos), 0)) {
                arg_len = Add(arg_len, 1)
                pos = Add(pos, 1)
            }
            
            flag = Allocate(Add(arg_len, 1))
            i = 0
            WhileLoop LessThan(i, arg_len) {
                ch = GetByte(args_buffer, Add(arg_start, i))
                SetByte(flag, i, ch)
                i = Add(i, 1)
            }
            SetByte(flag, arg_len, 0)
            
            second = GetByte(flag, 1)
            
            IfCondition EqualTo(second, 110) ThenBlock: {
                // -name flag
                pos = Add(pos, 1)
                
                pattern_start = pos
                pattern_len = 0
                
                WhileLoop And(LessThan(pos, 4096), NotEqual(GetByte(args_buffer, pos), 0)) {
                    pattern_len = Add(pattern_len, 1)
                    pos = Add(pos, 1)
                }
                
                FindConfig.name_pattern = Allocate(Add(pattern_len, 1))
                i = 0
                WhileLoop LessThan(i, pattern_len) {
                    ch = GetByte(args_buffer, Add(pattern_start, i))
                    SetByte(FindConfig.name_pattern, i, ch)
                    i = Add(i, 1)
                }
                SetByte(FindConfig.name_pattern, pattern_len, 0)
            }
            
            IfCondition EqualTo(second, 116) ThenBlock: {
                // -type flag
                pos = Add(pos, 1)
                
                type_char = GetByte(args_buffer, pos)
                
                IfCondition EqualTo(type_char, 102) ThenBlock: {
                    // 'f' = files only
                    FindConfig.type_filter = 1
                }
                IfCondition EqualTo(type_char, 100) ThenBlock: {
                    // 'd' = directories only
                    FindConfig.type_filter = 2
                }
                
                WhileLoop And(LessThan(pos, 4096), NotEqual(GetByte(args_buffer, pos), 0)) {
                    pos = Add(pos, 1)
                }
            }
            
            Deallocate(flag, Add(arg_len, 1))
        } ElseBlock: {
            // Path argument
            path_start = pos
            path_len = 0
            
            WhileLoop And(LessThan(pos, 4096), NotEqual(GetByte(args_buffer, pos), 0)) {
                path_len = Add(path_len, 1)
                pos = Add(pos, 1)
            }
            
            search_path = Allocate(Add(path_len, 1))
            i = 0
            WhileLoop LessThan(i, path_len) {
                ch = GetByte(args_buffer, Add(path_start, i))
                SetByte(search_path, i, ch)
                i = Add(i, 1)
            }
            SetByte(search_path, path_len, 0)
        }
        
        pos = Add(pos, 1)
    }
    
    Deallocate(args_buffer, 4096)
    
    // Start recursive search
    ProcessDirectory(search_path, 0)
    
    SystemCall(60, 0)
}

RunTask(Main)