// split.ailang - Split a file into pieces
// Usage: split [OPTION]... [FILE [PREFIX]]

FixedPool.SplitConfig {
    "lines_per_file": Initialize=1000
    "bytes_per_file": Initialize=0
    "numeric_suffixes": Initialize=0
    "suffix_length": Initialize=2
}

FixedPool.OutputBuffer {
    "buffer": Initialize=0
    "position": Initialize=0
    "fd": Initialize=-1
}

Function.InitOutputBuffer {
    Body: {
        OutputBuffer.buffer = Allocate(524288)  
        OutputBuffer.position = 0
        OutputBuffer.fd = -1
    }
}

Function.FlushOutputBuffer {
    Body: {
        IfCondition And(GreaterThan(OutputBuffer.position, 0), GreaterEqual(OutputBuffer.fd, 0)) ThenBlock: {
            SystemCall(1, OutputBuffer.fd, OutputBuffer.buffer, OutputBuffer.position)
            OutputBuffer.position = 0
        }
    }
}

Function.BuffWrite {
    Input: data: Address
    Input: len: Integer
    Body: {
        space = Subtract(524288, OutputBuffer.position)
        IfCondition LessThan(space, len) ThenBlock: {
            FlushOutputBuffer()
        }
        MemCopy(Add(OutputBuffer.buffer, OutputBuffer.position), data, len)
        OutputBuffer.position = Add(OutputBuffer.position, len)
    }
}

Function.WriteStdout {
    Input: buffer: Address
    Input: len: Integer
    Body: {
        SystemCall(1, 1, buffer, len)
    }
}

Function.WriteStderr {
    Input: buffer: Address
    Input: len: Integer
    Body: {
        SystemCall(1, 2, buffer, len)
    }
}

Function.GetStringLength {
    Input: str: Address
    Output: Integer
    Body: {
        len = 0
        WhileLoop NotEqual(GetByte(str, len), 0) {
            len = Add(len, 1)
        }
        ReturnValue(len)
    }
}

Function.ConvertNumberToString {
    Input: num: Integer
    Output: Address
    Body: {
        buffer = Allocate(32)
        
        IfCondition EqualTo(num, 0) ThenBlock: {
            SetByte(buffer, 0, 48)
            SetByte(buffer, 1, 0)
            ReturnValue(buffer)
        }
        
        is_neg = 0
        IfCondition LessThan(num, 0) ThenBlock: {
            is_neg = 1
            num = Subtract(0, num)
        }
        
        pos = 0
        temp = Allocate(32)
        
        WhileLoop GreaterThan(num, 0) {
            digit = Modulo(num, 10)
            SetByte(temp, pos, Add(48, digit))
            pos = Add(pos, 1)
            num = Divide(num, 10)
        }
        
        write_pos = 0
        IfCondition NotEqual(is_neg, 0) ThenBlock: {
            SetByte(buffer, 0, 45)
            write_pos = 1
        }
        
        i = Subtract(pos, 1)
        WhileLoop GreaterEqual(i, 0) {
            ch = GetByte(temp, i)
            SetByte(buffer, write_pos, ch)
            write_pos = Add(write_pos, 1)
            i = Subtract(i, 1)
        }
        
        SetByte(buffer, write_pos, 0)
        Deallocate(temp, 32)
        
        ReturnValue(buffer)
    }
}

Function.CopyString {
    Input: dest: Address
    Input: src: Address
    Body: {
        i = 0
        WhileLoop LessThan(i, 1000) {
            ch = GetByte(src, i)
            SetByte(dest, i, ch)
            IfCondition EqualTo(ch, 0) ThenBlock: {
                BreakLoop
            }
            i = Add(i, 1)
        }
    }
}

Function.AppendString {
    Input: dest: Address
    Input: src: Address
    Body: {
        i = 0
        WhileLoop LessThan(i, 1000) {
            IfCondition EqualTo(GetByte(dest, i), 0) ThenBlock: {
                BreakLoop
            }
            i = Add(i, 1)
        }
        
        j = 0
        WhileLoop LessThan(j, 100) {
            ch = GetByte(src, j)
            SetByte(dest, i, ch)
            IfCondition EqualTo(ch, 0) ThenBlock: {
                BreakLoop
            }
            i = Add(i, 1)
            j = Add(j, 1)
        }
    }
}

// Parse numeric value from string
Function.ParseNumeric {
    Input: str: Address
    Output: Integer
    Body: {
        result = 0
        i = 0
        
        WhileLoop LessThan(i, 20) {
            ch = GetByte(str, i)
            
            IfCondition EqualTo(ch, 0) ThenBlock: {
                BreakLoop
            }
            
            // Check if digit
            IfCondition Or(LessThan(ch, 48), GreaterThan(ch, 57)) ThenBlock: {
                BreakLoop
            }
            
            digit = Subtract(ch, 48)
            result = Add(Multiply(result, 10), digit)
            i = Add(i, 1)
        }
        
        ReturnValue(result)
    }
}

// Generate suffix for file name (aa, ab, ac... or 00, 01, 02...)
Function.GenerateSuffix {
    Input: num: Integer
    Input: suffix_len: Integer
    Output: Address
    Body: {
        suffix = Allocate(16)
        
        IfCondition NotEqual(SplitConfig.numeric_suffixes, 0) ThenBlock: {
            // Numeric suffixes: 00, 01, 02...
            temp_num = num
            i = Subtract(suffix_len, 1)
            
            WhileLoop GreaterEqual(i, 0) {
                digit = Modulo(temp_num, 10)
                SetByte(suffix, i, Add(48, digit))
                temp_num = Divide(temp_num, 10)
                i = Subtract(i, 1)
            }
            
            SetByte(suffix, suffix_len, 0)
        } ElseBlock: {
            // Alphabetic suffixes: aa, ab, ac...
            temp_num = num
            i = Subtract(suffix_len, 1)
            
            WhileLoop GreaterEqual(i, 0) {
                letter = Modulo(temp_num, 26)
                SetByte(suffix, i, Add(97, letter))
                temp_num = Divide(temp_num, 26)
                i = Subtract(i, 1)
            }
            
            SetByte(suffix, suffix_len, 0)
        }
        
        ReturnValue(suffix)
    }
}

// Split by lines
Function.SplitByLines {
    Input: input_fd: Integer
    Input: prefix: Address
    Body: {
        InitOutputBuffer()
        input_buffer = Allocate(262144)  // 256KB input buffer
        file_num = 0
        line_count = 0
        
        WhileLoop LessThan(0, 1) {
            bytes_read = SystemCall(0, input_fd, input_buffer, 262144)
            
            IfCondition LessEqual(bytes_read, 0) ThenBlock: {
                FlushOutputBuffer()
                BreakLoop
            }
            pos = 0
            
            WhileLoop LessThan(pos, bytes_read) {
                // Use MemChr to find next newline (SSE2!)
                remaining = Subtract(bytes_read, pos)
                search_ptr = Add(input_buffer, pos)
                newline_offset = MemChr(search_ptr, 10, remaining)
                
                IfCondition EqualTo(newline_offset, -1) ThenBlock: {
                    // No newline - write remaining bytes
                    IfCondition GreaterEqual(OutputBuffer.fd, 0) ThenBlock: {
                        BuffWrite(search_ptr, remaining)
                    }
                    BreakLoop
                }
                
                // Found newline - write line including newline
                line_len = Add(newline_offset, 1)
                
                // Open new file if needed
                IfCondition LessThan(OutputBuffer.fd, 0) ThenBlock: {
                    suffix = GenerateSuffix(file_num, SplitConfig.suffix_length)
                    filename = Allocate(256)
                    CopyString(filename, prefix)
                    AppendString(filename, suffix)
                    
                    OutputBuffer.fd = SystemCall(2, filename, 577, 420)
                    
                    IfCondition LessThan(OutputBuffer.fd, 0) ThenBlock: {
                        WriteStderr("split: cannot create '", 22)
                        WriteStderr(filename, GetStringLength(filename))
                        WriteStderr("'\n", 2)
                        Deallocate(filename, 256)
                        Deallocate(suffix, 16)
                        Deallocate(input_buffer, 262144)
                        Deallocate(OutputBuffer.buffer, 524288)
                        ReturnVoid
                    }
                    
                    Deallocate(filename, 256)
                    Deallocate(suffix, 16)
                    line_count = 0
                }
                
                // Buffer the line (will auto-flush if full)
                BuffWrite(search_ptr, line_len)
                line_count = Add(line_count, 1)
                
                // Close file if reached line limit
                IfCondition GreaterEqual(line_count, SplitConfig.lines_per_file) ThenBlock: {
                    FlushOutputBuffer()
                    SystemCall(3, OutputBuffer.fd)
                    OutputBuffer.fd = -1
                    file_num = Add(file_num, 1)
                }
                
                pos = Add(pos, line_len)
            }
        }
        // Close last file
        IfCondition GreaterEqual(OutputBuffer.fd, 0) ThenBlock: {
            FlushOutputBuffer()
            SystemCall(3, OutputBuffer.fd)
        }
        
        Deallocate(input_buffer, 262144)
        Deallocate(OutputBuffer.buffer, 524288)
    }
}

// Split by bytes
Function.SplitByBytes {
    Input: input_fd: Integer
    Input: prefix: Address
    Body: {
        InitOutputBuffer()
        input_buffer = Allocate(262144)
        file_num = 0
        byte_count = 0
        
        WhileLoop LessThan(0, 1) {
            bytes_read = SystemCall(0, input_fd, input_buffer, 262144)
            
            IfCondition LessEqual(bytes_read, 0) ThenBlock: {
                FlushOutputBuffer()
                BreakLoop
            }
            
            // Process buffer
            pos = 0
            WhileLoop LessThan(pos, bytes_read) {
                // Open new file if needed
                IfCondition LessThan(OutputBuffer.fd, 0) ThenBlock: {
                    suffix = GenerateSuffix(file_num, SplitConfig.suffix_length)
                    filename = Allocate(256)
                    CopyString(filename, prefix)
                    AppendString(filename, suffix)
                    
                    OutputBuffer.fd = SystemCall(2, filename, 577, 420)
                    
                    IfCondition LessThan(OutputBuffer.fd, 0) ThenBlock: {
                        WriteStderr("split: cannot create '", 22)
                        WriteStderr(filename, GetStringLength(filename))
                        WriteStderr("'\n", 2)
                        Deallocate(filename, 256)
                        Deallocate(suffix, 16)
                        Deallocate(input_buffer, 262144)
                        Deallocate(OutputBuffer.buffer, 524288)
                        ReturnVoid
                    }
                    
                    Deallocate(filename, 256)
                    Deallocate(suffix, 16)
                    byte_count = 0
                }
                
                // How many bytes can we write to current file?
                remaining_in_file = Subtract(SplitConfig.bytes_per_file, byte_count)
                remaining_in_buffer = Subtract(bytes_read, pos)
                to_write = remaining_in_buffer
                
                IfCondition LessThan(remaining_in_file, remaining_in_buffer) ThenBlock: {
                    to_write = remaining_in_file
                }
                
                // Buffer the bytes
                BuffWrite(Add(input_buffer, pos), to_write)
                byte_count = Add(byte_count, to_write)
                pos = Add(pos, to_write)
                
                // Close file if reached byte limit
                IfCondition GreaterEqual(byte_count, SplitConfig.bytes_per_file) ThenBlock: {
                    FlushOutputBuffer()
                    SystemCall(3, OutputBuffer.fd)
                    OutputBuffer.fd = -1
                    file_num = Add(file_num, 1)
                }
            }
        }
        
        // Close last file
        IfCondition GreaterEqual(OutputBuffer.fd, 0) ThenBlock: {
            FlushOutputBuffer()
            SystemCall(3, OutputBuffer.fd)
        }
        
        Deallocate(input_buffer, 262144)
        Deallocate(OutputBuffer.buffer, 524288)
    }
}

// Print help
Function.PrintHelp {
    Body: {
        WriteStdout("Usage: split [OPTION]... [FILE [PREFIX]]\n", 42)
        WriteStdout("Output pieces of FILE to PREFIXaa, PREFIXab, ...\n", 50)
        WriteStdout("Default PREFIX is 'x'.  With no FILE, or when FILE is -, read standard input.\n\n", 81)
        WriteStdout("  -b, --bytes=SIZE        put SIZE bytes per output file\n", 59)
        WriteStdout("  -l, --lines=NUMBER      put NUMBER lines per output file\n", 62)
        WriteStdout("  -d                      use numeric suffixes starting at 0, not alphabetic\n", 79)
        WriteStdout("  -a, --suffix-length=N   generate suffixes of length N (default 2)\n", 70)
        WriteStdout("      --help              display this help and exit\n", 54)
        WriteStdout("\n", 1)
        WriteStdout("Examples:\n", 10)
        WriteStdout("  split -l 1000 file.txt       Split into 1000-line chunks\n", 61)
        WriteStdout("  split -b 1M file.txt chunk   Split into 1MB chunks named chunk*\n", 68)
        WriteStdout("  split -d -l 100 file.txt     Use numeric suffixes (x00, x01...)\n", 68)
    }
}

Function.GetArgs {
    Output: Address
    Body: {
        fd = SystemCall(257, -100, "/proc/self/cmdline", 0, 0)
        IfCondition LessThan(fd, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        buffer = Allocate(4096)
        bytes_read = SystemCall(0, fd, buffer, 4096)
        SystemCall(3, fd)
        
        IfCondition LessEqual(bytes_read, 0) ThenBlock: {
            Deallocate(buffer, 4096)
            ReturnValue(0)
        }
        
        ReturnValue(buffer)
    }
}

SubRoutine.Main {
    args_buffer = GetArgs()
    
    IfCondition EqualTo(args_buffer, 0) ThenBlock: {
        WriteStderr("split: cannot read arguments\n", 29)
        SystemCall(60, 1)
    }
    
    // Skip program name
    pos = 0
    WhileLoop NotEqual(GetByte(args_buffer, pos), 0) {
        pos = Add(pos, 1)
    }
    pos = Add(pos, 1)
    
    // Parse options
    input_file = 0
    prefix = 0
    show_help = 0
    
    WhileLoop LessThan(pos, 4096) {
        ch = GetByte(args_buffer, pos)
        IfCondition EqualTo(ch, 0) ThenBlock: {
            BreakLoop
        }
        
        IfCondition EqualTo(ch, 45) ThenBlock: {
            next_ch = GetByte(args_buffer, Add(pos, 1))
            
            // --help
            IfCondition EqualTo(next_ch, 45) ThenBlock: {
                show_help = 1
            }
            
            // -l (lines)
            IfCondition EqualTo(next_ch, 108) ThenBlock: {
                // Skip to next arg for number
                WhileLoop NotEqual(GetByte(args_buffer, pos), 0) {
                    pos = Add(pos, 1)
                }
                pos = Add(pos, 1)
                
                num_str = Add(args_buffer, pos)
                SplitConfig.lines_per_file = ParseNumeric(num_str)
            }
            
            // -b (bytes)
            IfCondition EqualTo(next_ch, 98) ThenBlock: {
                // Skip to next arg for number
                WhileLoop NotEqual(GetByte(args_buffer, pos), 0) {
                    pos = Add(pos, 1)
                }
                pos = Add(pos, 1)
                
                num_str = Add(args_buffer, pos)
                SplitConfig.bytes_per_file = ParseNumeric(num_str)
            }
            
            // -d (numeric suffixes)
            IfCondition EqualTo(next_ch, 100) ThenBlock: {
                SplitConfig.numeric_suffixes = 1
            }
            
            // -a (suffix length)
            IfCondition EqualTo(next_ch, 97) ThenBlock: {
                // Skip to next arg for number
                WhileLoop NotEqual(GetByte(args_buffer, pos), 0) {
                    pos = Add(pos, 1)
                }
                pos = Add(pos, 1)
                
                num_str = Add(args_buffer, pos)
                SplitConfig.suffix_length = ParseNumeric(num_str)
            }
            
            // Skip to next argument
            WhileLoop NotEqual(GetByte(args_buffer, pos), 0) {
                pos = Add(pos, 1)
            }
            pos = Add(pos, 1)
        } ElseBlock: {
            // Non-option argument
            IfCondition EqualTo(input_file, 0) ThenBlock: {
                input_file = Add(args_buffer, pos)
            } ElseBlock: {
                IfCondition EqualTo(prefix, 0) ThenBlock: {
                    prefix = Add(args_buffer, pos)
                }
            }
            
            // Skip to next argument
            WhileLoop NotEqual(GetByte(args_buffer, pos), 0) {
                pos = Add(pos, 1)
            }
            pos = Add(pos, 1)
        }
    }
    
    // Show help if requested
    IfCondition NotEqual(show_help, 0) ThenBlock: {
        PrintHelp()
        Deallocate(args_buffer, 4096)
        SystemCall(60, 0)
    }
    
    // Default prefix
    IfCondition EqualTo(prefix, 0) ThenBlock: {
        default_prefix = Allocate(8)
        SetByte(default_prefix, 0, 120)  // 'x'
        SetByte(default_prefix, 1, 0)
        prefix = default_prefix
    }
    
    // Open input file (or use stdin)
    input_fd = 0
    IfCondition NotEqual(input_file, 0) ThenBlock: {
        input_fd = SystemCall(2, input_file, 0)
        
        IfCondition LessThan(input_fd, 0) ThenBlock: {
            WriteStderr("split: cannot open '", 20)
            WriteStderr(input_file, GetStringLength(input_file))
            WriteStderr("' for reading\n", 14)
            Deallocate(args_buffer, 4096)
            SystemCall(60, 1)
        }
    }
    
    // Split file
    IfCondition GreaterThan(SplitConfig.bytes_per_file, 0) ThenBlock: {
        SplitByBytes(input_fd, prefix)
    } ElseBlock: {
        SplitByLines(input_fd, prefix)
    }
    
    // Cleanup
    IfCondition NotEqual(input_fd, 0) ThenBlock: {
        SystemCall(3, input_fd)
    }
    
    Deallocate(args_buffer, 4096)
    SystemCall(60, 0)
}

RunTask(Main)