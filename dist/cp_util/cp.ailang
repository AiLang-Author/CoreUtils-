// cp.ailang - Enhanced Copy Utility with Full Unix Semantics
// Usage: cp [options] source... dest
// Options: 
//   -r, --recursive   Copy directories recursively
//   -f, --force       Force overwrite without prompting
//   -i, --interactive Prompt before overwrite
//   -v, --verbose     Explain what is being done
//   -p, --preserve    Preserve file attributes (mode, timestamps)
//   -n, --no-clobber  Do not overwrite existing files
//   -u, --update      Copy only when source is newer than dest
//   -L, --dereference Follow symbolic links
//   --debug           Show debug information

FixedPool.CpConfig {
    "recursive": Initialize=0
    "force": Initialize=0
    "interactive": Initialize=0
    "verbose": Initialize=0
    "preserve": Initialize=0
    "no_clobber": Initialize=0
    "update": Initialize=0
    "dereference": Initialize=0
    "debug": Initialize=0
}

FixedPool.CpConstants {
    "BUFFER_SIZE": Initialize=65536
    "O_RDONLY": Initialize=0
    "O_WRONLY": Initialize=1
    "O_CREAT": Initialize=64
    "O_TRUNC": Initialize=512
    "O_DIRECTORY": Initialize=65536
    "AT_FDCWD": Initialize=-100
    "DT_UNKNOWN": Initialize=0
    "DT_DIR": Initialize=4
    "DT_REG": Initialize=8
    "DT_LNK": Initialize=10
    "EEXIST": Initialize=17
    "EISDIR": Initialize=21
}

FixedPool.CpStats {
    "files_copied": Initialize=0
    "bytes_copied": Initialize=0
    "dirs_created": Initialize=0
    "skipped": Initialize=0
}

// ============================================================================
// UTILITY FUNCTIONS
// ============================================================================

Function.WriteStdout {
    Input: str: Address
    Body: {
        len = StringLength(str)
        SystemCall(1, 1, str, len)
    }
}

Function.WriteStderr {
    Input: str: Address
    Body: {
        len = StringLength(str)
        SystemCall(1, 2, str, len)
    }
}

Function.WriteDebug {
    Input: str: Address
    Body: {
        IfCondition EqualTo(CpConfig.debug, 1) ThenBlock: {
            WriteStderr("ðŸ” ")
            WriteStderr(str)
        }
    }
}

Function.WriteVerbose {
    Input: str: Address
    Body: {
        IfCondition EqualTo(CpConfig.verbose, 1) ThenBlock: {
            WriteStdout(str)
        }
    }
}

Function.WriteSuccess {
    Input: str: Address
    Body: {
        IfCondition EqualTo(CpConfig.verbose, 1) ThenBlock: {
            WriteStdout("âœ“ ")
            WriteStdout(str)
        }
    }
}

Function.WriteSyscallError {
    Input: error_code: Integer
    Body: {
        // Convert negative error code to positive errno
        errno = Subtract(0, error_code)
        
        // ETXTBSY = 26 (Text file busy)
        IfCondition EqualTo(errno, 26) ThenBlock: {
            WriteStderr("Text file busy")
            ReturnValue(0)
        }
        
        // EEXIST = 17 (File exists)
        IfCondition EqualTo(errno, 17) ThenBlock: {
            WriteStderr("File exists")
            ReturnValue(0)
        }
        
        WriteStderr("Unknown error ")
        // Fallback to printing the raw number if not recognized
    }
}

Function.IntToString {
    Input: num: Integer
    Output: Address
    Body: {
        // Handle zero
        IfCondition EqualTo(num, 0) ThenBlock: {
            str = Allocate(2)
            SetByte(str, 0, 48)  // '0'
            SetByte(str, 1, 0)
            ReturnValue(str)
        }
        
        // Handle negative numbers
        is_negative = LessThan(num, 0)
        abs_num = num
        IfCondition EqualTo(is_negative, 1) ThenBlock: {
            abs_num = Subtract(0, num)
        }
        
        // Count digits
        temp = abs_num
        digits = 0
        WhileLoop GreaterThan(temp, 0) {
            temp = Divide(temp, 10)
            digits = Add(digits, 1)
        }
        
        // Calculate total length
        total_len = digits
        IfCondition EqualTo(is_negative, 1) ThenBlock: {
            total_len = Add(total_len, 1)
        }
        
        str = Allocate(Add(total_len, 1))
        
        // Add minus sign if negative
        pos = 0
        IfCondition EqualTo(is_negative, 1) ThenBlock: {
            SetByte(str, 0, 45)  // '-'
            pos = 1
        }
        
        // Fill digits from right to left
        i = Subtract(total_len, 1)
        temp = abs_num
        WhileLoop GreaterThan(temp, 0) {
            digit = Modulo(temp, 10)
            SetByte(str, i, Add(48, digit))
            temp = Divide(temp, 10)
            i = Subtract(i, 1)
        }
        
        SetByte(str, total_len, 0)
        ReturnValue(str)
    }
}

// ============================================================================
// FILE SYSTEM OPERATIONS
// ============================================================================

Function.PathExists {
    Input: path: Address
    Output: Integer
    Body: {
        statbuf = Allocate(144)
        result = SystemCall(4, path, statbuf)
        Deallocate(statbuf, 144)
        ReturnValue(GreaterEqual(result, 0))
    }
}

Function.IsDirectory {
    Input: path: Address
    Output: Integer
    Body: {
        statbuf = Allocate(144)
        result = SystemCall(4, path, statbuf)
        
        IfCondition LessThan(result, 0) ThenBlock: {
            Deallocate(statbuf, 144)
            ReturnValue(0)
        }
        
        st_mode = Dereference(Add(statbuf, 24))
        Deallocate(statbuf, 144)
        
        // S_IFDIR = 0x4000
        is_dir = BitwiseAnd(st_mode, 16384)
        ReturnValue(NotEqual(is_dir, 0))
    }
}

Function.IsSymlink {
    Input: path: Address
    Output: Integer
    Body: {
        statbuf = Allocate(144)
        // Use lstat (syscall 6) to not follow symlinks
        result = SystemCall(6, path, statbuf)
        
        IfCondition LessThan(result, 0) ThenBlock: {
            Deallocate(statbuf, 144)
            ReturnValue(0)
        }
        
        st_mode = Dereference(Add(statbuf, 24))
        Deallocate(statbuf, 144)
        
        // S_IFLNK = 0xA000
        is_link = BitwiseAnd(st_mode, 40960)
        ReturnValue(NotEqual(is_link, 0))
    }
}

Function.GetFileMode {
    Input: path: Address
    Output: Integer
    Body: {
        statbuf = Allocate(144)
        result = SystemCall(4, path, statbuf)
        
        IfCondition LessThan(result, 0) ThenBlock: {
            Deallocate(statbuf, 144)
            ReturnValue(420)  // Default: 0644
        }
        
        st_mode = Dereference(Add(statbuf, 24))
        Deallocate(statbuf, 144)
        
        permissions = BitwiseAnd(st_mode, 4095)
        ReturnValue(permissions)
    }
}

Function.GetModTime {
    Input: path: Address
    Output: Integer
    Body: {
        statbuf = Allocate(144)
        result = SystemCall(4, path, statbuf)
        
        IfCondition LessThan(result, 0) ThenBlock: {
            Deallocate(statbuf, 144)
            ReturnValue(0)
        }
        
        // st_mtime at offset 88
        mtime = Dereference(Add(statbuf, 88))
        Deallocate(statbuf, 144)
        ReturnValue(mtime)
    }
}

Function.BuildPath {
    Input: dir: Address
    Input: file: Address
    Output: Address
    Body: {
        dir_len = StringLength(dir)
        file_len = StringLength(file)
        
        // Check if dir ends with slash
        needs_slash = 1
        IfCondition GreaterThan(dir_len, 0) ThenBlock: {
            last_char = GetByte(dir, Subtract(dir_len, 1))
            IfCondition EqualTo(last_char, 47) ThenBlock: {
                needs_slash = 0
            }
        }
        
        total_len = Add(Add(dir_len, file_len), Add(needs_slash, 1))
        path = Allocate(total_len)
        
        // Copy directory
        i = 0
        WhileLoop LessThan(i, dir_len) {
            SetByte(path, i, GetByte(dir, i))
            i = Add(i, 1)
        }
        
        // Add slash if needed
        IfCondition EqualTo(needs_slash, 1) ThenBlock: {
            SetByte(path, i, 47)
            i = Add(i, 1)
        }
        
        // Copy filename
        j = 0
        WhileLoop LessThan(j, file_len) {
            SetByte(path, i, GetByte(file, j))
            i = Add(i, 1)
            j = Add(j, 1)
        }
        
        SetByte(path, i, 0)
        ReturnValue(path)
    }
}

Function.GetBasename {
    Input: path: Address
    Output: Address
    Body: {
        len = StringLength(path)
        
        // Remove trailing slashes
        real_len = len
        WhileLoop And(GreaterThan(real_len, 0), EqualTo(GetByte(path, Subtract(real_len, 1)), 47)) {
            real_len = Subtract(real_len, 1)
        }
        
        // Find last slash in trimmed path
        last_slash = -1
        i = 0
        WhileLoop LessThan(i, real_len) {
            ch = GetByte(path, i)
            IfCondition EqualTo(ch, 47) ThenBlock: {
                last_slash = i
            }
            i = Add(i, 1)
        }
        
        start = Add(last_slash, 1)
        basename_len = Subtract(real_len, start)
        
        // Handle edge case: path is "/"
        IfCondition EqualTo(basename_len, 0) ThenBlock: {
            basename = Allocate(2)
            SetByte(basename, 0, 47)
            SetByte(basename, 1, 0)
            ReturnValue(basename)
        }
        
        basename = Allocate(Add(basename_len, 1))
        i = 0
        WhileLoop LessThan(i, basename_len) {
            SetByte(basename, i, GetByte(path, Add(start, i)))
            i = Add(i, 1)
        }
        SetByte(basename, basename_len, 0)
        
        ReturnValue(basename)
    }
}

Function.PromptOverwrite {
    Input: path: Address
    Output: Integer
    Body: {
        WriteStderr("cp: overwrite '")
        WriteStderr(path)
        WriteStderr("'? (y/n) ")
        
        response = Allocate(8)
        bytes = SystemCall(0, 0, response, 8)
        
        IfCondition LessEqual(bytes, 0) ThenBlock: {
            Deallocate(response, 8)
            ReturnValue(0)
        }
        
        ch = GetByte(response, 0)
        Deallocate(response, 8)
        
        // Accept y or Y
        result = Or(EqualTo(ch, 121), EqualTo(ch, 89))
        ReturnValue(result)
    }
}

// ============================================================================
// CORE COPY FUNCTIONS
// ============================================================================

Function.CpFile {
    Input: source: Address
    Input: dest: Address
    Output: Integer
    Body: {
        WriteDebug("Entering CpFile: ")
        WriteDebug(source)
        WriteDebug(" -> ")
        WriteDebug(dest)
        WriteDebug("\n")
        
        // Check if destination exists
        dest_exists = PathExists(dest)
        
        IfCondition EqualTo(dest_exists, 1) ThenBlock: {
            // Handle no-clobber
            IfCondition EqualTo(CpConfig.no_clobber, 1) ThenBlock: {
                WriteVerbose("skipped '")
                WriteVerbose(dest)
                WriteVerbose("' (already exists)\n")
                CpStats.skipped = Add(CpStats.skipped, 1)
                ReturnValue(0)
            }
            
            // Handle update mode
            IfCondition EqualTo(CpConfig.update, 1) ThenBlock: {
                src_mtime = GetModTime(source)
                dst_mtime = GetModTime(dest)
                
                IfCondition LessEqual(src_mtime, dst_mtime) ThenBlock: {
                    WriteVerbose("skipped '")
                    WriteVerbose(dest)
                    WriteVerbose("' (up to date)\n")
                    CpStats.skipped = Add(CpStats.skipped, 1)
                    ReturnValue(0)
                }
            }
            
            // Handle interactive mode
            IfCondition EqualTo(CpConfig.interactive, 1) ThenBlock: {
                should_overwrite = PromptOverwrite(dest)
                IfCondition EqualTo(should_overwrite, 0) ThenBlock: {
                    WriteVerbose("not overwritten\n")
                    CpStats.skipped = Add(CpStats.skipped, 1)
                    ReturnValue(0)
                }
            }
        }
        
        // Open source
        src_fd = SystemCall(2, source, CpConstants.O_RDONLY, 0)
        IfCondition LessThan(src_fd, 0) ThenBlock: {
            WriteStderr("cp: cannot open '")
            WriteStderr(source)
            WriteStderr("': ")
            WriteSyscallError(src_fd)
            WriteStderr("\n")
            ReturnValue(1)
        }
        
        // Get source permissions
        mode = 420
        IfCondition EqualTo(CpConfig.preserve, 1) ThenBlock: {
            mode = GetFileMode(source)
        }
        
        // Open/create destination
        flags = BitwiseOr(CpConstants.O_WRONLY, CpConstants.O_CREAT)
        flags = BitwiseOr(flags, CpConstants.O_TRUNC)
        
        dst_fd = SystemCall(2, dest, flags, mode)
        IfCondition LessThan(dst_fd, 0) ThenBlock: {
            WriteStderr("cp: cannot create '")
            WriteStderr(dest)
            WriteStderr("': ")
            WriteSyscallError(dst_fd)
            WriteStderr("\n")
            SystemCall(3, src_fd)
            ReturnValue(1)
        }
        
        // Copy data
        buffer = Allocate(CpConstants.BUFFER_SIZE)
        total_bytes = 0
        
        WhileLoop 1 {
            bytes_read = SystemCall(0, src_fd, buffer, CpConstants.BUFFER_SIZE)
            
            IfCondition LessEqual(bytes_read, 0) ThenBlock: {
                BreakLoop
            }
            
            bytes_written = SystemCall(1, dst_fd, buffer, bytes_read)
            
            IfCondition NotEqual(bytes_written, bytes_read) ThenBlock: {
                WriteStderr("cp: write error to '")
                WriteStderr(dest)
                WriteStderr("'\n")
                Deallocate(buffer, CpConstants.BUFFER_SIZE)
                SystemCall(3, src_fd)
                SystemCall(3, dst_fd)
                ReturnValue(1)
            }
            
            total_bytes = Add(total_bytes, bytes_written)
        }
        
        Deallocate(buffer, CpConstants.BUFFER_SIZE)
        SystemCall(3, src_fd)
        SystemCall(3, dst_fd)
        
        // Update statistics
        CpStats.files_copied = Add(CpStats.files_copied, 1)
        CpStats.bytes_copied = Add(CpStats.bytes_copied, total_bytes)
        
        // Verbose output
        WriteSuccess("'")
        WriteSuccess(source)
        WriteSuccess("' -> '")
        WriteSuccess(dest)
        WriteSuccess("' (")
        bytes_str = IntToString(total_bytes)
        WriteSuccess(bytes_str)
        Deallocate(bytes_str, 0)
        WriteSuccess(" bytes)\n")
        
        ReturnValue(0)
    }
}

Function.CpDirectory {
    Input: source: Address
    Input: dest: Address
    Output: Integer
    Body: {
        WriteDebug("Entering CpDirectory: ")
        WriteDebug(source)
        WriteDebug(" -> ")
        WriteDebug(dest)
        WriteDebug("\n")
        
        // Create destination directory
        mkdir_result = SystemCall(83, dest, 493)  // 0755
        
        IfCondition LessThan(mkdir_result, 0) ThenBlock: {
            // Check if EEXIST
            abs_error = Subtract(0, mkdir_result)
            IfCondition EqualTo(abs_error, CpConstants.EEXIST) ThenBlock: {
                // Directory exists - verify it's actually a directory
                is_dir = IsDirectory(dest)
                IfCondition EqualTo(is_dir, 0) ThenBlock: {
                    WriteStderr("cp: cannot overwrite non-directory '")
                    WriteStderr(dest)
                    WriteStderr("' with directory '")
                    WriteStderr(source)
                    WriteStderr("'\n")
                    ReturnValue(1)
                }
                WriteDebug("Directory already exists, continuing\n")
            } ElseBlock: {
                WriteStderr("cp: cannot create directory '")
                WriteStderr(dest)
                WriteStderr("': ")
                WriteSyscallError(mkdir_result)
                WriteStderr("\n")
                ReturnValue(1)
            }
        } ElseBlock: {
            CpStats.dirs_created = Add(CpStats.dirs_created, 1)
            WriteVerbose("created directory '")
            WriteVerbose(dest)
            WriteVerbose("'\n")
        }
        
        // Open source directory
        flags = BitwiseOr(CpConstants.O_RDONLY, CpConstants.O_DIRECTORY)
        dir_fd = SystemCall(257, CpConstants.AT_FDCWD, source, flags, 0)
        
        IfCondition LessThan(dir_fd, 0) ThenBlock: {
            WriteStderr("cp: cannot open directory '")
            WriteStderr(source)
            WriteStderr("': ")
            WriteSyscallError(dir_fd)
            WriteStderr("\n")
            ReturnValue(1)
        }
        
        // Read directory entries
        buffer = Allocate(32768)
        errors = 0
        
        WhileLoop 1 {
            bytes_read = SystemCall(217, dir_fd, buffer, 32768)
            
            IfCondition LessEqual(bytes_read, 0) ThenBlock: {
                BreakLoop
            }
            
            // Parse entries
            pos = 0
            WhileLoop LessThan(pos, bytes_read) {
                // Read d_reclen (2 bytes at offset 16)
                d_reclen = Add(GetByte(buffer, Add(pos, 16)), 
                              Multiply(GetByte(buffer, Add(pos, 17)), 256))
                d_type = GetByte(buffer, Add(pos, 18))
                name_start = Add(pos, 19)
                
                // Extract name
                name_len = 0
                WhileLoop 1 {
                    ch = GetByte(buffer, Add(name_start, name_len))
                    IfCondition EqualTo(ch, 0) ThenBlock: {
                        BreakLoop
                    }
                    name_len = Add(name_len, 1)
                }
                
                name = Allocate(Add(name_len, 1))
                i = 0
                WhileLoop LessThan(i, name_len) {
                    SetByte(name, i, GetByte(buffer, Add(name_start, i)))
                    i = Add(i, 1)
                }
                SetByte(name, name_len, 0)
                
                // Skip "." and ".."
                is_dot = And(EqualTo(name_len, 1), EqualTo(GetByte(name, 0), 46))
                is_dotdot = And(EqualTo(name_len, 2), 
                               And(EqualTo(GetByte(name, 0), 46), 
                                   EqualTo(GetByte(name, 1), 46)))
                
                IfCondition Not(Or(is_dot, is_dotdot)) ThenBlock: {
                    src_path = BuildPath(source, name)
                    dst_path = BuildPath(dest, name)
                    
                    copy_result = 0
                    
                    // Handle different file types
                    IfCondition EqualTo(d_type, CpConstants.DT_DIR) ThenBlock: {
                        copy_result = CpDirectory(src_path, dst_path)
                    } ElseBlock: {
                        IfCondition EqualTo(d_type, CpConstants.DT_LNK) ThenBlock: {
                            // Symlink handling
                            IfCondition EqualTo(CpConfig.dereference, 1) ThenBlock: {
                                // Follow the link
                                is_dir = IsDirectory(src_path)
                                IfCondition EqualTo(is_dir, 1) ThenBlock: {
                                    copy_result = CpDirectory(src_path, dst_path)
                                } ElseBlock: {
                                    copy_result = CpFile(src_path, dst_path)
                                }
                            } ElseBlock: {
                                WriteVerbose("skipped symlink '")
                                WriteVerbose(src_path)
                                WriteVerbose("'\n")
                                CpStats.skipped = Add(CpStats.skipped, 1)
                            }
                        } ElseBlock: {
                            // Regular file or unknown type - try to copy as file
                            copy_result = CpFile(src_path, dst_path)
                        }
                    }
                    
                    IfCondition NotEqual(copy_result, 0) ThenBlock: {
                        errors = Add(errors, 1)
                    }
                    
                    Deallocate(src_path, 0)
                    Deallocate(dst_path, 0)
                }
                
                Deallocate(name, Add(name_len, 1))
                pos = Add(pos, d_reclen)
            }
        }
        
        Deallocate(buffer, 32768)
        SystemCall(3, dir_fd)
        
        ReturnValue(errors)
    }
}

// ============================================================================
// ARGUMENT PARSING
// ============================================================================

Function.GetArgs {
    Output: Address
    Body: {
        fd = SystemCall(257, -100, "/proc/self/cmdline", 0, 0)
        IfCondition LessThan(fd, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        buffer = Allocate(4096)
        bytes_read = SystemCall(0, fd, buffer, 4096)
        SystemCall(3, fd)
        
        IfCondition LessEqual(bytes_read, 0) ThenBlock: {
            Deallocate(buffer, 4096)
            ReturnValue(0)
        }
        
        ReturnValue(buffer)
    }
}

Function.StringCompare {
    Input: str1: Address
    Input: str2: Address
    Output: Integer
    Body: {
        i = 0
        WhileLoop 1 {
            ch1 = GetByte(str1, i)
            ch2 = GetByte(str2, i)
            
            IfCondition NotEqual(ch1, ch2) ThenBlock: {
                ReturnValue(0)
            }
            
            IfCondition EqualTo(ch1, 0) ThenBlock: {
                ReturnValue(1)
            }
            
            i = Add(i, 1)
        }
        ReturnValue(1)
    }
}

Function.ShowHelp {
    Body: {
        WriteStdout("Usage: cp [OPTION]... SOURCE... DEST\n")
        WriteStdout("Copy SOURCE to DEST, or multiple SOURCE(s) to DIRECTORY.\n")
        WriteStdout("\nOptions:\n")
        WriteStdout("  -r, --recursive       copy directories recursively\n")
        WriteStdout("  -f, --force           force overwrite (implies -n is off)\n")
        WriteStdout("  -i, --interactive     prompt before overwrite\n")
        WriteStdout("  -n, --no-clobber      do not overwrite existing files\n")
        WriteStdout("  -u, --update          copy only when source is newer\n")
        WriteStdout("  -v, --verbose         explain what is being done\n")
        WriteStdout("  -p, --preserve        preserve file attributes\n")
        WriteStdout("  -L, --dereference     follow symbolic links\n")
        WriteStdout("      --debug           show debug information\n")
        WriteStdout("      --help            display this help and exit\n")
    }
}

// ============================================================================
// MAIN ROUTINE
// ============================================================================

SubRoutine.Main {
    args_buffer = GetArgs()
    
    IfCondition EqualTo(args_buffer, 0) ThenBlock: {
        WriteStderr("cp: failed to read arguments\n")
        SystemCall(60, 1)
    }
    
    // Skip program name
    pos = 0
    WhileLoop NotEqual(GetByte(args_buffer, pos), 0) {
        pos = Add(pos, 1)
    }
    pos = Add(pos, 1)
    
    // Collect source files
    max_sources = 128
    sources = ArrayCreate(max_sources)
    source_count = 0
    dest = 0
    
    // Parse arguments
    WhileLoop LessThan(pos, 4096) {
        ch = GetByte(args_buffer, pos)
        IfCondition EqualTo(ch, 0) ThenBlock: {
            BreakLoop
        }
        
        first = GetByte(args_buffer, pos)
        
        IfCondition EqualTo(first, 45) ThenBlock: {
            // Potential flag
            arg_start = pos
            arg_len = 0
            
            WhileLoop And(LessThan(pos, 4096), NotEqual(GetByte(args_buffer, pos), 0)) {
                arg_len = Add(arg_len, 1)
                pos = Add(pos, 1)
            }
            
            // Build flag string
            flag = Allocate(Add(arg_len, 1))
            i = 0
            WhileLoop LessThan(i, arg_len) {
                SetByte(flag, i, GetByte(args_buffer, Add(arg_start, i)))
                i = Add(i, 1)
            }
            SetByte(flag, arg_len, 0)
            
            // Check for long options
            IfCondition StringCompare(flag, "--help") ThenBlock: {
                ShowHelp()
                Deallocate(flag, Add(arg_len, 1))
                Deallocate(sources, Multiply(max_sources, 8))
                Deallocate(args_buffer, 4096)
                SystemCall(60, 0)
            }
            
            IfCondition StringCompare(flag, "--debug") ThenBlock: {
                CpConfig.debug = 1
            }
            
            IfCondition StringCompare(flag, "--recursive") ThenBlock: {
                CpConfig.recursive = 1
            }
            
            IfCondition StringCompare(flag, "--force") ThenBlock: {
                CpConfig.force = 1
                CpConfig.no_clobber = 0
            }
            
            IfCondition StringCompare(flag, "--interactive") ThenBlock: {
                CpConfig.interactive = 1
            }
            
            IfCondition StringCompare(flag, "--verbose") ThenBlock: {
                CpConfig.verbose = 1
            }
            
            IfCondition StringCompare(flag, "--preserve") ThenBlock: {
                CpConfig.preserve = 1
            }
            
            IfCondition StringCompare(flag, "--no-clobber") ThenBlock: {
                CpConfig.no_clobber = 1
            }
            
            IfCondition StringCompare(flag, "--update") ThenBlock: {
                CpConfig.update = 1
            }
            
            IfCondition StringCompare(flag, "--dereference") ThenBlock: {
                CpConfig.dereference = 1
            }
            
            // Parse short options
            i = 1
            WhileLoop LessThan(i, arg_len) {
                flag_char = GetByte(flag, i)
                
                IfCondition EqualTo(flag_char, 114) ThenBlock: { CpConfig.recursive = 1 }
                IfCondition EqualTo(flag_char, 102) ThenBlock: { 
                    CpConfig.force = 1
                    CpConfig.no_clobber = 0
                }
                IfCondition EqualTo(flag_char, 105) ThenBlock: { CpConfig.interactive = 1 }
                IfCondition EqualTo(flag_char, 118) ThenBlock: { CpConfig.verbose = 1 }
                IfCondition EqualTo(flag_char, 112) ThenBlock: { CpConfig.preserve = 1 }
                IfCondition EqualTo(flag_char, 110) ThenBlock: { CpConfig.no_clobber = 1 }
                IfCondition EqualTo(flag_char, 117) ThenBlock: { CpConfig.update = 1 }
                IfCondition EqualTo(flag_char, 76) ThenBlock: { CpConfig.dereference = 1 }
                
                i = Add(i, 1)
            }
            
            Deallocate(flag, Add(arg_len, 1))
        } ElseBlock: {
            // File argument
            file_start = pos
            file_len = 0
            
            WhileLoop And(LessThan(pos, 4096), NotEqual(GetByte(args_buffer, pos), 0)) {
                file_len = Add(file_len, 1)
                pos = Add(pos, 1)
            }
            
            filename = Allocate(Add(file_len, 1))
            i = 0
            WhileLoop LessThan(i, file_len) {
                SetByte(filename, i, GetByte(args_buffer, Add(file_start, i)))
                i = Add(i, 1)
            }
            SetByte(filename, file_len, 0)
            
            // Add to sources array
            IfCondition LessThan(source_count, max_sources) ThenBlock: {
                ArraySet(sources, source_count, filename)
                source_count = Add(source_count, 1)
            }
        }
        
        pos = Add(pos, 1)
    }
    
    Deallocate(args_buffer, 4096)
    
    // Need at least 2 arguments (source and dest)
    IfCondition LessThan(source_count, 2) ThenBlock: {
        WriteStderr("cp: missing file operand\n")
        WriteStderr("Try 'cp --help' for more information.\n")
        ArrayDestroy(sources)
        SystemCall(60, 1)
    }
    
    // Last argument is destination
    source_count = Subtract(source_count, 1)
    dest = ArrayGet(sources, source_count)
    
    WriteDebug("Configuration:\n")
    WriteDebug("  recursive: ")
    dbg_str = IntToString(CpConfig.recursive)
    WriteDebug(dbg_str)
    Deallocate(dbg_str, 0)
    WriteDebug("\n  verbose: ")
    dbg_str = IntToString(CpConfig.verbose)
    WriteDebug(dbg_str)
    Deallocate(dbg_str, 0)
    WriteDebug("\n  sources: ")
    dbg_str = IntToString(source_count)
    WriteDebug(dbg_str)
    Deallocate(dbg_str, 0)
    WriteDebug("\n  dest: ")
    WriteDebug(dest)
    WriteDebug("\n\n")
    
    // Check if destination is a directory when copying multiple sources
    dest_is_dir = IsDirectory(dest)
    
    IfCondition GreaterThan(source_count, 1) ThenBlock: {
        IfCondition EqualTo(dest_is_dir, 0) ThenBlock: {
            WriteStderr("cp: target '")
            WriteStderr(dest)
            WriteStderr("' is not a directory\n")
            ArrayDestroy(sources)
            SystemCall(60, 1)
        }
    }
    
    // Process each source
    total_errors = 0
    i = 0
    WhileLoop LessThan(i, source_count) {
        source = ArrayGet(sources, i)
        
        src_is_dir = IsDirectory(source)
        
        // Determine final destination
        final_dest = dest
        IfCondition EqualTo(dest_is_dir, 1) ThenBlock: {
            basename = GetBasename(source)
            final_dest = BuildPath(dest, basename)
            Deallocate(basename, 0)
        }
        
        // Copy based on source type
        result = 0
        IfCondition EqualTo(src_is_dir, 1) ThenBlock: {
            IfCondition EqualTo(CpConfig.recursive, 0) ThenBlock: {
                WriteStderr("cp: -r not specified; omitting directory '")
                WriteStderr(source)
                WriteStderr("'\n")
                result = 1
            } ElseBlock: {
                result = CpDirectory(source, final_dest)
            }
        } ElseBlock: {
            result = CpFile(source, final_dest)
        }
        
        IfCondition NotEqual(result, 0) ThenBlock: {
            total_errors = Add(total_errors, 1)
        }
        
        // Free final_dest if we allocated it
        IfCondition EqualTo(dest_is_dir, 1) ThenBlock: {
            Deallocate(final_dest, 0)
        }
        
        Deallocate(source, 0)
        i = Add(i, 1)
    }
    
    ArrayDestroy(sources)
    
    // Show summary if verbose
    IfCondition EqualTo(CpConfig.verbose, 1) ThenBlock: {
        WriteStdout("\nðŸ“Š Summary:\n")
        WriteStdout("  Files copied: ")
        sum_str = IntToString(CpStats.files_copied)
        WriteStdout(sum_str)
        Deallocate(sum_str, 0)
        WriteStdout("\n  Directories created: ")
        sum_str = IntToString(CpStats.dirs_created)
        WriteStdout(sum_str)
        Deallocate(sum_str, 0)
        WriteStdout("\n  Bytes copied: ")
        sum_str = IntToString(CpStats.bytes_copied)
        WriteStdout(sum_str)
        Deallocate(sum_str, 0)
        WriteStdout("\n  Skipped: ")
        sum_str = IntToString(CpStats.skipped)
        WriteStdout(sum_str)
        Deallocate(sum_str, 0)
        WriteStdout("\n  Errors: ")
        sum_str = IntToString(total_errors)
        WriteStdout(sum_str)
        Deallocate(sum_str, 0)
        WriteStdout("\n")
    }
    
    exit_code = 0
    IfCondition GreaterThan(total_errors, 0) ThenBlock: {
        exit_code = 1
    }
    
    SystemCall(60, exit_code)
}

RunTask(Main)