// du.ailang - Estimate file space usage
// Usage: du [OPTIONS] [FILE...]

FixedPool.DuConfig {
    "human_readable": Initialize=0
    "summarize": Initialize=0
    "all_files": Initialize=0
    "max_depth": Initialize=0
    "apparent_size": Initialize=0
    "total_only": Initialize=0
}

FixedPool.DuStats {
    "grand_total": Initialize=0
}

Function.PrintHelp {
    Body: {
        WriteStdout("Usage: du [OPTION]... [FILE]...\n", 33)
        WriteStdout("  or:  du [OPTION]... --files0-from=F\n", 39)
        WriteStdout("Summarize disk usage of the set of FILEs, recursively for directories.\n\n", 73)
        WriteStdout("Mandatory arguments to long options are mandatory for short options too.\n", 74)
        WriteStdout("  -a, --all             write counts for all files, not just directories\n", 74)
        WriteStdout("  -c, --total           produce a grand total\n", 47)
        WriteStdout("  -h, --human-readable  print sizes in human readable format (e.g., 1K 234M 2G)\n", 82)
        WriteStdout("  -s, --summarize       display only a total for each argument\n", 64)
        WriteStdout("      --help            display this help and exit\n", 52)
        WriteStdout("\n", 1)
        WriteStdout("SIZE is an integer and optional unit (example: 10M is 10*1024*1024).\n", 71)
        WriteStdout("Units are K, M, G, T, P, E, Z, Y (powers of 1024).\n\n", 53)
        WriteStdout("Examples:\n", 10)
        WriteStdout("  du -h               Show disk usage in human readable format\n", 64)
        WriteStdout("  du -sh /var         Show only total for /var\n", 48)
        WriteStdout("  du -a /home         Show all files in /home\n", 47)
        WriteStdout("  du -c dir1 dir2     Show totals with grand total\n", 52)
    }
}

Function.WriteStdout {
    Input: buffer: Address
    Input: len: Integer
    Body: {
        SystemCall(1, 1, buffer, len)
    }
}

Function.WriteStderr {
    Input: buffer: Address
    Input: len: Integer
    Body: {
        SystemCall(1, 2, buffer, len)
    }
}

Function.GetStringLength {
    Input: str: Address
    Output: Integer
    Body: {
        len = 0
        WhileLoop NotEqual(GetByte(str, len), 0) {
            len = Add(len, 1)
        }
        ReturnValue(len)
    }
}

Function.ConvertNumberToString {
    Input: num: Integer
    Output: Address
    Body: {
        buffer = Allocate(32)
        
        IfCondition EqualTo(num, 0) ThenBlock: {
            SetByte(buffer, 0, 48)
            SetByte(buffer, 1, 0)
            ReturnValue(buffer)
        }
        
        is_neg = 0
        IfCondition LessThan(num, 0) ThenBlock: {
            is_neg = 1
            num = Subtract(0, num)
        }
        
        pos = 0
        temp = Allocate(32)
        
        WhileLoop GreaterThan(num, 0) {
            digit = Modulo(num, 10)
            SetByte(temp, pos, Add(48, digit))
            pos = Add(pos, 1)
            num = Divide(num, 10)
        }
        
        write_pos = 0
        IfCondition NotEqual(is_neg, 0) ThenBlock: {
            SetByte(buffer, 0, 45)
            write_pos = 1
        }
        
        i = Subtract(pos, 1)
        WhileLoop GreaterEqual(i, 0) {
            ch = GetByte(temp, i)
            SetByte(buffer, write_pos, ch)
            write_pos = Add(write_pos, 1)
            i = Subtract(i, 1)
        }
        
        SetByte(buffer, write_pos, 0)
        Deallocate(temp, 32)
        
        ReturnValue(buffer)
    }
}

Function.CopyString {
    Input: dest: Address
    Input: src: Address
    Body: {
        i = 0
        WhileLoop LessThan(i, 1000) {
            ch = GetByte(src, i)
            SetByte(dest, i, ch)
            IfCondition EqualTo(ch, 0) ThenBlock: {
                BreakLoop
            }
            i = Add(i, 1)
        }
    }
}

Function.AppendString {
    Input: dest: Address
    Input: src: Address
    Body: {
        i = 0
        WhileLoop LessThan(i, 1000) {
            IfCondition EqualTo(GetByte(dest, i), 0) ThenBlock: {
                BreakLoop
            }
            i = Add(i, 1)
        }
        
        j = 0
        WhileLoop LessThan(j, 100) {
            ch = GetByte(src, j)
            SetByte(dest, i, ch)
            IfCondition EqualTo(ch, 0) ThenBlock: {
                BreakLoop
            }
            i = Add(i, 1)
            j = Add(j, 1)
        }
    }
}

// Format size in human-readable form
Function.FormatHumanSize {
    Input: bytes: Integer
    Output: Address
    Body: {
        buffer = Allocate(32)
        
        IfCondition LessThan(bytes, 1024) ThenBlock: {
            num_str = ConvertNumberToString(bytes)
            CopyString(buffer, num_str)
            AppendString(buffer, "B")
            Deallocate(num_str, 32)
            ReturnValue(buffer)
        }
        
        kb = Divide(bytes, 1024)
        IfCondition LessThan(kb, 1024) ThenBlock: {
            num_str = ConvertNumberToString(kb)
            CopyString(buffer, num_str)
            AppendString(buffer, "K")
            Deallocate(num_str, 32)
            ReturnValue(buffer)
        }
        
        mb = Divide(kb, 1024)
        IfCondition LessThan(mb, 1024) ThenBlock: {
            num_str = ConvertNumberToString(mb)
            CopyString(buffer, num_str)
            AppendString(buffer, "M")
            Deallocate(num_str, 32)
            ReturnValue(buffer)
        }
        
        gb = Divide(mb, 1024)
        IfCondition LessThan(gb, 1024) ThenBlock: {
            num_str = ConvertNumberToString(gb)
            CopyString(buffer, num_str)
            AppendString(buffer, "G")
            Deallocate(num_str, 32)
            ReturnValue(buffer)
        }
        
        tb = Divide(gb, 1024)
        num_str = ConvertNumberToString(tb)
        CopyString(buffer, num_str)
        AppendString(buffer, "T")
        Deallocate(num_str, 32)
        
        ReturnValue(buffer)
    }
}

// Get 64-bit value from buffer
Function.GetUInt64 {
    Input: addr: Address
    Input: offset: Integer
    Output: Integer
    Body: {
        ptr = Add(addr, offset)
        
        b0 = GetByte(ptr, 0)
        b1 = GetByte(ptr, 1)
        b2 = GetByte(ptr, 2)
        b3 = GetByte(ptr, 3)
        b4 = GetByte(ptr, 4)
        b5 = GetByte(ptr, 5)
        b6 = GetByte(ptr, 6)
        b7 = GetByte(ptr, 7)
        
        value = Add(b0, Multiply(b1, 256))
        value = Add(value, Multiply(b2, 65536))
        value = Add(value, Multiply(b3, 16777216))
        
        ReturnValue(value)
    }
}

// Get file/directory size
Function.CalculateFileSize {
    Input: path: Address
    Output: Integer
    Body: {
        statbuf = Allocate(144)
        
        // stat syscall: 4 on x86_64
        result = SystemCall(4, path, statbuf)
        
        IfCondition LessThan(result, 0) ThenBlock: {
            Deallocate(statbuf, 144)
            ReturnValue(0)
        }
        
        // Get size based on mode
        IfCondition NotEqual(DuConfig.apparent_size, 0) ThenBlock: {
            // Use st_size (apparent size)
            size = GetUInt64(statbuf, 48)
        } ElseBlock: {
            // Use st_blocks * 512 (disk usage)
            blocks = GetUInt64(statbuf, 64)
            size = Multiply(blocks, 512)
        }
        
        Deallocate(statbuf, 144)
        ReturnValue(size)
    }
}

// Check if path is a directory
Function.IsDirectory {
    Input: path: Address
    Output: Integer
    Body: {
        statbuf = Allocate(144)
        
        result = SystemCall(4, path, statbuf)
        
        IfCondition LessThan(result, 0) ThenBlock: {
            Deallocate(statbuf, 144)
            ReturnValue(0)
        }
        
        // Get st_mode at offset 24 (4 bytes)
        b0 = GetByte(statbuf, 24)
        b1 = GetByte(statbuf, 25)
        b2 = GetByte(statbuf, 26)
        b3 = GetByte(statbuf, 27)
        
        mode = Add(b0, Multiply(b1, 256))
        mode = Add(mode, Multiply(b2, 65536))
        mode = Add(mode, Multiply(b3, 16777216))
        
        // Check if S_IFDIR (0x4000)
        file_type = BitwiseAnd(mode, 61440)
        is_dir = EqualTo(file_type, 16384)
        
        Deallocate(statbuf, 144)
        ReturnValue(is_dir)
    }
}

// Calculate directory size recursively
Function.CalculateDirectorySize {
    Input: path: Address
    Input: depth: Integer
    Output: Integer
    Body: {
        total_size = 0
        
        // Open directory using openat syscall: 257
        fd = SystemCall(257, -100, path, 0, 0)
        
        IfCondition LessThan(fd, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        // Read directory entries using getdents64: syscall 217
        buffer = Allocate(4096)
        
        WhileLoop LessThan(0, 1) {
            bytes_read = SystemCall(217, fd, buffer, 4096)
            
            IfCondition LessEqual(bytes_read, 0) ThenBlock: {
                BreakLoop
            }
            
            // Parse directory entries
            pos = 0
            WhileLoop LessThan(pos, bytes_read) {
                // struct linux_dirent64:
                // 0: d_ino (8 bytes)
                // 8: d_off (8 bytes)
                // 16: d_reclen (2 bytes)
                // 18: d_type (1 byte)
                // 19: d_name (variable)
                
                d_reclen_lo = GetByte(buffer, Add(pos, 16))
                d_reclen_hi = GetByte(buffer, Add(pos, 17))
                d_reclen = Add(d_reclen_lo, Multiply(d_reclen_hi, 256))
                
                d_type = GetByte(buffer, Add(pos, 18))
                name_offset = Add(pos, 19)
                
                // Get name
                name_start = Add(buffer, name_offset)
                first_char = GetByte(name_start, 0)
                
                // Skip . and ..
                skip = 0
                IfCondition EqualTo(first_char, 46) ThenBlock: {
                    second_char = GetByte(name_start, 1)
                    IfCondition Or(EqualTo(second_char, 0), EqualTo(second_char, 46)) ThenBlock: {
                        skip = 1
                    }
                }
                
                IfCondition EqualTo(skip, 0) ThenBlock: {
                    // Build full path
                    full_path = Allocate(512)
                    CopyString(full_path, path)
                    
                    // Add / if needed
                    path_len = GetStringLength(path)
                    last_char = GetByte(path, Subtract(path_len, 1))
                    IfCondition NotEqual(last_char, 47) ThenBlock: {
                        SetByte(full_path, path_len, 47)
                        SetByte(full_path, Add(path_len, 1), 0)
                    }
                    
                    AppendString(full_path, name_start)
                    
                    // Get file size
                    file_size = CalculateFileSize(full_path)
                    total_size = Add(total_size, file_size)
                    
                    // If directory, recurse
                    IfCondition EqualTo(d_type, 4) ThenBlock: {
                        subdir_size = CalculateDirectorySize(full_path, Add(depth, 1))
                        total_size = Add(total_size, subdir_size)
                        
                        // Print subdirectory if at depth 0 and not in summarize mode
                        IfCondition And(EqualTo(depth, 0), EqualTo(DuConfig.summarize, 0)) ThenBlock: {
                            PrintSize(subdir_size, full_path)
                        }
                    } ElseBlock: {
                        // Print file if all_files mode and at depth 0
                        IfCondition And(NotEqual(DuConfig.all_files, 0), EqualTo(depth, 0)) ThenBlock: {
                            PrintSize(file_size, full_path)
                        }
                    }
                    
                    Deallocate(full_path, 512)
                }
                
                pos = Add(pos, d_reclen)
            }
        }
        
        Deallocate(buffer, 4096)
        SystemCall(3, fd)
        
        ReturnValue(total_size)
    }
}

// Print size and path
Function.PrintSize {
    Input: size: Integer
    Input: path: Address
    Body: {
        // Convert to KB for display
        size_kb = Divide(size, 1024)
        
        IfCondition NotEqual(DuConfig.human_readable, 0) ThenBlock: {
            size_str = FormatHumanSize(size)
            WriteStdout(size_str, GetStringLength(size_str))
            Deallocate(size_str, 32)
        } ElseBlock: {
            size_str = ConvertNumberToString(size_kb)
            WriteStdout(size_str, GetStringLength(size_str))
            Deallocate(size_str, 32)
        }
        
        WriteStdout("\t", 1)
        WriteStdout(path, GetStringLength(path))
        WriteStdout("\n", 1)
    }
}

Function.GetArgs {
    Output: Address
    Body: {
        fd = SystemCall(257, -100, "/proc/self/cmdline", 0, 0)
        IfCondition LessThan(fd, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        buffer = Allocate(4096)
        bytes_read = SystemCall(0, fd, buffer, 4096)
        SystemCall(3, fd)
        
        IfCondition LessEqual(bytes_read, 0) ThenBlock: {
            Deallocate(buffer, 4096)
            ReturnValue(0)
        }
        
        ReturnValue(buffer)
    }
}

SubRoutine.Main {
    args_buffer = GetArgs()
    
    IfCondition EqualTo(args_buffer, 0) ThenBlock: {
        WriteStderr("du: cannot read arguments\n", 26)
        SystemCall(60, 1)
    }
    
    // Skip program name
    pos = 0
    WhileLoop NotEqual(GetByte(args_buffer, pos), 0) {
        pos = Add(pos, 1)
    }
    pos = Add(pos, 1)
    
    // Parse options
    has_files = 0
    show_help = 0
    
    WhileLoop LessThan(pos, 4096) {
        ch = GetByte(args_buffer, pos)
        IfCondition EqualTo(ch, 0) ThenBlock: {
            BreakLoop
        }
        
        IfCondition EqualTo(ch, 45) ThenBlock: {
            next_ch = GetByte(args_buffer, Add(pos, 1))
            
            // Check for --help (double dash)
            IfCondition EqualTo(next_ch, 45) ThenBlock: {
                h_char = GetByte(args_buffer, Add(pos, 2))
                e_char = GetByte(args_buffer, Add(pos, 3))
                l_char = GetByte(args_buffer, Add(pos, 4))
                p_char = GetByte(args_buffer, Add(pos, 5))
                
                // Check "help"
                IfCondition And(EqualTo(h_char, 104), And(EqualTo(e_char, 101), And(EqualTo(l_char, 108), EqualTo(p_char, 112)))) ThenBlock: {
                    show_help = 1
                }
            }
            
            // -h (human readable)
            IfCondition EqualTo(next_ch, 104) ThenBlock: {
                DuConfig.human_readable = 1
            }
            
            // -s (summarize)
            IfCondition EqualTo(next_ch, 115) ThenBlock: {
                DuConfig.summarize = 1
            }
            
            // -a (all files)
            IfCondition EqualTo(next_ch, 97) ThenBlock: {
                DuConfig.all_files = 1
            }
            
            // -c (total)
            IfCondition EqualTo(next_ch, 99) ThenBlock: {
                DuConfig.total_only = 1
            }
            
            // Skip to next argument
            WhileLoop NotEqual(GetByte(args_buffer, pos), 0) {
                pos = Add(pos, 1)
            }
            pos = Add(pos, 1)
        } ElseBlock: {
            has_files = 1
            BreakLoop
        }
    }
    
    // Show help if requested
    IfCondition NotEqual(show_help, 0) ThenBlock: {
        PrintHelp()
        Deallocate(args_buffer, 4096)
        SystemCall(60, 0)
    }
    
    // If no files specified, use current directory
    IfCondition EqualTo(has_files, 0) ThenBlock: {
        is_dir = IsDirectory(".")
        
        IfCondition NotEqual(is_dir, 0) ThenBlock: {
            dir_size = CalculateDirectorySize(".", 0)
        } ElseBlock: {
            dir_size = CalculateFileSize(".")
        }
        
        PrintSize(dir_size, ".")
    } ElseBlock: {
        // Process specified files/directories
        WhileLoop LessThan(pos, 4096) {
            ch = GetByte(args_buffer, pos)
            IfCondition EqualTo(ch, 0) ThenBlock: {
                BreakLoop
            }
            
            IfCondition NotEqual(ch, 45) ThenBlock: {
                file_path = Add(args_buffer, pos)
                
                is_dir = IsDirectory(file_path)
                
                IfCondition NotEqual(is_dir, 0) ThenBlock: {
                    dir_size = CalculateDirectorySize(file_path, 0)
                } ElseBlock: {
                    dir_size = CalculateFileSize(file_path)
                }
                
                PrintSize(dir_size, file_path)
                DuStats.grand_total = Add(DuStats.grand_total, dir_size)
            }
            
            // Skip to next argument
            WhileLoop NotEqual(GetByte(args_buffer, pos), 0) {
                pos = Add(pos, 1)
            }
            pos = Add(pos, 1)
        }
        
        // Print total if requested
        IfCondition NotEqual(DuConfig.total_only, 0) ThenBlock: {
            PrintSize(DuStats.grand_total, "total")
        }
    }
    
    Deallocate(args_buffer, 4096)
    SystemCall(60, 0)
}

RunTask(Main)