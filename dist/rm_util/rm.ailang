// rm.ailang - GNU-Compatible File/Directory Removal Utility
// Usage: rm [OPTION]... [FILE]...
// Remove (unlink) the FILE(s).
//
// Options:
//   -f, --force           ignore nonexistent files and arguments, never prompt
//   -i                    prompt before every removal
//   -I                    prompt once before removing more than three files, or
//                           when removing recursively
//   -r, -R, --recursive   remove directories and their contents recursively
//   -d, --dir             remove empty directories
//   -v, --verbose         explain what is being done
//   --help                display this help and exit
//   --version             output version information and exit

FixedPool.RmConfig {
    "force": Initialize=0
    "interactive": Initialize=0
    "interactive_once": Initialize=0
    "recursive": Initialize=0
    "dir": Initialize=0
    "verbose": Initialize=0
    "prompted_once": Initialize=0
}

FixedPool.RmStats {
    "files_removed": Initialize=0
    "dirs_removed": Initialize=0
    "errors": Initialize=0
    "skipped": Initialize=0
}

FixedPool.RmConstants {
    "ENOENT": Initialize=2
    "EACCES": Initialize=13
    "EBUSY": Initialize=16
    "EEXIST": Initialize=17
    "EISDIR": Initialize=21
    "ENOTDIR": Initialize=20
    "ENOTEMPTY": Initialize=39
    "EROFS": Initialize=30
    "O_RDONLY": Initialize=0
    "O_DIRECTORY": Initialize=65536
    "AT_FDCWD": Initialize=-100
    "DT_DIR": Initialize=4
    "DT_REG": Initialize=8
}

// ============================================================================
// UTILITY FUNCTIONS
// ============================================================================

Function.WriteStdout {
    Input: str: Address
    Body: {
        len = StringLength(str)
        SystemCall(1, 1, str, len)
    }
}

Function.WriteStderr {
    Input: str: Address
    Body: {
        len = StringLength(str)
        SystemCall(1, 2, str, len)
    }
}

Function.IntToString {
    Input: num: Integer
    Output: Address
    Body: {
        IfCondition EqualTo(num, 0) ThenBlock: {
            str = Allocate(2)
            SetByte(str, 0, 48)
            SetByte(str, 1, 0)
            ReturnValue(str)
        }
        
        is_negative = LessThan(num, 0)
        abs_num = num
        IfCondition EqualTo(is_negative, 1) ThenBlock: {
            abs_num = Subtract(0, num)
        }
        
        temp = abs_num
        digits = 0
        WhileLoop GreaterThan(temp, 0) {
            temp = Divide(temp, 10)
            digits = Add(digits, 1)
        }
        
        total_len = digits
        IfCondition EqualTo(is_negative, 1) ThenBlock: {
            total_len = Add(total_len, 1)
        }
        
        str = Allocate(Add(total_len, 1))
        
        pos = 0
        IfCondition EqualTo(is_negative, 1) ThenBlock: {
            SetByte(str, 0, 45)
            pos = 1
        }
        
        i = Subtract(total_len, 1)
        temp = abs_num
        WhileLoop GreaterThan(temp, 0) {
            digit = Modulo(temp, 10)
            SetByte(str, i, Add(48, digit))
            temp = Divide(temp, 10)
            i = Subtract(i, 1)
        }
        
        SetByte(str, total_len, 0)
        ReturnValue(str)
    }
}

Function.PathExists {
    Input: path: Address
    Output: Integer
    Body: {
        statbuf = Allocate(144)
        result = SystemCall(4, path, statbuf)
        Deallocate(statbuf, 144)
        ReturnValue(GreaterEqual(result, 0))
    }
}

Function.IsDirectory {
    Input: path: Address
    Output: Integer
    Body: {
        statbuf = Allocate(144)
        result = SystemCall(4, path, statbuf)
        
        IfCondition LessThan(result, 0) ThenBlock: {
            Deallocate(statbuf, 144)
            ReturnValue(0)
        }
        
        st_mode = Dereference(Add(statbuf, 24))
        Deallocate(statbuf, 144)
        
        is_dir = BitwiseAnd(st_mode, 16384)
        ReturnValue(NotEqual(is_dir, 0))
    }
}

Function.BuildPath {
    Input: dir: Address
    Input: file: Address
    Output: Address
    Body: {
        dir_len = StringLength(dir)
        file_len = StringLength(file)
        
        needs_slash = 1
        IfCondition GreaterThan(dir_len, 0) ThenBlock: {
            last_char = GetByte(dir, Subtract(dir_len, 1))
            IfCondition EqualTo(last_char, 47) ThenBlock: {
                needs_slash = 0
            }
        }
        
        total_len = Add(Add(dir_len, file_len), Add(needs_slash, 1))
        path = Allocate(total_len)
        
        i = 0
        WhileLoop LessThan(i, dir_len) {
            SetByte(path, i, GetByte(dir, i))
            i = Add(i, 1)
        }
        
        IfCondition EqualTo(needs_slash, 1) ThenBlock: {
            SetByte(path, i, 47)
            i = Add(i, 1)
        }
        
        j = 0
        WhileLoop LessThan(j, file_len) {
            SetByte(path, i, GetByte(file, j))
            i = Add(i, 1)
            j = Add(j, 1)
        }
        
        SetByte(path, i, 0)
        ReturnValue(path)
    }
}

Function.GetErrorString {
    Input: errno: Integer
    Output: Address
    Body: {
        abs_errno = errno
        IfCondition LessThan(errno, 0) ThenBlock: {
            abs_errno = Subtract(0, errno)
        }
        
        IfCondition EqualTo(abs_errno, RmConstants.ENOENT) ThenBlock: {
            ReturnValue("No such file or directory")
        }
        
        IfCondition EqualTo(abs_errno, RmConstants.EACCES) ThenBlock: {
            ReturnValue("Permission denied")
        }
        
        IfCondition EqualTo(abs_errno, RmConstants.EISDIR) ThenBlock: {
            ReturnValue("Is a directory")
        }
        
        IfCondition EqualTo(abs_errno, RmConstants.ENOTDIR) ThenBlock: {
            ReturnValue("Not a directory")
        }
        
        IfCondition EqualTo(abs_errno, RmConstants.ENOTEMPTY) ThenBlock: {
            ReturnValue("Directory not empty")
        }
        
        IfCondition EqualTo(abs_errno, RmConstants.EBUSY) ThenBlock: {
            ReturnValue("Device or resource busy")
        }
        
        IfCondition EqualTo(abs_errno, RmConstants.EROFS) ThenBlock: {
            ReturnValue("Read-only file system")
        }
        
        ReturnValue("Unknown error")
    }
}

Function.PromptUser {
    Input: prompt: Address
    Output: Integer
    Body: {
        WriteStderr(prompt)
        
        response = Allocate(8)
        bytes = SystemCall(0, 0, response, 8)
        
        IfCondition LessEqual(bytes, 0) ThenBlock: {
            Deallocate(response, 8)
            ReturnValue(0)
        }
        
        ch = GetByte(response, 0)
        Deallocate(response, 8)
        
        result = Or(EqualTo(ch, 121), EqualTo(ch, 89))
        ReturnValue(result)
    }
}

// ============================================================================
// CORE REMOVAL FUNCTIONS
// ============================================================================

Function.RemoveFile {
    Input: path: Address
    Output: Integer
    Body: {
        IfCondition EqualTo(RmConfig.interactive, 1) ThenBlock: {
            WriteStderr("rm: remove regular file '")
            WriteStderr(path)
            WriteStderr("'? ")
            
            response = PromptUser("")
            IfCondition EqualTo(response, 0) ThenBlock: {
                RmStats.skipped = Add(RmStats.skipped, 1)
                ReturnValue(0)
            }
        }
        
        result = SystemCall(87, path)
        
        IfCondition GreaterEqual(result, 0) ThenBlock: {
            RmStats.files_removed = Add(RmStats.files_removed, 1)
            
            IfCondition EqualTo(RmConfig.verbose, 1) ThenBlock: {
                WriteStderr("removed '")
                WriteStderr(path)
                WriteStderr("'\n")
            }
            
            ReturnValue(0)
        }
        
        abs_error = Subtract(0, result)
        
        IfCondition EqualTo(abs_error, RmConstants.ENOENT) ThenBlock: {
            IfCondition EqualTo(RmConfig.force, 1) ThenBlock: {
                ReturnValue(0)
            }
        }
        
        IfCondition EqualTo(abs_error, RmConstants.EISDIR) ThenBlock: {
            IfCondition EqualTo(RmConfig.recursive, 0) ThenBlock: {
                WriteStderr("rm: cannot remove '")
                WriteStderr(path)
                WriteStderr("': Is a directory\n")
                RmStats.errors = Add(RmStats.errors, 1)
                ReturnValue(1)
            }
        }
        
        WriteStderr("rm: cannot remove '")
        WriteStderr(path)
        WriteStderr("': ")
        WriteStderr(GetErrorString(result))
        WriteStderr("\n")
        
        RmStats.errors = Add(RmStats.errors, 1)
        ReturnValue(1)
    }
}

Function.RemoveEmptyDirectory {
    Input: path: Address
    Output: Integer
    Body: {
        IfCondition EqualTo(RmConfig.interactive, 1) ThenBlock: {
            WriteStderr("rm: remove directory '")
            WriteStderr(path)
            WriteStderr("'? ")
            
            response = PromptUser("")
            IfCondition EqualTo(response, 0) ThenBlock: {
                RmStats.skipped = Add(RmStats.skipped, 1)
                ReturnValue(0)
            }
        }
        
        result = SystemCall(84, path)
        
        IfCondition GreaterEqual(result, 0) ThenBlock: {
            RmStats.dirs_removed = Add(RmStats.dirs_removed, 1)
            
            IfCondition EqualTo(RmConfig.verbose, 1) ThenBlock: {
                WriteStderr("removed directory '")
                WriteStderr(path)
                WriteStderr("'\n")
            }
            
            ReturnValue(0)
        }
        
        abs_error = Subtract(0, result)
        
        IfCondition EqualTo(abs_error, RmConstants.ENOENT) ThenBlock: {
            IfCondition EqualTo(RmConfig.force, 1) ThenBlock: {
                ReturnValue(0)
            }
        }
        
        WriteStderr("rm: cannot remove '")
        WriteStderr(path)
        WriteStderr("': ")
        WriteStderr(GetErrorString(result))
        WriteStderr("\n")
        
        RmStats.errors = Add(RmStats.errors, 1)
        ReturnValue(1)
    }
}

Function.RemoveDirectoryRecursive {
    Input: path: Address
    Output: Integer
    Body: {
        flags = BitwiseOr(RmConstants.O_RDONLY, RmConstants.O_DIRECTORY)
        dir_fd = SystemCall(257, RmConstants.AT_FDCWD, path, flags, 0)
        
        IfCondition LessThan(dir_fd, 0) ThenBlock: {
            abs_error = Subtract(0, dir_fd)
            
            IfCondition EqualTo(abs_error, RmConstants.ENOTDIR) ThenBlock: {
                ReturnValue(RemoveFile(path))
            }
            
            IfCondition EqualTo(abs_error, RmConstants.ENOENT) ThenBlock: {
                IfCondition EqualTo(RmConfig.force, 1) ThenBlock: {
                    ReturnValue(0)
                }
            }
            
            WriteStderr("rm: cannot remove '")
            WriteStderr(path)
            WriteStderr("': ")
            WriteStderr(GetErrorString(dir_fd))
            WriteStderr("\n")
            
            RmStats.errors = Add(RmStats.errors, 1)
            ReturnValue(1)
        }
        
        buffer = Allocate(32768)
        errors = 0
        
        WhileLoop 1 {
            bytes_read = SystemCall(217, dir_fd, buffer, 32768)
            
            IfCondition LessEqual(bytes_read, 0) ThenBlock: {
                BreakLoop
            }
            
            pos = 0
            WhileLoop LessThan(pos, bytes_read) {
                d_reclen = Add(GetByte(buffer, Add(pos, 16)), 
                              Multiply(GetByte(buffer, Add(pos, 17)), 256))
                d_type = GetByte(buffer, Add(pos, 18))
                name_start = Add(pos, 19)
                
                name_len = 0
                WhileLoop 1 {
                    ch = GetByte(buffer, Add(name_start, name_len))
                    IfCondition EqualTo(ch, 0) ThenBlock: {
                        BreakLoop
                    }
                    name_len = Add(name_len, 1)
                }
                
                name = Allocate(Add(name_len, 1))
                i = 0
                WhileLoop LessThan(i, name_len) {
                    SetByte(name, i, GetByte(buffer, Add(name_start, i)))
                    i = Add(i, 1)
                }
                SetByte(name, name_len, 0)
                
                is_dot = And(EqualTo(name_len, 1), EqualTo(GetByte(name, 0), 46))
                is_dotdot = And(EqualTo(name_len, 2), 
                               And(EqualTo(GetByte(name, 0), 46), 
                                   EqualTo(GetByte(name, 1), 46)))
                
                IfCondition Not(Or(is_dot, is_dotdot)) ThenBlock: {
                    entry_path = BuildPath(path, name)
                    
                    remove_result = 0
                    IfCondition EqualTo(d_type, RmConstants.DT_DIR) ThenBlock: {
                        remove_result = RemoveDirectoryRecursive(entry_path)
                    } ElseBlock: {
                        remove_result = RemoveFile(entry_path)
                    }
                    
                    IfCondition NotEqual(remove_result, 0) ThenBlock: {
                        errors = Add(errors, 1)
                    }
                    
                    Deallocate(entry_path, 0)
                }
                
                Deallocate(name, Add(name_len, 1))
                pos = Add(pos, d_reclen)
            }
        }
        
        Deallocate(buffer, 32768)
        SystemCall(3, dir_fd)
        
        IfCondition EqualTo(errors, 0) ThenBlock: {
            ReturnValue(RemoveEmptyDirectory(path))
        }
        
        ReturnValue(1)
    }
}

Function.RemovePath {
    Input: path: Address
    Output: Integer
    Body: {
        exists = PathExists(path)
        
        IfCondition EqualTo(exists, 0) ThenBlock: {
            IfCondition EqualTo(RmConfig.force, 1) ThenBlock: {
                ReturnValue(0)
            }
            
            WriteStderr("rm: cannot remove '")
            WriteStderr(path)
            WriteStderr("': No such file or directory\n")
            RmStats.errors = Add(RmStats.errors, 1)
            ReturnValue(1)
        }
        
        is_dir = IsDirectory(path)
        
        IfCondition EqualTo(is_dir, 1) ThenBlock: {
            IfCondition EqualTo(RmConfig.recursive, 1) ThenBlock: {
                ReturnValue(RemoveDirectoryRecursive(path))
            }
            
            IfCondition EqualTo(RmConfig.dir, 1) ThenBlock: {
                ReturnValue(RemoveEmptyDirectory(path))
            }
            
            WriteStderr("rm: cannot remove '")
            WriteStderr(path)
            WriteStderr("': Is a directory\n")
            RmStats.errors = Add(RmStats.errors, 1)
            ReturnValue(1)
        }
        
        ReturnValue(RemoveFile(path))
    }
}

// ============================================================================
// ARGUMENT PARSING
// ============================================================================

Function.GetArgs {
    Output: Address
    Body: {
        fd = SystemCall(257, -100, "/proc/self/cmdline", 0, 0)
        IfCondition LessThan(fd, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        buffer = Allocate(4096)
        bytes_read = SystemCall(0, fd, buffer, 4096)
        SystemCall(3, fd)
        
        IfCondition LessEqual(bytes_read, 0) ThenBlock: {
            Deallocate(buffer, 4096)
            ReturnValue(0)
        }
        
        ReturnValue(buffer)
    }
}

Function.StringCompare {
    Input: str1: Address
    Input: str2: Address
    Output: Integer
    Body: {
        i = 0
        WhileLoop 1 {
            ch1 = GetByte(str1, i)
            ch2 = GetByte(str2, i)
            
            IfCondition NotEqual(ch1, ch2) ThenBlock: {
                ReturnValue(0)
            }
            
            IfCondition EqualTo(ch1, 0) ThenBlock: {
                ReturnValue(1)
            }
            
            i = Add(i, 1)
        }
        ReturnValue(1)
    }
}

Function.ShowHelp {
    Body: {
        WriteStdout("Usage: rm [OPTION]... [FILE]...\n")
        WriteStdout("Remove (unlink) the FILE(s).\n")
        WriteStdout("\n")
        WriteStdout("  -f, --force           ignore nonexistent files and arguments, never prompt\n")
        WriteStdout("  -i                    prompt before every removal\n")
        WriteStdout("  -I                    prompt once before removing more than three files, or\n")
        WriteStdout("                          when removing recursively; less intrusive than -i,\n")
        WriteStdout("                          while still giving protection against most mistakes\n")
        WriteStdout("  -r, -R, --recursive   remove directories and their contents recursively\n")
        WriteStdout("  -d, --dir             remove empty directories\n")
        WriteStdout("  -v, --verbose         explain what is being done\n")
        WriteStdout("      --help            display this help and exit\n")
        WriteStdout("      --version         output version information and exit\n")
        WriteStdout("\n")
        WriteStdout("By default, rm does not remove directories.  Use the --recursive (-r or -R)\n")
        WriteStdout("option to remove each listed directory, too, along with all of its contents.\n")
        WriteStdout("\n")
        WriteStdout("To remove a file whose name starts with a '-', for example '-foo',\n")
        WriteStdout("use one of these commands:\n")
        WriteStdout("  rm -- -foo\n")
        WriteStdout("\n")
        WriteStdout("  rm ./-foo\n")
        WriteStdout("\n")
        WriteStdout("Note that if you use rm to remove a file, it might be possible to recover\n")
        WriteStdout("some of its contents, given sufficient expertise and/or time.  For greater\n")
        WriteStdout("assurance that the contents are truly unrecoverable, consider using shred.\n")
        WriteStdout("\n")
        WriteStdout("GNU coreutils compatible rm implementation in AiLang.\n")
    }
}

Function.ShowVersion {
    Body: {
        WriteStdout("rm (AiLang coreutils) 1.0\n")
        WriteStdout("Copyright (C) 2025 AiLang Project\n")
        WriteStdout("License: MIT\n")
        WriteStdout("\n")
        WriteStdout("Written in AiLang - A language designed for human and LLM comprehension.\n")
    }
}

// ============================================================================
// MAIN ROUTINE
// ============================================================================

SubRoutine.Main {
    args_buffer = GetArgs()
    
    IfCondition EqualTo(args_buffer, 0) ThenBlock: {
        WriteStderr("rm: failed to read arguments\n")
        SystemCall(60, 1)
    }
    
    pos = 0
    WhileLoop NotEqual(GetByte(args_buffer, pos), 0) {
        pos = Add(pos, 1)
    }
    pos = Add(pos, 1)
    
    max_files = 256
    files = ArrayCreate(max_files)
    file_count = 0
    
    WhileLoop LessThan(pos, 4096) {
        ch = GetByte(args_buffer, pos)
        IfCondition EqualTo(ch, 0) ThenBlock: {
            BreakLoop
        }
        
        first = GetByte(args_buffer, pos)
        
        IfCondition EqualTo(first, 45) ThenBlock: {
            arg_start = pos
            arg_len = 0
            
            WhileLoop And(LessThan(pos, 4096), NotEqual(GetByte(args_buffer, pos), 0)) {
                arg_len = Add(arg_len, 1)
                pos = Add(pos, 1)
            }
            
            flag = Allocate(Add(arg_len, 1))
            i = 0
            WhileLoop LessThan(i, arg_len) {
                SetByte(flag, i, GetByte(args_buffer, Add(arg_start, i)))
                i = Add(i, 1)
            }
            SetByte(flag, arg_len, 0)
            
            IfCondition StringCompare(flag, "--help") ThenBlock: {
                ShowHelp()
                Deallocate(flag, Add(arg_len, 1))
                ArrayDestroy(files)
                Deallocate(args_buffer, 4096)
                SystemCall(60, 0)
            }
            
            IfCondition StringCompare(flag, "--version") ThenBlock: {
                ShowVersion()
                Deallocate(flag, Add(arg_len, 1))
                ArrayDestroy(files)
                Deallocate(args_buffer, 4096)
                SystemCall(60, 0)
            }
            
            IfCondition StringCompare(flag, "--force") ThenBlock: {
                RmConfig.force = 1
            }
            
            IfCondition StringCompare(flag, "--recursive") ThenBlock: {
                RmConfig.recursive = 1
            }
            
            IfCondition StringCompare(flag, "--dir") ThenBlock: {
                RmConfig.dir = 1
            }
            
            IfCondition StringCompare(flag, "--verbose") ThenBlock: {
                RmConfig.verbose = 1
            }
            
            i = 1
            WhileLoop LessThan(i, arg_len) {
                flag_char = GetByte(flag, i)
                
                IfCondition EqualTo(flag_char, 102) ThenBlock: {
                    RmConfig.force = 1
                }
                
                IfCondition EqualTo(flag_char, 105) ThenBlock: {
                    RmConfig.interactive = 1
                }
                
                IfCondition EqualTo(flag_char, 73) ThenBlock: {
                    RmConfig.interactive_once = 1
                }
                
                IfCondition EqualTo(flag_char, 114) ThenBlock: {
                    RmConfig.recursive = 1
                }
                
                IfCondition EqualTo(flag_char, 82) ThenBlock: {
                    RmConfig.recursive = 1
                }
                
                IfCondition EqualTo(flag_char, 100) ThenBlock: {
                    RmConfig.dir = 1
                }
                
                IfCondition EqualTo(flag_char, 118) ThenBlock: {
                    RmConfig.verbose = 1
                }
                
                i = Add(i, 1)
            }
            
            Deallocate(flag, Add(arg_len, 1))
        } ElseBlock: {
            arg_start = pos
            arg_len = 0
            
            WhileLoop And(LessThan(pos, 4096), NotEqual(GetByte(args_buffer, pos), 0)) {
                arg_len = Add(arg_len, 1)
                pos = Add(pos, 1)
            }
            
            filename = Allocate(Add(arg_len, 1))
            i = 0
            WhileLoop LessThan(i, arg_len) {
                SetByte(filename, i, GetByte(args_buffer, Add(arg_start, i)))
                i = Add(i, 1)
            }
            SetByte(filename, arg_len, 0)
            
            IfCondition LessThan(file_count, max_files) ThenBlock: {
                ArraySet(files, file_count, filename)
                file_count = Add(file_count, 1)
            }
        }
        
        pos = Add(pos, 1)
    }
    
    Deallocate(args_buffer, 4096)
    
    IfCondition EqualTo(file_count, 0) ThenBlock: {
        WriteStderr("rm: missing operand\n")
        WriteStderr("Try 'rm --help' for more information.\n")
        ArrayDestroy(files)
        SystemCall(60, 1)
    }
    
    IfCondition EqualTo(RmConfig.interactive_once, 1) ThenBlock: {
        should_prompt = 0
        
        IfCondition GreaterThan(file_count, 3) ThenBlock: {
            should_prompt = 1
        }
        
        IfCondition EqualTo(RmConfig.recursive, 1) ThenBlock: {
            should_prompt = 1
        }
        
        IfCondition EqualTo(should_prompt, 1) ThenBlock: {
            IfCondition EqualTo(RmConfig.prompted_once, 0) ThenBlock: {
                WriteStderr("rm: remove ")
                count_str = IntToString(file_count)
                WriteStderr(count_str)
                Deallocate(count_str, 0)
                WriteStderr(" argument")
                
                IfCondition GreaterThan(file_count, 1) ThenBlock: {
                    WriteStderr("s")
                }
                
                IfCondition EqualTo(RmConfig.recursive, 1) ThenBlock: {
                    WriteStderr(" recursively")
                }
                
                WriteStderr("? ")
                
                response = PromptUser("")
                RmConfig.prompted_once = 1
                
                IfCondition EqualTo(response, 0) ThenBlock: {
                    ArrayDestroy(files)
                    SystemCall(60, 0)
                }
            }
        }
    }
    
    i = 0
    WhileLoop LessThan(i, file_count) {
        file = ArrayGet(files, i)
        result = RemovePath(file)
        Deallocate(file, 0)
        i = Add(i, 1)
    }
    
    ArrayDestroy(files)
    
    IfCondition EqualTo(RmConfig.verbose, 1) ThenBlock: {
        IfCondition GreaterThan(file_count, 1) ThenBlock: {
            WriteStderr("\nðŸ“Š Summary:\n")
            WriteStderr("  Files removed: ")
            sum_str = IntToString(RmStats.files_removed)
            WriteStderr(sum_str)
            Deallocate(sum_str, 0)
            WriteStderr("\n  Directories removed: ")
            sum_str = IntToString(RmStats.dirs_removed)
            WriteStderr(sum_str)
            Deallocate(sum_str, 0)
            WriteStderr("\n  Skipped: ")
            sum_str = IntToString(RmStats.skipped)
            WriteStderr(sum_str)
            Deallocate(sum_str, 0)
            WriteStderr("\n  Errors: ")
            sum_str = IntToString(RmStats.errors)
            WriteStderr(sum_str)
            Deallocate(sum_str, 0)
            WriteStderr("\n")
        }
    }
    
    exit_code = 0
    IfCondition GreaterThan(RmStats.errors, 0) ThenBlock: {
        exit_code = 1
    }
    
    SystemCall(60, exit_code)
}

RunTask(Main)