// cat.ailang - Minimal working cat for AILang
// Reads from stdin OR files via simple argument parsing
// NO LINE LENGTH LIMIT - character streaming
// WITH PERFORMANCE MONITORING

FixedPool.CatConfig {
    "show_line_numbers": Initialize=0
    "show_ends": Initialize=0
    "show_tabs": Initialize=0
    "squeeze_blank": Initialize=0
    "number_nonblank": Initialize=0
    "line_counter": Initialize=1
    "at_line_start": Initialize=1
    "last_was_blank": Initialize=0
}

FixedPool.CatConstants {
    "BUFFER_SIZE": Initialize=131072
    "POSIX_FADV_SEQUENTIAL": Initialize=2
}

// Write raw bytes to stdout
Function.WriteStdoutRaw {
    Input: buffer: Address
    Input: len: Integer
    Body: {
        IfCondition GreaterThan(len, 0) ThenBlock: {
            SystemCall(1, 1, buffer, len)
        }
    }
}

Function.WriteStdoutString {
    Input: str: Address
    Body: {
        len = StringLength(str)
        WriteStdoutRaw(str, len)
    }
}

Function.WriteStderrString {
    Input: str: Address
    Body: {
        len = StringLength(str)
        IfCondition GreaterThan(len, 0) ThenBlock: {
            SystemCall(1, 2, str, len)
        }
    }
}

Function.WriteChar {
    Input: ch: Integer
    Body: {
        temp = Allocate(2)
        SetByte(temp, 0, ch)
        SetByte(temp, 1, 0)
        WriteStdoutRaw(temp, 1)
        Deallocate(temp, 2)
    }
}

// File I/O
Function.SysOpen {
    Input: filename: Address
    Output: Integer
    Body: {
        // open(filename, O_RDONLY=0, 0)
        fd = SystemCall(2, filename, 0, 0)
        ReturnValue(fd)
    }
}

Function.SysRead {
    Input: fd: Integer
    Input: buffer: Address
    Input: size: Integer
    Output: Integer
    Body: {
        bytes_read = SystemCall(0, fd, buffer, size)
        ReturnValue(bytes_read)
    }
}

Function.SysClose {
    Input: fd: Integer
    Body: {
        SystemCall(3, fd)
    }
}

// Print line number (for -n flag)
Function.PrintLineNumber {
    Body: {
        num = CatConfig.line_counter
        
        spaces_needed = 6
        temp = num
        digits = 1
        
        WhileLoop GreaterEqual(temp, 10) {
            digits = Add(digits, 1)
            temp = Divide(temp, 10)
        }
        
        i = 0
        WhileLoop LessThan(i, Subtract(spaces_needed, digits)) {
            WriteStdoutString(" ")
            i = Add(i, 1)
        }
        
        num_str = NumberToString(num)
        WriteStdoutString(num_str)
        WriteChar(9)
        
        CatConfig.line_counter = Add(CatConfig.line_counter, 1)
    }
}

// Process one character - STREAMING
Function.ProcessChar {
    Input: ch: Integer
    Body: {
        is_newline = EqualTo(ch, 10)
        
        // Calculate if this is a blank line
        is_blank_line = And(CatConfig.at_line_start, is_newline)
        
        // Check if we should skip this character
        should_skip = 0
        
        // Squeeze blank lines: skip consecutive blank lines
        IfCondition CatConfig.squeeze_blank ThenBlock: {
            IfCondition is_blank_line ThenBlock: {
                IfCondition CatConfig.last_was_blank ThenBlock: {
                    should_skip = 1
                }
                CatConfig.last_was_blank = 1
            }
        }
        
        // If we're skipping, just update state and exit
        IfCondition should_skip ThenBlock: {
            CatConfig.at_line_start = 1
            ReturnValue(0)
        }
        
        // Line numbering at start of line
        IfCondition CatConfig.at_line_start ThenBlock: {
            IfCondition CatConfig.show_line_numbers ThenBlock: {
                should_number = 1
                
                // number_nonblank: don't number blank lines
                IfCondition CatConfig.number_nonblank ThenBlock: {
                    IfCondition is_newline ThenBlock: {
                        should_number = 0
                    }
                }
                
                IfCondition should_number ThenBlock: {
                    PrintLineNumber()
                }
            }
            
            CatConfig.at_line_start = 0
        }
        
        // Output the character
        IfCondition is_newline ThenBlock: {
            IfCondition CatConfig.show_ends ThenBlock: {
                WriteStdoutString("$")
            }
            WriteChar(10)
            CatConfig.at_line_start = 1
        } ElseBlock: {
            // Not a newline - reset blank tracking since we have content
            CatConfig.last_was_blank = 0
            
            // Handle tabs
            IfCondition And(CatConfig.show_tabs, EqualTo(ch, 9)) ThenBlock: {
                WriteStdoutString("^I")
            } ElseBlock: {
                WriteChar(ch)
            }
        }
        
        ReturnValue(0)
    }
}

// Simple cat: just copy bytes
Function.SimpleCat {
    Input: fd: Integer
    Body: {
        DebugPerf.Start("SimpleCat")
        
        buffer = Allocate(CatConstants.BUFFER_SIZE)
        keep_reading = 1
        
        WhileLoop EqualTo(keep_reading, 1) {
            bytes_read = SysRead(fd, buffer, CatConstants.BUFFER_SIZE)
            
            IfCondition LessEqual(bytes_read, 0) ThenBlock: {
                keep_reading = 0
            } ElseBlock: {
                WriteStdoutRaw(buffer, bytes_read)
            }
        }
        
        Deallocate(buffer, CatConstants.BUFFER_SIZE)
        
        DebugPerf.End("SimpleCat")
    }
}

// Feature cat: process char-by-char
Function.FeatureCat {
    Input: fd: Integer
    Body: {
        DebugPerf.Start("FeatureCat")
        
        buffer = Allocate(CatConstants.BUFFER_SIZE)
        keep_reading = 1
        
        WhileLoop EqualTo(keep_reading, 1) {
            bytes_read = SysRead(fd, buffer, CatConstants.BUFFER_SIZE)
            
            IfCondition LessEqual(bytes_read, 0) ThenBlock: {
                keep_reading = 0
            } ElseBlock: {
                i = 0
                WhileLoop LessThan(i, bytes_read) {
                    ch = GetByte(buffer, i)
                    ProcessChar(ch)
                    i = Add(i, 1)
                }
            }
        }
        
        Deallocate(buffer, CatConstants.BUFFER_SIZE)
        
        DebugPerf.End("FeatureCat")
    }
}

// Cat from stdin
Function.CatStdin {
    Body: {
        has_features = Or(CatConfig.show_line_numbers, 
                          Or(CatConfig.show_ends,
                          Or(CatConfig.show_tabs,
                          CatConfig.squeeze_blank)))
        
        IfCondition has_features ThenBlock: {
            FeatureCat(0)
        } ElseBlock: {
            SimpleCat(0)
        }
    }
}

// Cat from file
Function.CatFile {
    Input: filename: Address
    Output: Integer
    Body: {
        fd = SysOpen(filename)
        
        IfCondition LessThan(fd, 0) ThenBlock: {
            WriteStderrString("cat: ")
            WriteStderrString(filename)
            WriteStderrString(": No such file or directory\n")
            ReturnValue(1)
        }
        
        has_features = Or(CatConfig.show_line_numbers, 
                          Or(CatConfig.show_ends,
                          Or(CatConfig.show_tabs,
                          CatConfig.squeeze_blank)))
        
        IfCondition has_features ThenBlock: {
            FeatureCat(fd)
        } ElseBlock: {
            SimpleCat(fd)
        }
        
        SysClose(fd)
        ReturnValue(0)
    }
}

// WORKAROUND: Read first argument from /proc/self/cmdline
Function.GetFirstArg {
    Output: Address
    Body: {
        DebugPerf.Start("ArgParse")
        
        cmdline_path = "/proc/self/cmdline"
        fd = SysOpen(cmdline_path)
        
        IfCondition LessThan(fd, 0) ThenBlock: {
            DebugPerf.End("ArgParse")
            ReturnValue(0)
        }
        
        buffer = Allocate(1024)
        bytes_read = SysRead(fd, buffer, 1024)
        SysClose(fd)
        
        IfCondition LessEqual(bytes_read, 0) ThenBlock: {
            Deallocate(buffer, 1024)
            DebugPerf.End("ArgParse")
            ReturnValue(0)
        }
        
        // /proc/self/cmdline format: "program\0arg1\0arg2\0"
        // Skip program name (find first null)
        i = 0
        found_first_null = 0
        
        WhileLoop And(LessThan(i, bytes_read), EqualTo(found_first_null, 0)) {
            ch = GetByte(buffer, i)
            IfCondition EqualTo(ch, 0) ThenBlock: {
                found_first_null = 1
            } ElseBlock: {
                i = Add(i, 1)
            }
        }
        
        // i is now at the first null, skip it
        i = Add(i, 1)
        
        // Check if we're past the end or at another null
        IfCondition GreaterEqual(i, bytes_read) ThenBlock: {
            Deallocate(buffer, 1024)
            DebugPerf.End("ArgParse")
            ReturnValue(0)
        }
        
        ch = GetByte(buffer, i)
        IfCondition EqualTo(ch, 0) ThenBlock: {
            // No arguments
            Deallocate(buffer, 1024)
            DebugPerf.End("ArgParse")
            ReturnValue(0)
        }
        
        // Found argument start, find its length
        arg_start = i
        arg_len = 0
        
        WhileLoop LessThan(i, bytes_read) {
            ch = GetByte(buffer, i)
            IfCondition EqualTo(ch, 0) ThenBlock: {
                BreakLoop
            }
            arg_len = Add(arg_len, 1)
            i = Add(i, 1)
        }
        
        // Safety check
        IfCondition EqualTo(arg_len, 0) ThenBlock: {
            Deallocate(buffer, 1024)
            DebugPerf.End("ArgParse")
            ReturnValue(0)
        }
        
        // Copy argument to new buffer
        arg = Allocate(Add(arg_len, 1))
        j = 0
        WhileLoop LessThan(j, arg_len) {
            ch = GetByte(buffer, Add(arg_start, j))
            SetByte(arg, j, ch)
            j = Add(j, 1)
        }
        SetByte(arg, arg_len, 0)
        
        Deallocate(buffer, 1024)
        
        DebugPerf.End("ArgParse")
        
        ReturnValue(arg)
    }
}

// NEW: Process all arguments by calling CatFile/CatStdin multiple times
// (Not used - logic moved directly into Main)

// Main - SIMPLIFIED: Check if we even have args before complex parsing
SubRoutine.Main {
    // Quick check: try to get first arg using the working function
    quick_arg = GetFirstArg()
    
    // If no args, just do stdin and exit
    IfCondition EqualTo(quick_arg, 0) ThenBlock: {
        CatStdin()
        HaltProgram()
    }
    
    // We have at least one arg - NOW do full parsing
    Deallocate(quick_arg, 0)
    
    cmdline_path = "/proc/self/cmdline"
    fd = SysOpen(cmdline_path)
    
    IfCondition LessThan(fd, 0) ThenBlock: {
        CatStdin()
        HaltProgram()
    }
    
    // BIGGER BUFFER for many files (4KB instead of 1KB)
    main_buffer = Allocate(4096)
    main_bytes_read = SysRead(fd, main_buffer, 4096)
    SysClose(fd)
    
    IfCondition LessEqual(main_bytes_read, 0) ThenBlock: {
        Deallocate(main_buffer, 4096)
        CatStdin()
        HaltProgram()
    }
    
    // Track if any file failed
    main_exit_code = 0
    main_had_files = 0
    
    // Skip program name
    main_i = 0
    WhileLoop LessThan(main_i, main_bytes_read) {
        main_ch = GetByte(main_buffer, main_i)
        IfCondition EqualTo(main_ch, 0) ThenBlock: {
            main_i = Add(main_i, 1)
            BreakLoop
        }
        main_i = Add(main_i, 1)
    }
    
    // Process each argument
    WhileLoop LessThan(main_i, main_bytes_read) {
        main_arg_start = main_i
        main_arg_len = 0
        
        // Find arg length
        WhileLoop LessThan(main_i, main_bytes_read) {
            main_ch = GetByte(main_buffer, main_i)
            IfCondition EqualTo(main_ch, 0) ThenBlock: {
                BreakLoop
            }
            main_arg_len = Add(main_arg_len, 1)
            main_i = Add(main_i, 1)
        }
        
        // Process if non-empty
        IfCondition GreaterThan(main_arg_len, 0) ThenBlock: {
            main_arg = Allocate(Add(main_arg_len, 1))
            main_j = 0
            WhileLoop LessThan(main_j, main_arg_len) {
                main_ch = GetByte(main_buffer, Add(main_arg_start, main_j))
                SetByte(main_arg, main_j, main_ch)
                main_j = Add(main_j, 1)
            }
            SetByte(main_arg, main_arg_len, 0)
            
            // Check if it's a flag (starts with '-')
            main_first_char = GetByte(main_arg, 0)
            main_is_flag = EqualTo(main_first_char, 45)
            
            IfCondition main_is_flag ThenBlock: {
                // Get second and third chars for parsing
                main_second_char = GetByte(main_arg, 1)
                main_third_char = GetByte(main_arg, 2)
                
                // Check for long options (--something)
                main_is_long = EqualTo(main_second_char, 45)
                
                IfCondition main_is_long ThenBlock: {
                    // Long options: check the string after "--"
                    // --number (6 chars after --)
                    c3 = GetByte(main_arg, 2)
                    c4 = GetByte(main_arg, 3)
                    c5 = GetByte(main_arg, 4)
                    c6 = GetByte(main_arg, 5)
                    c7 = GetByte(main_arg, 6)
                    c8 = GetByte(main_arg, 7)
                    c9 = GetByte(main_arg, 8)
                    
                    // --number: n=110, u=117, m=109, b=98, e=101, r=114
                    main_is_long_number = And(EqualTo(c3, 110), And(EqualTo(c4, 117), And(EqualTo(c5, 109), And(EqualTo(c6, 98), And(EqualTo(c7, 101), And(EqualTo(c8, 114), EqualTo(c9, 0)))))))
                    
                    IfCondition main_is_long_number ThenBlock: {
                        CatConfig.show_line_numbers = 1
                    }
                    
                    // --number-nonblank: n=110, u=117, m=109, b=98, e=101, r=114, -, n, o, n, b, l, a, n, k
                    c10 = GetByte(main_arg, 9)
                    c11 = GetByte(main_arg, 10)
                    c12 = GetByte(main_arg, 11)
                    c13 = GetByte(main_arg, 12)
                    c14 = GetByte(main_arg, 13)
                    c15 = GetByte(main_arg, 14)
                    c16 = GetByte(main_arg, 15)
                    c17 = GetByte(main_arg, 16)
                    
                    main_is_long_nonblank = And(EqualTo(c3, 110), And(EqualTo(c4, 117), And(EqualTo(c5, 109), And(EqualTo(c6, 98), And(EqualTo(c7, 101), And(EqualTo(c8, 114), And(EqualTo(c9, 45), And(EqualTo(c10, 110), And(EqualTo(c11, 111), And(EqualTo(c12, 110), And(EqualTo(c13, 98), And(EqualTo(c14, 108), And(EqualTo(c15, 97), And(EqualTo(c16, 110), And(EqualTo(c17, 107), EqualTo(GetByte(main_arg, 17), 0))))))))))))))))
                    
                    IfCondition main_is_long_nonblank ThenBlock: {
                        CatConfig.show_line_numbers = 1
                        CatConfig.number_nonblank = 1
                    }
                    
                    // --squeeze-blank: s=115, q=113, u=117, e=101, e=101, z=122, e=101, -, b, l, a, n, k
                    main_is_long_squeeze = And(EqualTo(c3, 115), And(EqualTo(c4, 113), And(EqualTo(c5, 117), And(EqualTo(c6, 101), And(EqualTo(c7, 101), And(EqualTo(c8, 122), And(EqualTo(c9, 101), And(EqualTo(c10, 45), And(EqualTo(c11, 98), And(EqualTo(c12, 108), And(EqualTo(c13, 97), And(EqualTo(c14, 110), And(EqualTo(c15, 107), EqualTo(c16, 0))))))))))))))
                    
                    IfCondition main_is_long_squeeze ThenBlock: {
                        CatConfig.squeeze_blank = 1
                    }
                    
                    // --show-ends: s=115, h=104, o=111, w=119, -, e, n, d, s
                    main_is_long_ends = And(EqualTo(c3, 115), And(EqualTo(c4, 104), And(EqualTo(c5, 111), And(EqualTo(c6, 119), And(EqualTo(c7, 45), And(EqualTo(c8, 101), And(EqualTo(c9, 110), And(EqualTo(c10, 100), And(EqualTo(c11, 115), EqualTo(c12, 0))))))))))
                    
                    IfCondition main_is_long_ends ThenBlock: {
                        CatConfig.show_ends = 1
                    }
                    
                    // --show-tabs: s=115, h=104, o=111, w=119, -, t, a, b, s
                    main_is_long_tabs = And(EqualTo(c3, 115), And(EqualTo(c4, 104), And(EqualTo(c5, 111), And(EqualTo(c6, 119), And(EqualTo(c7, 45), And(EqualTo(c8, 116), And(EqualTo(c9, 97), And(EqualTo(c10, 98), And(EqualTo(c11, 115), EqualTo(c12, 0))))))))))
                    
                    IfCondition main_is_long_tabs ThenBlock: {
                        CatConfig.show_tabs = 1
                    }
                    
                    // --show-all: s=115, h=104, o=111, w=119, -, a, l, l
                    main_is_long_all = And(EqualTo(c3, 115), And(EqualTo(c4, 104), And(EqualTo(c5, 111), And(EqualTo(c6, 119), And(EqualTo(c7, 45), And(EqualTo(c8, 97), And(EqualTo(c9, 108), And(EqualTo(c10, 108), EqualTo(c11, 0)))))))))
                    
                    IfCondition main_is_long_all ThenBlock: {
                        CatConfig.show_ends = 1
                        CatConfig.show_tabs = 1
                    }
                } ElseBlock: {
                    // Short options (-n, -b, etc)
                    main_is_n = And(EqualTo(main_second_char, 110), EqualTo(main_third_char, 0))
                
                IfCondition main_is_n ThenBlock: {
                    CatConfig.show_line_numbers = 1
                }
                
                // Check for "-b" flag (98 = 'b')
                main_is_b = And(EqualTo(main_second_char, 98), EqualTo(main_third_char, 0))
                
                IfCondition main_is_b ThenBlock: {
                    CatConfig.show_line_numbers = 1
                    CatConfig.number_nonblank = 1
                }
                
                // Check for "-E" flag (69 = 'E')
                main_is_E = And(EqualTo(main_second_char, 69), EqualTo(main_third_char, 0))
                
                IfCondition main_is_E ThenBlock: {
                    CatConfig.show_ends = 1
                }
                
                // Check for "-T" flag (84 = 'T')
                main_is_T = And(EqualTo(main_second_char, 84), EqualTo(main_third_char, 0))
                
                IfCondition main_is_T ThenBlock: {
                    CatConfig.show_tabs = 1
                }
                
                // Check for "-s" flag (115 = 's')
                main_is_s = And(EqualTo(main_second_char, 115), EqualTo(main_third_char, 0))
                
                IfCondition main_is_s ThenBlock: {
                    CatConfig.squeeze_blank = 1
                }
                
                // Check for "-A" flag (65 = 'A') - show all
                main_is_A = And(EqualTo(main_second_char, 65), EqualTo(main_third_char, 0))
                
                IfCondition main_is_A ThenBlock: {
                    CatConfig.show_ends = 1
                    CatConfig.show_tabs = 1
                }
                
                // Check for "-e" flag (101 = 'e') - equivalent to -E (we skip -v)
                main_is_e = And(EqualTo(main_second_char, 101), EqualTo(main_third_char, 0))
                
                IfCondition main_is_e ThenBlock: {
                    CatConfig.show_ends = 1
                }
                
                // Check for "-t" flag (116 = 't') - equivalent to -T (we skip -v)
                main_is_t = And(EqualTo(main_second_char, 116), EqualTo(main_third_char, 0))
                
                IfCondition main_is_t ThenBlock: {
                    CatConfig.show_tabs = 1
                }
                }
                
                // Check for "--help"
                main_is_help = 0
                IfCondition EqualTo(main_second_char, 45) ThenBlock: {
                    // Check for "help"
                    c3 = GetByte(main_arg, 2)
                    c4 = GetByte(main_arg, 3)
                    c5 = GetByte(main_arg, 4)
                    c6 = GetByte(main_arg, 5)
                    c7 = GetByte(main_arg, 6)
                    // h=104, e=101, l=108, p=112
                    main_is_help = And(EqualTo(c3, 104), And(EqualTo(c4, 101), And(EqualTo(c5, 108), And(EqualTo(c6, 112), EqualTo(c7, 0)))))
                }
                
                IfCondition main_is_help ThenBlock: {
                    WriteStdoutString("Usage: cat [OPTION]... [FILE]...\n")
                    WriteStdoutString("Concatenate FILE(s) to standard output.\n\n")
                    WriteStdoutString("  -A          equivalent to -vET\n")
                    WriteStdoutString("  -b          number nonempty output lines\n")
                    WriteStdoutString("  -e          equivalent to -vE\n")
                    WriteStdoutString("  -E          display $ at end of each line\n")
                    WriteStdoutString("  -n          number all output lines\n")
                    WriteStdoutString("  -s          squeeze multiple adjacent blank lines\n")
                    WriteStdoutString("  -t          equivalent to -vT\n")
                    WriteStdoutString("  -T          display TAB characters as ^I\n")
                    WriteStdoutString("      --help     display this help and exit\n")
                    WriteStdoutString("      --version  output version information and exit\n\n")
                    WriteStdoutString("With no FILE, or when FILE is -, read standard input.\n\n")
                    WriteStdoutString("AILang cat 1.0 - https://github.com/your-repo\n")
                    SystemCall(60, 0)
                }
                
                // Check for "--version"
                main_is_version = 0
                IfCondition EqualTo(main_second_char, 45) ThenBlock: {
                    // Check for "version"
                    c3 = GetByte(main_arg, 2)
                    c4 = GetByte(main_arg, 3)
                    c5 = GetByte(main_arg, 4)
                    c6 = GetByte(main_arg, 5)
                    c7 = GetByte(main_arg, 6)
                    c8 = GetByte(main_arg, 7)
                    c9 = GetByte(main_arg, 8)
                    c10 = GetByte(main_arg, 9)
                    // v=118, e=101, r=114, s=115, i=105, o=111, n=110
                    main_is_version = And(EqualTo(c3, 118), And(EqualTo(c4, 101), And(EqualTo(c5, 114), And(EqualTo(c6, 115), And(EqualTo(c7, 105), And(EqualTo(c8, 111), And(EqualTo(c9, 110), EqualTo(c10, 0))))))))
                }
                
                IfCondition main_is_version ThenBlock: {
                    WriteStdoutString("cat (AILang coreutils) 1.0\n")
                    WriteStdoutString("Written in AILang - A new systems programming language\n")
                    WriteStdoutString("Faster and smaller than GNU cat\n")
                    SystemCall(60, 0)
                }
                
                // Check for "-" (stdin marker)
                main_second_char = GetByte(main_arg, 1)
                main_is_just_dash = And(EqualTo(main_first_char, 45), EqualTo(main_second_char, 0))
                
                IfCondition main_is_just_dash ThenBlock: {
                    CatStdin()
                    main_had_files = 1
                }
                
                // All other flags are just config setters, don't process as files
            } ElseBlock: {
                // It's a filename
                main_had_files = 1
                main_result = CatFile(main_arg)
                
                // Reset state after each file
                CatConfig.at_line_start = 1
                CatConfig.last_was_blank = 0
                
                // Track if any file failed
                IfCondition NotEqual(main_result, 0) ThenBlock: {
                    main_exit_code = 1
                }
            }
            
            Deallocate(main_arg, 0)
        }
        
        // Skip null
        main_i = Add(main_i, 1)
    }
    
    Deallocate(main_buffer, 4096)
    
    // If we only had flags and no files, read from stdin
    IfCondition EqualTo(main_had_files, 0) ThenBlock: {
        CatStdin()
    }
    
    // Exit with proper error code
    IfCondition NotEqual(main_exit_code, 0) ThenBlock: {
        SystemCall(60, 1)
    }
    
    HaltProgram()
}

RunTask(Main)