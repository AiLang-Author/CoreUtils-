// head.ailang - Output first part of files
// Default: first 10 lines
// Supports: -n (line count), -c (byte count), -q (quiet/no headers)

FixedPool.HeadConfig {
    "line_count": Initialize=10
    "byte_count": Initialize=0
    "quiet_mode": Initialize=0
    "use_bytes": Initialize=0
}

FixedPool.HeadConstants {
    "BUFFER_SIZE": Initialize=32768
    "MAX_FILES": Initialize=1000
}

// === SYSCALL WRAPPERS ===

Function.SysOpen {
    Input: filename: Address
    Output: Integer
    Body: {
        fd = SystemCall(2, filename, 0, 0)
        ReturnValue(fd)
    }
}

Function.SysRead {
    Input: fd: Integer
    Input: buffer: Address
    Input: count: Integer
    Output: Integer
    Body: {
        bytes = SystemCall(0, fd, buffer, count)
        ReturnValue(bytes)
    }
}

Function.SysClose {
    Input: fd: Integer
    Body: {
        SystemCall(3, fd)
    }
}

Function.SysWrite {
    Input: fd: Integer
    Input: buffer: Address
    Input: count: Integer
    Body: {
        SystemCall(1, fd, buffer, count)
    }
}

// === OUTPUT FUNCTIONS ===

Function.WriteStdout {
    Input: buffer: Address
    Input: count: Integer
    Body: {
        SysWrite(1, buffer, count)
    }
}

Function.WriteStderr {
    Input: str: Address
    Body: {
        len = StringLength(str)
        SysWrite(2, str, len)
    }
}

// === CORE HEAD FUNCTIONS ===

// Head by line count (default mode)
Function.HeadLines {
    Input: fd: Integer
    Input: max_lines: Integer
    Body: {
        IfCondition LessEqual(max_lines, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        buffer = Allocate(HeadConstants.BUFFER_SIZE)
        lines_output = 0
        keep_reading = 1
        
        WhileLoop EqualTo(keep_reading, 1) {
            bytes_read = SysRead(fd, buffer, HeadConstants.BUFFER_SIZE)
            
            IfCondition LessEqual(bytes_read, 0) ThenBlock: {
                keep_reading = 0
            } ElseBlock: {
                // Scan for newlines and write line-by-line
                line_start = 0
                i = 0
                WhileLoop LessThan(i, bytes_read) {
                    ch = GetByte(buffer, i)
                    
                    IfCondition EqualTo(ch, 10) ThenBlock: {
                        // Found newline - write whole line including newline
                        line_len = Add(Subtract(i, line_start), 1)
                        SysWrite(1, Add(buffer, line_start), line_len)
                        lines_output = Add(lines_output, 1)
                        line_start = Add(i, 1)
                        
                        IfCondition GreaterEqual(lines_output, max_lines) ThenBlock: {
                            keep_reading = 0
                            BreakLoop
                        }
                    }
                    
                    i = Add(i, 1)
                }
                
                // Handle partial line at end of buffer (no newline yet)
                IfCondition And(LessThan(line_start, bytes_read), EqualTo(keep_reading, 1)) ThenBlock: {
                    partial_len = Subtract(bytes_read, line_start)
                    SysWrite(1, Add(buffer, line_start), partial_len)
                }
            }
        }
        
        Deallocate(buffer, HeadConstants.BUFFER_SIZE)
    }
}

// Head by byte count (-c flag)
Function.HeadBytes {
    Input: fd: Integer
    Input: max_bytes: Integer
    Body: {
        buffer = Allocate(HeadConstants.BUFFER_SIZE)
        bytes_output = 0
        keep_reading = 1
        
        WhileLoop EqualTo(keep_reading, 1) {
            bytes_remaining = Subtract(max_bytes, bytes_output)
            
            IfCondition LessEqual(bytes_remaining, 0) ThenBlock: {
                keep_reading = 0
                BreakLoop
            }
            
            // Read only what we need
            read_size = HeadConstants.BUFFER_SIZE
            IfCondition LessThan(bytes_remaining, read_size) ThenBlock: {
                read_size = bytes_remaining
            }
            
            bytes_read = SysRead(fd, buffer, read_size)
            
            IfCondition LessEqual(bytes_read, 0) ThenBlock: {
                keep_reading = 0
            } ElseBlock: {
                WriteStdout(buffer, bytes_read)
                bytes_output = Add(bytes_output, bytes_read)
            }
        }
        
        Deallocate(buffer, HeadConstants.BUFFER_SIZE)
    }
}

// Process stdin
Function.HeadStdin {
    Body: {
        IfCondition EqualTo(HeadConfig.use_bytes, 1) ThenBlock: {
            HeadBytes(0, HeadConfig.byte_count)
        } ElseBlock: {
            HeadLines(0, HeadConfig.line_count)
        }
    }
}

// Process a single file
Function.HeadFile {
    Input: filename: Address
    Output: Integer
    Body: {
        fd = SysOpen(filename)
        
        IfCondition LessThan(fd, 0) ThenBlock: {
            WriteStderr("head: cannot open '")
            WriteStderr(filename)
            WriteStderr("' for reading: No such file or directory\n")
            ReturnValue(1)
        }
        
        IfCondition EqualTo(HeadConfig.use_bytes, 1) ThenBlock: {
            HeadBytes(fd, HeadConfig.byte_count)
        } ElseBlock: {
            HeadLines(fd, HeadConfig.line_count)
        }
        
        SysClose(fd)
        ReturnValue(0)
    }
}

// === FLAG PARSING ===

Function.IsFlag {
    Input: str: Address
    Output: Integer
    Body: {
        first = GetByte(str, 0)
        second = GetByte(str, 1)
        ReturnValue(And(EqualTo(first, 45), NotEqual(second, 0)))
    }
}

Function.StrEquals {
    Input: str1: Address
    Input: str2: Address
    Output: Integer
    Body: {
        i = 0
        WhileLoop 1 {
            ch1 = GetByte(str1, i)
            ch2 = GetByte(str2, i)
            
            IfCondition NotEqual(ch1, ch2) ThenBlock: {
                ReturnValue(0)
            }
            
            IfCondition EqualTo(ch1, 0) ThenBlock: {
                ReturnValue(1)
            }
            
            i = Add(i, 1)
        }
    }
}

Function.StringToInt {
    Input: str: Address
    Output: Integer
    Body: {
        result = 0
        i = 0
        
        WhileLoop 1 {
            ch = GetByte(str, i)
            
            IfCondition Or(LessThan(ch, 48), GreaterThan(ch, 57)) ThenBlock: {
                ReturnValue(result)
            }
            
            digit = Subtract(ch, 48)
            result = Add(Multiply(result, 10), digit)
            i = Add(i, 1)
        }
    }
}

Function.ParseFlags {
    Input: flag_str: Address
    Output: Integer
    Body: {
        // Check for --help
        is_help = StrEquals(flag_str, "--help")
        IfCondition EqualTo(is_help, 1) ThenBlock: {
            WriteStderr("Usage: head [OPTION]... [FILE]...\n")
            WriteStderr("Print the first 10 lines of each FILE to standard output.\n")
            WriteStderr("With more than one FILE, precede each with a header.\n\n")
            WriteStderr("With no FILE, or when FILE is -, read standard input.\n\n")
            WriteStderr("  -c, --bytes=K        print the first K bytes\n")
            WriteStderr("  -n, --lines=K        print the first K lines (default: 10)\n")
            WriteStderr("  -q, --quiet          never print headers\n")
            WriteStderr("      --help           display this help and exit\n")
            SystemCall(60, 0)
        }
        
        // Check for --version
        is_version = StrEquals(flag_str, "--version")
        IfCondition EqualTo(is_version, 1) ThenBlock: {
            WriteStderr("head (AILANG coreutils) 1.0\n")
            SystemCall(60, 0)
        }
        
        first = GetByte(flag_str, 0)
        second = GetByte(flag_str, 1)
        
        // Must start with -
        IfCondition NotEqual(first, 45) ThenBlock: {
            ReturnValue(0)
        }
        
        // Handle -n and -c with attached numbers (e.g., -n5, -c100)
        IfCondition EqualTo(second, 110) ThenBlock: {
            // -n flag
            third = GetByte(flag_str, 2)
            IfCondition EqualTo(third, 0) ThenBlock: {
                // Just "-n", number comes in next arg
                ReturnValue(2)
            } ElseBlock: {
                // -n5 format, parse number
                number_str = Add(flag_str, 2)
                HeadConfig.line_count = StringToInt(number_str)
                ReturnValue(1)
            }
        }
        
        IfCondition EqualTo(second, 99) ThenBlock: {
            // -c flag
            third = GetByte(flag_str, 2)
            IfCondition EqualTo(third, 0) ThenBlock: {
                // Just "-c", number comes in next arg
                ReturnValue(3)
            } ElseBlock: {
                // -c100 format, parse number
                number_str = Add(flag_str, 2)
                HeadConfig.byte_count = StringToInt(number_str)
                HeadConfig.use_bytes = 1
                ReturnValue(1)
            }
        }
        
        // -q flag
        IfCondition EqualTo(second, 113) ThenBlock: {
            HeadConfig.quiet_mode = 1
            ReturnValue(1)
        }
        
        ReturnValue(0)
    }
}

// === ARGUMENT PARSING ===

Function.GetArgs {
    Output: Address
    Body: {
        cmdline_path = "/proc/self/cmdline"
        fd = SystemCall(257, -100, cmdline_path, 0, 0)
        
        IfCondition LessThan(fd, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        buffer = Allocate(4096)
        bytes_read = SystemCall(0, fd, buffer, 4096)
        SystemCall(3, fd)
        
        IfCondition LessEqual(bytes_read, 0) ThenBlock: {
            Deallocate(buffer, 4096)
            ReturnValue(0)
        }
        
        ReturnValue(buffer)
    }
}

// === MAIN ===

SubRoutine.Main {
    args_buffer = GetArgs()
    
    // If no args, process stdin
    IfCondition EqualTo(args_buffer, 0) ThenBlock: {
        HeadStdin()
        SystemCall(60, 0)
    }
    
    // Skip program name
    pos = 0
    WhileLoop NotEqual(GetByte(args_buffer, pos), 0) {
        pos = Add(pos, 1)
    }
    pos = Add(pos, 1)
    
    // Collect file paths
    file_paths = Allocate(Multiply(HeadConstants.MAX_FILES, 8))
    file_count = 0
    expect_number = 0  // 2 for -n, 3 for -c
    
    WhileLoop LessThan(pos, 4096) {
        ch = GetByte(args_buffer, pos)
        IfCondition EqualTo(ch, 0) ThenBlock: {
            BreakLoop
        }
        
        arg_start = pos
        arg_len = 0
        
        WhileLoop And(LessThan(pos, 4096), NotEqual(GetByte(args_buffer, pos), 0)) {
            arg_len = Add(arg_len, 1)
            pos = Add(pos, 1)
        }
        
        arg = Allocate(Add(arg_len, 1))
        i = 0
        WhileLoop LessThan(i, arg_len) {
            ch = GetByte(args_buffer, Add(arg_start, i))
            SetByte(arg, i, ch)
            i = Add(i, 1)
        }
        SetByte(arg, arg_len, 0)
        
        // If expecting a number, parse it
        IfCondition EqualTo(expect_number, 2) ThenBlock: {
            HeadConfig.line_count = StringToInt(arg)
            expect_number = 0
            Deallocate(arg, Add(arg_len, 1))
        } ElseBlock: {
            IfCondition EqualTo(expect_number, 3) ThenBlock: {
                HeadConfig.byte_count = StringToInt(arg)
                HeadConfig.use_bytes = 1
                expect_number = 0
                Deallocate(arg, Add(arg_len, 1))
            } ElseBlock: {
                // Try to parse as flag
                flag_result = ParseFlags(arg)
                
                IfCondition GreaterThan(flag_result, 1) ThenBlock: {
                    // Flag expects next arg as number
                    expect_number = flag_result
                    Deallocate(arg, Add(arg_len, 1))
                } ElseBlock: {
                    IfCondition EqualTo(flag_result, 0) ThenBlock: {
                        // Not a flag, it's a filename
                        StoreValue(Add(file_paths, Multiply(file_count, 8)), arg)
                        file_count = Add(file_count, 1)
                    } ElseBlock: {
                        // Flag was parsed, deallocate
                        Deallocate(arg, Add(arg_len, 1))
                    }
                }
            }
        }
        
        pos = Add(pos, 1)
    }
    
    Deallocate(args_buffer, 4096)
    
    // If no files specified, read stdin
    IfCondition EqualTo(file_count, 0) ThenBlock: {
        HeadStdin()
        SystemCall(60, 0)
    }
    
    // Process files
    exit_code = 0
    show_headers = And(GreaterThan(file_count, 1), EqualTo(HeadConfig.quiet_mode, 0))
    
    i = 0
    WhileLoop LessThan(i, file_count) {
        path = Dereference(Add(file_paths, Multiply(i, 8)))
        
        // Print header if multiple files
        IfCondition EqualTo(show_headers, 1) ThenBlock: {
            IfCondition GreaterThan(i, 0) ThenBlock: {
                WriteStderr("\n")
            }
            WriteStderr("==> ")
            WriteStderr(path)
            WriteStderr(" <==\n")
        }
        
        result = HeadFile(path)
        IfCondition NotEqual(result, 0) ThenBlock: {
            exit_code = 1
        }
        
        Deallocate(path, 0)
        i = Add(i, 1)
    }
    
    Deallocate(file_paths, Multiply(HeadConstants.MAX_FILES, 8))
    SystemCall(60, exit_code)
}

RunTask(Main)