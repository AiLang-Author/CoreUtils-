// nohup.ailang - Run a command immune to hangups

FixedPool.NohupConstants {
    "SIGHUP": Initialize=1
    "O_WRONLY": Initialize=1
    "O_CREAT": Initialize=64
    "O_APPEND": Initialize=1024
}

Function.WriteStdout {
    Input: buffer: Address
    Input: len: Integer
    Body: {
        SystemCall(1, 1, buffer, len)
    }
}

Function.WriteStderr {
    Input: buffer: Address
    Input: len: Integer
    Body: {
        SystemCall(1, 2, buffer, len)
    }
}

Function.GetArgs {
    Output: Address
    Body: {
        fd = SystemCall(257, -100, "/proc/self/cmdline", 0, 0)
        IfCondition LessThan(fd, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        buffer = Allocate(4096)
        bytes_read = SystemCall(0, fd, buffer, 4096)
        SystemCall(3, fd)
        
        IfCondition LessEqual(bytes_read, 0) ThenBlock: {
            Deallocate(buffer, 4096)
            ReturnValue(0)
        }
        
        ReturnValue(buffer)
    }
}

Function.IgnoreHangup {
    Body: {
        // rt_sigaction syscall: 13
        // Set SIGHUP to SIG_IGN (1)
        act = Allocate(152)
        
        // Zero out structure
        i = 0
        WhileLoop LessThan(i, 152) {
            SetByte(act, i, 0)
            i = Add(i, 1)
        }
        
        // Set sa_handler to SIG_IGN (1)
        SetByte(act, 0, 1)
        
        // Call rt_sigaction(SIGHUP=1, act, NULL, 8)
        result = SystemCall(13, NohupConstants.SIGHUP, act, 0, 8)
        
        Deallocate(act, 152)
        ReturnValue(result)
    }
}

Function.RedirectOutput {
    Output: Integer
    Body: {
        // Open nohup.out with O_WRONLY|O_CREAT|O_APPEND, mode 0644
        flags = BitwiseOr(NohupConstants.O_WRONLY, NohupConstants.O_CREAT)
        flags = BitwiseOr(flags, NohupConstants.O_APPEND)
        mode = 420  // 0644 in octal
        
        // open syscall: 2
        fd = SystemCall(2, "nohup.out", flags, mode)
        
        IfCondition LessThan(fd, 0) ThenBlock: {
            ReturnValue(-1)
        }
        
        // dup2 stdout to file: syscall 33
        result1 = SystemCall(33, fd, 1)
        
        // dup2 stderr to file: syscall 33  
        result2 = SystemCall(33, fd, 2)
        
        // Close original fd
        SystemCall(3, fd)
        
        IfCondition Or(LessThan(result1, 0), LessThan(result2, 0)) ThenBlock: {
            ReturnValue(-1)
        }
        
        ReturnValue(0)
    }
}

Function.StorePointer {
    Input: addr: Address
    Input: value: Address
    Body: {
        // Store 64-bit pointer value at addr
        i = 0
        WhileLoop LessThan(i, 8) {
            byte_val = BitwiseAnd(RightShift(value, Multiply(i, 8)), 255)
            SetByte(addr, i, byte_val)
            i = Add(i, 1)
        }
    }
}

Function.BuildArgvArray {
    Input: args_buffer: Address
    Input: cmd_pos: Integer
    Input: full_cmd: Address
    Output: Address
    Body: {
        // Count arguments starting from cmd_pos
        argc = 0
        pos = cmd_pos
        
        WhileLoop LessThan(pos, 4096) {
            ch = GetByte(args_buffer, pos)
            
            IfCondition EqualTo(ch, 0) ThenBlock: {
                // End of this arg
                next_pos = Add(pos, 1)
                
                // Check if next is also null (end of all args)
                IfCondition EqualTo(GetByte(args_buffer, next_pos), 0) ThenBlock: {
                    BreakLoop
                }
                
                argc = Add(argc, 1)
                pos = next_pos
            } ElseBlock: {
                pos = Add(pos, 1)
            }
        }
        
        // We have at least the command itself
        IfCondition EqualTo(argc, 0) ThenBlock: {
            argc = 1
        }
        
        // Allocate argv array: (argc + 1) * 8 bytes for NULL terminator
        argv_size = Multiply(Add(argc, 1), 8)
        argv = Allocate(argv_size)
        
        // argv[0] should be the full path
        StorePointer(argv, full_cmd)
        
        // Fill rest of argv with pointers to each argument (starting from second arg)
        idx = 1
        pos = cmd_pos
        
        // Skip first argument (the command name)
        WhileLoop And(LessThan(pos, 4096), NotEqual(GetByte(args_buffer, pos), 0)) {
            pos = Add(pos, 1)
        }
        pos = Add(pos, 1)
        
        // Now copy remaining arguments
        WhileLoop LessThan(idx, argc) {
            arg_ptr = Add(args_buffer, pos)
            
            // Store pointer at argv[idx]
            StorePointer(Add(argv, Multiply(idx, 8)), arg_ptr)
            
            // Skip to next arg
            WhileLoop And(LessThan(pos, 4096), NotEqual(GetByte(args_buffer, pos), 0)) {
                pos = Add(pos, 1)
            }
            pos = Add(pos, 1)
            
            idx = Add(idx, 1)
        }
        
        // NULL terminator at argv[argc]
        StorePointer(Add(argv, Multiply(argc, 8)), 0)
        
        ReturnValue(argv)
    }
}

Function.FindInPath {
    Input: cmd: Address
    Output: Address
    Body: {
        // Check if command has a slash (absolute or relative path)
        i = 0
        has_slash = 0
        WhileLoop LessThan(i, 256) {
            ch = GetByte(cmd, i)
            IfCondition EqualTo(ch, 0) ThenBlock: {
                BreakLoop
            }
            IfCondition EqualTo(ch, 47) ThenBlock: {
                has_slash = 1
                BreakLoop
            }
            i = Add(i, 1)
        }
        
        // If it has a slash, use as-is
        IfCondition NotEqual(has_slash, 0) ThenBlock: {
            ReturnValue(cmd)
        }
        
        // Search in common paths
        paths = "/usr/local/bin:/usr/bin:/bin:/usr/local/sbin:/usr/sbin:/sbin"
        
        dir_start = 0
        i = 0
        
        WhileLoop LessThan(i, 1000) {
            ch = GetByte(paths, i)
            
            IfCondition Or(EqualTo(ch, 58), EqualTo(ch, 0)) ThenBlock: {
                // Extract directory
                dir_len = Subtract(i, dir_start)
                
                IfCondition GreaterThan(dir_len, 0) ThenBlock: {
                    // Build path: dir + "/" + cmd
                    cmd_len = StringLength(cmd)
                    full_len = Add(Add(dir_len, cmd_len), 2)
                    full_path = Allocate(full_len)
                    
                    // Copy directory
                    j = 0
                    WhileLoop LessThan(j, dir_len) {
                        SetByte(full_path, j, GetByte(paths, Add(dir_start, j)))
                        j = Add(j, 1)
                    }
                    
                    // Add slash
                    SetByte(full_path, j, 47)
                    j = Add(j, 1)
                    
                    // Copy command
                    k = 0
                    WhileLoop LessThan(k, cmd_len) {
                        SetByte(full_path, j, GetByte(cmd, k))
                        j = Add(j, 1)
                        k = Add(k, 1)
                    }
                    SetByte(full_path, j, 0)
                    
                    // Check if executable (access syscall 21)
                    result = SystemCall(21, full_path, 1)
                    
                    IfCondition GreaterEqual(result, 0) ThenBlock: {
                        ReturnValue(full_path)
                    }
                    
                    Deallocate(full_path, 0)
                }
                
                dir_start = Add(i, 1)
                
                IfCondition EqualTo(ch, 0) ThenBlock: {
                    BreakLoop
                }
            }
            
            i = Add(i, 1)
        }
        
        // Not found, return original
        ReturnValue(cmd)
    }
}

SubRoutine.Main {
    args_buffer = GetArgs()
    
    IfCondition EqualTo(args_buffer, 0) ThenBlock: {
        WriteStderr("nohup: missing operand\n", 23)
        SystemCall(60, 127)
    }
    
    // Skip program name
    pos = 0
    WhileLoop NotEqual(GetByte(args_buffer, pos), 0) {
        pos = Add(pos, 1)
    }
    pos = Add(pos, 1)
    
    // Check if we have a command
    cmd_pos = pos
    
    IfCondition GreaterEqual(pos, 4096) ThenBlock: {
        WriteStderr("nohup: missing operand\n", 23)
        Deallocate(args_buffer, 4096)
        SystemCall(60, 127)
    }
    
    IfCondition EqualTo(GetByte(args_buffer, pos), 0) ThenBlock: {
        WriteStderr("nohup: missing operand\n", 23)
        Deallocate(args_buffer, 4096)
        SystemCall(60, 127)
    }
    
    // Get command path
    cmd = Add(args_buffer, cmd_pos)
    
    // Find full path to command
    full_cmd = FindInPath(cmd)
    
    // Ignore SIGHUP
    IgnoreHangup()
    
    // Redirect output to nohup.out (do this BEFORE any output)
    redirect_result = RedirectOutput()
    
    IfCondition LessThan(redirect_result, 0) ThenBlock: {
        WriteStderr("nohup: failed to open nohup.out\n", 32)
        Deallocate(args_buffer, 4096)
        SystemCall(60, 127)
    }
    
    // Now all output goes to nohup.out
    WriteStdout("nohup: executing ", 17)
    WriteStdout(full_cmd, StringLength(full_cmd))
    WriteStdout("\n", 1)
    
    // Build argv array for execve
    argv = BuildArgvArray(args_buffer, cmd_pos, full_cmd)
    
    // execve syscall: 59 (pathname, argv, envp)
    // We pass 0 for envp to inherit parent's environment
    result = SystemCall(59, full_cmd, argv, 0)
    
    // If we get here, exec failed
    WriteStdout("nohup: exec failed with code ", 29)
    
    // Print errno (result is negative errno)
    errno = Subtract(0, result)
    errno_str = NumberToString(errno)
    WriteStdout(errno_str, StringLength(errno_str))
    WriteStdout("\n", 1)
    
    // If we get here, exec failed
    WriteStderr("nohup: failed to execute ", 25)
    WriteStderr(cmd, StringLength(cmd))
    WriteStderr("\n", 1)
    
    Deallocate(argv, 0)
    Deallocate(args_buffer, 4096)
    SystemCall(60, 127)
}

RunTask(Main)