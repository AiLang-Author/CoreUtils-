// ln.ailang - GNU-Compatible Link Creation Utility
// Usage: ln [OPTION]... TARGET LINK_NAME
//        ln [OPTION]... TARGET... DIRECTORY
// Create links to TARGET(s).
//
// Options:
//   -s, --symbolic            make symbolic links instead of hard links
//   -f, --force               remove existing destination files
//   -i, --interactive         prompt whether to remove destinations
//   -n, --no-dereference      treat LINK_NAME as a normal file if it is a
//                               symbolic link to a directory
//   -v, --verbose             print name of each linked file
//   -b, --backup              make a backup of each existing destination file
//   -L, --logical             dereference TARGETs that are symbolic links
//   -P, --physical            make hard links directly to symbolic links
//   --help                    display this help and exit
//   --version                 output version information and exit

FixedPool.LnConfig {
    "symbolic": Initialize=0
    "force": Initialize=0
    "interactive": Initialize=0
    "no_dereference": Initialize=0
    "verbose": Initialize=0
    "backup": Initialize=0
    "logical": Initialize=0
    "physical": Initialize=0
}

FixedPool.LnStats {
    "created": Initialize=0
    "errors": Initialize=0
    "backed_up": Initialize=0
}

FixedPool.LnConstants {
    "EEXIST": Initialize=17
    "ENOENT": Initialize=2
    "EACCES": Initialize=13
    "EXDEV": Initialize=18
    "EISDIR": Initialize=21
    "ENOTDIR": Initialize=20
    "EPERM": Initialize=1
}

// ============================================================================
// UTILITY FUNCTIONS
// ============================================================================

Function.WriteStdout {
    Input: str: Address
    Body: {
        len = StringLength(str)
        SystemCall(1, 1, str, len)
    }
}

Function.WriteStderr {
    Input: str: Address
    Body: {
        len = StringLength(str)
        SystemCall(1, 2, str, len)
    }
}

Function.IntToString {
    Input: num: Integer
    Output: Address
    Body: {
        IfCondition EqualTo(num, 0) ThenBlock: {
            str = Allocate(2)
            SetByte(str, 0, 48)
            SetByte(str, 1, 0)
            ReturnValue(str)
        }
        
        is_negative = LessThan(num, 0)
        abs_num = num
        IfCondition EqualTo(is_negative, 1) ThenBlock: {
            abs_num = Subtract(0, num)
        }
        
        temp = abs_num
        digits = 0
        WhileLoop GreaterThan(temp, 0) {
            temp = Divide(temp, 10)
            digits = Add(digits, 1)
        }
        
        total_len = digits
        IfCondition EqualTo(is_negative, 1) ThenBlock: {
            total_len = Add(total_len, 1)
        }
        
        str = Allocate(Add(total_len, 1))
        
        pos = 0
        IfCondition EqualTo(is_negative, 1) ThenBlock: {
            SetByte(str, 0, 45)
            pos = 1
        }
        
        i = Subtract(total_len, 1)
        temp = abs_num
        WhileLoop GreaterThan(temp, 0) {
            digit = Modulo(temp, 10)
            SetByte(str, i, Add(48, digit))
            temp = Divide(temp, 10)
            i = Subtract(i, 1)
        }
        
        SetByte(str, total_len, 0)
        ReturnValue(str)
    }
}

Function.PathExists {
    Input: path: Address
    Output: Integer
    Body: {
        statbuf = Allocate(144)
        result = SystemCall(4, path, statbuf)
        Deallocate(statbuf, 144)
        ReturnValue(GreaterEqual(result, 0))
    }
}

Function.IsDirectory {
    Input: path: Address
    Output: Integer
    Body: {
        statbuf = Allocate(144)
        result = SystemCall(4, path, statbuf)
        
        IfCondition LessThan(result, 0) ThenBlock: {
            Deallocate(statbuf, 144)
            ReturnValue(0)
        }
        
        st_mode = Dereference(Add(statbuf, 24))
        Deallocate(statbuf, 144)
        
        is_dir = BitwiseAnd(st_mode, 16384)
        ReturnValue(NotEqual(is_dir, 0))
    }
}

Function.BuildPath {
    Input: dir: Address
    Input: file: Address
    Output: Address
    Body: {
        dir_len = StringLength(dir)
        file_len = StringLength(file)
        
        needs_slash = 1
        IfCondition GreaterThan(dir_len, 0) ThenBlock: {
            last_char = GetByte(dir, Subtract(dir_len, 1))
            IfCondition EqualTo(last_char, 47) ThenBlock: {
                needs_slash = 0
            }
        }
        
        total_len = Add(Add(dir_len, file_len), Add(needs_slash, 1))
        path = Allocate(total_len)
        
        i = 0
        WhileLoop LessThan(i, dir_len) {
            SetByte(path, i, GetByte(dir, i))
            i = Add(i, 1)
        }
        
        IfCondition EqualTo(needs_slash, 1) ThenBlock: {
            SetByte(path, i, 47)
            i = Add(i, 1)
        }
        
        j = 0
        WhileLoop LessThan(j, file_len) {
            SetByte(path, i, GetByte(file, j))
            i = Add(i, 1)
            j = Add(j, 1)
        }
        
        SetByte(path, i, 0)
        ReturnValue(path)
    }
}

Function.GetBasename {
    Input: path: Address
    Output: Address
    Body: {
        len = StringLength(path)
        
        real_len = len
        WhileLoop And(GreaterThan(real_len, 0), 
                     EqualTo(GetByte(path, Subtract(real_len, 1)), 47)) {
            real_len = Subtract(real_len, 1)
        }
        
        last_slash = -1
        i = 0
        WhileLoop LessThan(i, real_len) {
            IfCondition EqualTo(GetByte(path, i), 47) ThenBlock: {
                last_slash = i
            }
            i = Add(i, 1)
        }
        
        start = Add(last_slash, 1)
        basename_len = Subtract(real_len, start)
        
        IfCondition EqualTo(basename_len, 0) ThenBlock: {
            basename = Allocate(2)
            SetByte(basename, 0, 47)
            SetByte(basename, 1, 0)
            ReturnValue(basename)
        }
        
        basename = Allocate(Add(basename_len, 1))
        i = 0
        WhileLoop LessThan(i, basename_len) {
            SetByte(basename, i, GetByte(path, Add(start, i)))
            i = Add(i, 1)
        }
        SetByte(basename, basename_len, 0)
        
        ReturnValue(basename)
    }
}

Function.GetErrorString {
    Input: errno: Integer
    Output: Address
    Body: {
        abs_errno = errno
        IfCondition LessThan(errno, 0) ThenBlock: {
            abs_errno = Subtract(0, errno)
        }
        
        IfCondition EqualTo(abs_errno, LnConstants.EEXIST) ThenBlock: {
            ReturnValue("File exists")
        }
        
        IfCondition EqualTo(abs_errno, LnConstants.ENOENT) ThenBlock: {
            ReturnValue("No such file or directory")
        }
        
        IfCondition EqualTo(abs_errno, LnConstants.EACCES) ThenBlock: {
            ReturnValue("Permission denied")
        }
        
        IfCondition EqualTo(abs_errno, LnConstants.EXDEV) ThenBlock: {
            ReturnValue("Invalid cross-device link")
        }
        
        IfCondition EqualTo(abs_errno, LnConstants.EISDIR) ThenBlock: {
            ReturnValue("Is a directory")
        }
        
        IfCondition EqualTo(abs_errno, LnConstants.ENOTDIR) ThenBlock: {
            ReturnValue("Not a directory")
        }
        
        IfCondition EqualTo(abs_errno, LnConstants.EPERM) ThenBlock: {
            ReturnValue("Operation not permitted")
        }
        
        ReturnValue("Unknown error")
    }
}

Function.PromptUser {
    Input: prompt: Address
    Output: Integer
    Body: {
        WriteStderr(prompt)
        
        response = Allocate(8)
        bytes = SystemCall(0, 0, response, 8)
        
        IfCondition LessEqual(bytes, 0) ThenBlock: {
            Deallocate(response, 8)
            ReturnValue(0)
        }
        
        ch = GetByte(response, 0)
        Deallocate(response, 8)
        
        result = Or(EqualTo(ch, 121), EqualTo(ch, 89))
        ReturnValue(result)
    }
}

// ============================================================================
// CORE LINK FUNCTIONS
// ============================================================================

Function.CreateLink {
    Input: target: Address
    Input: linkname: Address
    Output: Integer
    Body: {
        exists = PathExists(linkname)
        
        IfCondition EqualTo(exists, 1) ThenBlock: {
            IfCondition EqualTo(LnConfig.interactive, 1) ThenBlock: {
                WriteStderr("ln: replace '")
                WriteStderr(linkname)
                WriteStderr("'? ")
                
                response = PromptUser("")
                IfCondition EqualTo(response, 0) ThenBlock: {
                    ReturnValue(0)
                }
            }
            
            IfCondition EqualTo(LnConfig.force, 1) ThenBlock: {
                unlink_result = SystemCall(87, linkname)
                IfCondition LessThan(unlink_result, 0) ThenBlock: {
                    WriteStderr("ln: cannot remove '")
                    WriteStderr(linkname)
                    WriteStderr("': ")
                    WriteStderr(GetErrorString(unlink_result))
                    WriteStderr("\n")
                    LnStats.errors = Add(LnStats.errors, 1)
                    ReturnValue(1)
                }
            } ElseBlock: {
                WriteStderr("ln: failed to create ")
                IfCondition EqualTo(LnConfig.symbolic, 1) ThenBlock: {
                    WriteStderr("symbolic ")
                }
                WriteStderr("link '")
                WriteStderr(linkname)
                WriteStderr("': File exists\n")
                LnStats.errors = Add(LnStats.errors, 1)
                ReturnValue(1)
            }
        }
        
        result = 0
        IfCondition EqualTo(LnConfig.symbolic, 1) ThenBlock: {
            result = SystemCall(88, target, linkname)
        } ElseBlock: {
            result = SystemCall(86, target, linkname)
        }
        
        IfCondition LessThan(result, 0) ThenBlock: {
            WriteStderr("ln: failed to create ")
            IfCondition EqualTo(LnConfig.symbolic, 1) ThenBlock: {
                WriteStderr("symbolic ")
            }
            WriteStderr("link '")
            WriteStderr(linkname)
            WriteStderr("'")
            
            IfCondition EqualTo(LnConfig.symbolic, 0) ThenBlock: {
                WriteStderr(" => '")
                WriteStderr(target)
                WriteStderr("'")
            }
            
            WriteStderr(": ")
            WriteStderr(GetErrorString(result))
            WriteStderr("\n")
            
            LnStats.errors = Add(LnStats.errors, 1)
            ReturnValue(1)
        }
        
        LnStats.created = Add(LnStats.created, 1)
        
        IfCondition EqualTo(LnConfig.verbose, 1) ThenBlock: {
            WriteStderr("'")
            WriteStderr(linkname)
            WriteStderr("' ")
            
            IfCondition EqualTo(LnConfig.symbolic, 1) ThenBlock: {
                WriteStderr("-> '")
                WriteStderr(target)
                WriteStderr("'\n")
            } ElseBlock: {
                WriteStderr("=> '")
                WriteStderr(target)
                WriteStderr("'\n")
            }
        }
        
        ReturnValue(0)
    }
}

// ============================================================================
// ARGUMENT PARSING
// ============================================================================

Function.GetArgs {
    Output: Address
    Body: {
        fd = SystemCall(257, -100, "/proc/self/cmdline", 0, 0)
        IfCondition LessThan(fd, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        buffer = Allocate(4096)
        bytes_read = SystemCall(0, fd, buffer, 4096)
        SystemCall(3, fd)
        
        IfCondition LessEqual(bytes_read, 0) ThenBlock: {
            Deallocate(buffer, 4096)
            ReturnValue(0)
        }
        
        ReturnValue(buffer)
    }
}

Function.StringCompare {
    Input: str1: Address
    Input: str2: Address
    Output: Integer
    Body: {
        i = 0
        WhileLoop 1 {
            ch1 = GetByte(str1, i)
            ch2 = GetByte(str2, i)
            
            IfCondition NotEqual(ch1, ch2) ThenBlock: {
                ReturnValue(0)
            }
            
            IfCondition EqualTo(ch1, 0) ThenBlock: {
                ReturnValue(1)
            }
            
            i = Add(i, 1)
        }
        ReturnValue(1)
    }
}

Function.ShowHelp {
    Body: {
        WriteStdout("Usage: ln [OPTION]... TARGET LINK_NAME\n")
        WriteStdout("  or:  ln [OPTION]... TARGET... DIRECTORY\n")
        WriteStdout("Create a link to TARGET with the name LINK_NAME.\n")
        WriteStdout("Create links to each TARGET in DIRECTORY.\n")
        WriteStdout("\n")
        WriteStdout("Mandatory arguments to long options are mandatory for short options too.\n")
        WriteStdout("  -f, --force              remove existing destination files\n")
        WriteStdout("  -i, --interactive        prompt whether to remove destinations\n")
        WriteStdout("  -n, --no-dereference     treat LINK_NAME as a normal file if\n")
        WriteStdout("                             it is a symbolic link to a directory\n")
        WriteStdout("  -s, --symbolic           make symbolic links instead of hard links\n")
        WriteStdout("  -v, --verbose            print name of each linked file\n")
        WriteStdout("  -L, --logical            dereference TARGETs that are symbolic links\n")
        WriteStdout("  -P, --physical           make hard links directly to symbolic links\n")
        WriteStdout("      --help               display this help and exit\n")
        WriteStdout("      --version            output version information and exit\n")
        WriteStdout("\n")
        WriteStdout("Using -s ignores -L and -P.  Otherwise, the last option specified controls\n")
        WriteStdout("behavior when a TARGET is a symbolic link, defaulting to -P.\n")
        WriteStdout("\n")
        WriteStdout("GNU coreutils compatible ln implementation in AiLang.\n")
    }
}

Function.ShowVersion {
    Body: {
        WriteStdout("ln (AiLang coreutils) 1.0\n")
        WriteStdout("Copyright (C) 2025 AiLang Project\n")
        WriteStdout("License: MIT\n")
        WriteStdout("\n")
        WriteStdout("Written in AiLang - A language designed for human and LLM comprehension.\n")
    }
}

// ============================================================================
// MAIN ROUTINE
// ============================================================================

SubRoutine.Main {
    args_buffer = GetArgs()
    
    IfCondition EqualTo(args_buffer, 0) ThenBlock: {
        WriteStderr("ln: failed to read arguments\n")
        SystemCall(60, 1)
    }
    
    pos = 0
    WhileLoop NotEqual(GetByte(args_buffer, pos), 0) {
        pos = Add(pos, 1)
    }
    pos = Add(pos, 1)
    
    max_targets = 256
    targets = ArrayCreate(max_targets)
    target_count = 0
    
    WhileLoop LessThan(pos, 4096) {
        ch = GetByte(args_buffer, pos)
        IfCondition EqualTo(ch, 0) ThenBlock: {
            BreakLoop
        }
        
        first = GetByte(args_buffer, pos)
        
        IfCondition EqualTo(first, 45) ThenBlock: {
            arg_start = pos
            arg_len = 0
            
            WhileLoop And(LessThan(pos, 4096), NotEqual(GetByte(args_buffer, pos), 0)) {
                arg_len = Add(arg_len, 1)
                pos = Add(pos, 1)
            }
            
            flag = Allocate(Add(arg_len, 1))
            i = 0
            WhileLoop LessThan(i, arg_len) {
                SetByte(flag, i, GetByte(args_buffer, Add(arg_start, i)))
                i = Add(i, 1)
            }
            SetByte(flag, arg_len, 0)
            
            IfCondition StringCompare(flag, "--help") ThenBlock: {
                ShowHelp()
                Deallocate(flag, Add(arg_len, 1))
                ArrayDestroy(targets)
                Deallocate(args_buffer, 4096)
                SystemCall(60, 0)
            }
            
            IfCondition StringCompare(flag, "--version") ThenBlock: {
                ShowVersion()
                Deallocate(flag, Add(arg_len, 1))
                ArrayDestroy(targets)
                Deallocate(args_buffer, 4096)
                SystemCall(60, 0)
            }
            
            IfCondition StringCompare(flag, "--symbolic") ThenBlock: {
                LnConfig.symbolic = 1
            }
            
            IfCondition StringCompare(flag, "--force") ThenBlock: {
                LnConfig.force = 1
            }
            
            IfCondition StringCompare(flag, "--interactive") ThenBlock: {
                LnConfig.interactive = 1
            }
            
            IfCondition StringCompare(flag, "--verbose") ThenBlock: {
                LnConfig.verbose = 1
            }
            
            IfCondition StringCompare(flag, "--no-dereference") ThenBlock: {
                LnConfig.no_dereference = 1
            }
            
            IfCondition StringCompare(flag, "--logical") ThenBlock: {
                LnConfig.logical = 1
            }
            
            IfCondition StringCompare(flag, "--physical") ThenBlock: {
                LnConfig.physical = 1
            }
            
            i = 1
            WhileLoop LessThan(i, arg_len) {
                flag_char = GetByte(flag, i)
                
                IfCondition EqualTo(flag_char, 115) ThenBlock: {
                    LnConfig.symbolic = 1
                }
                
                IfCondition EqualTo(flag_char, 102) ThenBlock: {
                    LnConfig.force = 1
                }
                
                IfCondition EqualTo(flag_char, 105) ThenBlock: {
                    LnConfig.interactive = 1
                }
                
                IfCondition EqualTo(flag_char, 118) ThenBlock: {
                    LnConfig.verbose = 1
                }
                
                IfCondition EqualTo(flag_char, 110) ThenBlock: {
                    LnConfig.no_dereference = 1
                }
                
                IfCondition EqualTo(flag_char, 76) ThenBlock: {
                    LnConfig.logical = 1
                }
                
                IfCondition EqualTo(flag_char, 80) ThenBlock: {
                    LnConfig.physical = 1
                }
                
                i = Add(i, 1)
            }
            
            Deallocate(flag, Add(arg_len, 1))
        } ElseBlock: {
            arg_start = pos
            arg_len = 0
            
            WhileLoop And(LessThan(pos, 4096), NotEqual(GetByte(args_buffer, pos), 0)) {
                arg_len = Add(arg_len, 1)
                pos = Add(pos, 1)
            }
            
            filename = Allocate(Add(arg_len, 1))
            i = 0
            WhileLoop LessThan(i, arg_len) {
                SetByte(filename, i, GetByte(args_buffer, Add(arg_start, i)))
                i = Add(i, 1)
            }
            SetByte(filename, arg_len, 0)
            
            IfCondition LessThan(target_count, max_targets) ThenBlock: {
                ArraySet(targets, target_count, filename)
                target_count = Add(target_count, 1)
            }
        }
        
        pos = Add(pos, 1)
    }
    
    Deallocate(args_buffer, 4096)
    
    IfCondition LessThan(target_count, 2) ThenBlock: {
        WriteStderr("ln: missing operand")
        IfCondition EqualTo(target_count, 1) ThenBlock: {
            WriteStderr(" after '")
            target = ArrayGet(targets, 0)
            WriteStderr(target)
            WriteStderr("'")
        }
        WriteStderr("\n")
        WriteStderr("Try 'ln --help' for more information.\n")
        ArrayDestroy(targets)
        SystemCall(60, 1)
    }
    
    last_arg = ArrayGet(targets, Subtract(target_count, 1))
    is_dir = IsDirectory(last_arg)
    
    IfCondition GreaterThan(target_count, 2) ThenBlock: {
        IfCondition EqualTo(is_dir, 0) ThenBlock: {
            WriteStderr("ln: target '")
            WriteStderr(last_arg)
            WriteStderr("' is not a directory\n")
            ArrayDestroy(targets)
            SystemCall(60, 1)
        }
        
        i = 0
        WhileLoop LessThan(i, Subtract(target_count, 1)) {
            target = ArrayGet(targets, i)
            basename = GetBasename(target)
            linkname = BuildPath(last_arg, basename)
            
            result = CreateLink(target, linkname)
            
            Deallocate(basename, 0)
            Deallocate(linkname, 0)
            Deallocate(target, 0)
            i = Add(i, 1)
        }
    } ElseBlock: {
        target = ArrayGet(targets, 0)
        linkname = ArrayGet(targets, 1)
        
        IfCondition EqualTo(is_dir, 1) ThenBlock: {
            basename = GetBasename(target)
            final_link = BuildPath(linkname, basename)
            result = CreateLink(target, final_link)
            Deallocate(basename, 0)
            Deallocate(final_link, 0)
        } ElseBlock: {
            result = CreateLink(target, linkname)
        }
        
        Deallocate(target, 0)
        Deallocate(linkname, 0)
    }
    
    ArrayDestroy(targets)
    
    exit_code = 0
    IfCondition GreaterThan(LnStats.errors, 0) ThenBlock: {
        exit_code = 1
    }
    
    SystemCall(60, exit_code)
}

RunTask(Main)