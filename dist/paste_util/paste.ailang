// paste_fixed_no_function_pools.ailang
// Fixed: No FixedPool access from inside Functions

FixedPool.PasteConfig {
    "delimiter": Initialize=9
    "serial": Initialize=0
}

FixedPool.OutputBuffer {
    "buffer": Initialize=0
    "position": Initialize=0
    "size": Initialize=524288
}

FixedPool.FileBuffer {
    "buffer": Initialize=0
    "position": Initialize=0
    "end": Initialize=0
    "size": Initialize=262144
}

FixedPool.StdinMailbox {
    "head": Initialize=0
    "tail": Initialize=0
    "count": Initialize=0
    "slot0": Initialize=0
    "slot1": Initialize=0
    "slot2": Initialize=0
    "slot3": Initialize=0
    "slot4": Initialize=0
    "slot5": Initialize=0
    "slot6": Initialize=0
    "slot7": Initialize=0
}

Function.InitBuffers {
    Body: {
        OutputBuffer.buffer = Allocate(OutputBuffer.size)
        OutputBuffer.position = 0
    }
}

Function.FlushOutput {
    Body: {
        IfCondition GreaterThan(OutputBuffer.position, 0) ThenBlock: {
            SystemCall(1, 1, OutputBuffer.buffer, OutputBuffer.position)
            OutputBuffer.position = 0
        }
    }
}

Function.WriteBuffered {
    Input: data: Address
    Input: len: Integer
    Body: {
        space_left = Subtract(OutputBuffer.size, OutputBuffer.position)
        IfCondition LessThan(space_left, len) ThenBlock: {
            FlushOutput()
        }
        
        MemCopy(Add(OutputBuffer.buffer, OutputBuffer.position), data, len)
        OutputBuffer.position = Add(OutputBuffer.position, len)
    }
}

Function.WriteByteBuffered {
    Input: byte: Integer
    Body: {
        IfCondition GreaterEqual(OutputBuffer.position, OutputBuffer.size) ThenBlock: {
            FlushOutput()
        }
        SetByte(OutputBuffer.buffer, OutputBuffer.position, byte)
        OutputBuffer.position = Add(OutputBuffer.position, 1)
    }
}

Function.WriteStderr {
    Input: buffer: Address
    Input: len: Integer
    Body: {
        SystemCall(1, 2, buffer, len)
    }
}

Function.GetStringLength {
    Input: str: Address
    Output: Integer
    Body: {
        len = 0
        WhileLoop NotEqual(GetByte(str, len), 0) {
            len = Add(len, 1)
        }
        ReturnValue(len)
    }
}

Function.SkipToNextArg {
    Input: args: Address
    Input: current_pos: Integer
    Output: Integer
    Body: {
        pos = current_pos
        WhileLoop NotEqual(GetByte(args, pos), 0) {
            pos = Add(pos, 1)
        }
        pos = Add(pos, 1)
        ReturnValue(pos)
    }
}

Function.CreateFileBuffer {
    Output: Address
    Body: {
        fb = Allocate(32)
        buffer = Allocate(FileBuffer.size)
        
        StoreValue(fb, buffer)
        StoreValue(Add(fb, 8), 0)
        StoreValue(Add(fb, 16), 0)
        StoreValue(Add(fb, 24), FileBuffer.size)
        
        ReturnValue(fb)
    }
}

Function.DestroyFileBuffer {
    Input: fb: Address
    Body: {
        buffer = Dereference(fb)
        Deallocate(buffer, FileBuffer.size)
        Deallocate(fb, 32)
    }
}

// Mailbox functions - these work because they only access FixedPool.StdinMailbox
Function.MailboxSend {
    Input: line_data: Address
    Input: line_len: Integer
    Body: {
        IfCondition LessThan(StdinMailbox.count, 8) ThenBlock: {
            pos = StdinMailbox.tail
            
            cached_line = Allocate(Add(line_len, 1))
            MemCopy(cached_line, line_data, line_len)
            SetByte(cached_line, line_len, 0)
            
            packed = Add(Multiply(cached_line, 65536), line_len)
            
            Branch pos {
                Case 0: { StdinMailbox.slot0 = packed }
                Case 1: { StdinMailbox.slot1 = packed }
                Case 2: { StdinMailbox.slot2 = packed }
                Case 3: { StdinMailbox.slot3 = packed }
                Case 4: { StdinMailbox.slot4 = packed }
                Case 5: { StdinMailbox.slot5 = packed }
                Case 6: { StdinMailbox.slot6 = packed }
                Case 7: { StdinMailbox.slot7 = packed }
            }
            
            StdinMailbox.tail = Modulo(Add(pos, 1), 8)
            StdinMailbox.count = Add(StdinMailbox.count, 1)
        }
    }
}

Function.MailboxReceive {
    Output: Address
    Body: {
        result = Allocate(16)
        StoreValue(result, 0)
        StoreValue(Add(result, 8), -1)
        
        IfCondition GreaterThan(StdinMailbox.count, 0) ThenBlock: {
            pos = StdinMailbox.head
            packed = 0
            
            Branch pos {
                Case 0: { packed = StdinMailbox.slot0 }
                Case 1: { packed = StdinMailbox.slot1 }
                Case 2: { packed = StdinMailbox.slot2 }
                Case 3: { packed = StdinMailbox.slot3 }
                Case 4: { packed = StdinMailbox.slot4 }
                Case 5: { packed = StdinMailbox.slot5 }
                Case 6: { packed = StdinMailbox.slot6 }
                Case 7: { packed = StdinMailbox.slot7 }
            }
            
            line_len = Modulo(packed, 65536)
            cached_line = Divide(packed, 65536)
            
            StoreValue(result, cached_line)
            StoreValue(Add(result, 8), line_len)
            
            StdinMailbox.head = Modulo(Add(pos, 1), 8)
            StdinMailbox.count = Subtract(StdinMailbox.count, 1)
        }
        
        ReturnValue(result)
    }
}

Function.PreloadStdin {
    Input: stdin_fb: Address
    Body: {
        lines_loaded = 0
        max_lines = 1000
        
        WhileLoop LessThan(lines_loaded, max_lines) {
            buffer = Dereference(stdin_fb)
            pos = Dereference(Add(stdin_fb, 8))
            end = Dereference(Add(stdin_fb, 16))
            
            IfCondition GreaterEqual(pos, end) ThenBlock: {
                bytes_read = SystemCall(0, 0, buffer, FileBuffer.size)
                IfCondition LessEqual(bytes_read, 0) ThenBlock: {
                    BreakLoop
                }
                StoreValue(Add(stdin_fb, 8), 0)
                StoreValue(Add(stdin_fb, 16), bytes_read)
                pos = 0
                end = bytes_read
            }
            
            search_start = Add(buffer, pos)
            search_len = Subtract(end, pos)
            newline_offset = MemChr(search_start, 10, search_len)
            
            IfCondition LessThan(newline_offset, 0) ThenBlock: {
                BreakLoop
            }
            
            MailboxSend(search_start, newline_offset)
            StoreValue(Add(stdin_fb, 8), Add(pos, Add(newline_offset, 1)))
            lines_loaded = Add(lines_loaded, 1)
            
            IfCondition GreaterEqual(StdinMailbox.count, 6) ThenBlock: {
                BreakLoop
            }
        }
    }
}

Function.GetSingleLineBuffered {
    Input: fb: Address
    Input: fd: Integer
    Input: output: Address
    Input: max_len: Integer
    Output: Integer
    Body: {
        buffer = Dereference(fb)
        pos = Dereference(Add(fb, 8))
        end = Dereference(Add(fb, 16))
        output_pos = 0
        
        WhileLoop LessThan(output_pos, max_len) {
            IfCondition GreaterEqual(pos, end) ThenBlock: {
                bytes_read = SystemCall(0, fd, buffer, FileBuffer.size)
                IfCondition LessEqual(bytes_read, 0) ThenBlock: {
                    IfCondition EqualTo(output_pos, 0) ThenBlock: {
                        ReturnValue(-1)
                    } ElseBlock: {
                        ReturnValue(output_pos)
                    }
                }
                pos = 0
                end = bytes_read
                StoreValue(Add(fb, 16), end)
            }
            
            search_start = Add(buffer, pos)
            search_len = Subtract(end, pos)
            remaining_output = Subtract(max_len, output_pos)
            
            IfCondition GreaterThan(search_len, remaining_output) ThenBlock: {
                search_len = remaining_output
            }
            
            newline_offset = MemChr(search_start, 10, search_len)
            
            IfCondition LessThan(newline_offset, 0) ThenBlock: {
                MemCopy(Add(output, output_pos), search_start, search_len)
                output_pos = Add(output_pos, search_len)
                pos = Add(pos, search_len)
                StoreValue(Add(fb, 8), pos)
            } ElseBlock: {
                MemCopy(Add(output, output_pos), search_start, newline_offset)
                output_pos = Add(output_pos, newline_offset)
                pos = Add(pos, Add(newline_offset, 1))
                StoreValue(Add(fb, 8), pos)
                ReturnValue(output_pos)
            }
        }
        
        StoreValue(Add(fb, 8), pos)
        ReturnValue(output_pos)
    }
}

Function.GetStdinLine {
    Input: fb: Address
    Input: output: Address
    Input: max_len: Integer
    Output: Integer
    Body: {
        IfCondition GreaterThan(StdinMailbox.count, 0) ThenBlock: {
            result = MailboxReceive()
            cached_line = Dereference(result)
            line_len = Dereference(Add(result, 8))
            Deallocate(result, 16)
            
            IfCondition GreaterEqual(line_len, 0) ThenBlock: {
                copy_len = line_len
                IfCondition GreaterThan(copy_len, max_len) ThenBlock: {
                    copy_len = max_len
                }
                MemCopy(output, cached_line, copy_len)
                Deallocate(cached_line, Add(line_len, 1))
                ReturnValue(copy_len)
            }
        }
        
        ReturnValue(GetSingleLineBuffered(fb, 0, output, max_len))
    }
}

Function.PasteSerial {
    Input: fd: Integer
    Body: {
        buffer = Allocate(4096)
        fb = CreateFileBuffer()
        first_line = 1
        
        WhileLoop LessThan(0, 1) {
            line_len = GetSingleLineBuffered(fb, fd, buffer, 4096)
            
            IfCondition LessThan(line_len, 0) ThenBlock: {
                BreakLoop
            }
            
            IfCondition EqualTo(first_line, 0) ThenBlock: {
                WriteByteBuffered(PasteConfig.delimiter)
            }
            
            WriteBuffered(buffer, line_len)
            first_line = 0
        }
        
        WriteByteBuffered(10)
        DestroyFileBuffer(fb)
        Deallocate(buffer, 4096)
    }
}

Function.PrintHelp {
    Body: {
        help_text = "Usage: paste [OPTION]... [FILE]...
Write lines consisting of the sequentially corresponding lines from
each FILE, separated by TABs, to standard output.

  -d DELIM   use DELIM instead of TAB
  -s         paste one file at a time instead of in parallel
  --help     display this help and exit

Examples:
  paste file1 file2       Merge lines side-by-side
  paste -s file.txt       Join all lines with tabs
  paste -d , f1 f2        Use comma as delimiter
  paste - -               Read stdin twice (proper columns)
"
        WriteBuffered(help_text, GetStringLength(help_text))
        FlushOutput()
    }
}

Function.GetArgs {
    Output: Address
    Body: {
        fd = SystemCall(257, -100, "/proc/self/cmdline", 0, 0)
        IfCondition LessThan(fd, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        buffer = Allocate(4096)
        bytes_read = SystemCall(0, fd, buffer, 4096)
        SystemCall(3, fd)
        
        IfCondition LessEqual(bytes_read, 0) ThenBlock: {
            Deallocate(buffer, 4096)
            ReturnValue(0)
        }
        
        ReturnValue(buffer)
    }
}

SubRoutine.Main {
    InitBuffers()
    
    args_buffer = GetArgs()
    
    IfCondition EqualTo(args_buffer, 0) ThenBlock: {
        WriteStderr("paste: cannot read arguments\n", 29)
        SystemCall(60, 1)
    }
    
    pos = 0
    WhileLoop NotEqual(GetByte(args_buffer, pos), 0) {
        pos = Add(pos, 1)
    }
    pos = Add(pos, 1)
    
    show_help = 0
    num_files = 0
    
    WhileLoop LessThan(pos, 4096) {
        ch = GetByte(args_buffer, pos)
        IfCondition EqualTo(ch, 0) ThenBlock: {
            BreakLoop
        }
        
        IfCondition EqualTo(ch, 45) ThenBlock: {
            next_ch = GetByte(args_buffer, Add(pos, 1))
            
            IfCondition EqualTo(next_ch, 0) ThenBlock: {
                num_files = Add(num_files, 1)
                pos = SkipToNextArg(args_buffer, pos)
            } ElseBlock: {
                IfCondition EqualTo(next_ch, 45) ThenBlock: {
                    third_ch = GetByte(args_buffer, Add(pos, 2))
                    IfCondition EqualTo(third_ch, 104) ThenBlock: {
                        show_help = 1
                    }
                    pos = SkipToNextArg(args_buffer, pos)
                } ElseBlock: {
                    IfCondition EqualTo(next_ch, 115) ThenBlock: {
                        PasteConfig.serial = 1
                        pos = SkipToNextArg(args_buffer, pos)
                    } ElseBlock: {
                        IfCondition EqualTo(next_ch, 100) ThenBlock: {
                            PasteConfig.delimiter = GetByte(args_buffer, Add(pos, 2))
                            pos = SkipToNextArg(args_buffer, pos)
                        } ElseBlock: {
                            IfCondition EqualTo(next_ch, 104) ThenBlock: {
                                show_help = 1
                                pos = SkipToNextArg(args_buffer, pos)
                            } ElseBlock: {
                                pos = SkipToNextArg(args_buffer, pos)
                            }
                        }
                    }
                }
            }
        } ElseBlock: {
            num_files = Add(num_files, 1)
            pos = SkipToNextArg(args_buffer, pos)
        }
    }
    
    IfCondition NotEqual(show_help, 0) ThenBlock: {
        PrintHelp()
        Deallocate(args_buffer, 4096)
        SystemCall(60, 0)
    }
    
    IfCondition EqualTo(num_files, 0) ThenBlock: {
        IfCondition NotEqual(PasteConfig.serial, 0) ThenBlock: {
            PasteSerial(0)
        } ElseBlock: {
            // Single stdin, no mailbox needed
            line_buf = Allocate(4096)
            fb = CreateFileBuffer()
            
            WhileLoop LessThan(0, 1) {
                line_len = GetSingleLineBuffered(fb, 0, line_buf, 4096)
                IfCondition LessThan(line_len, 0) ThenBlock: {
                    BreakLoop
                }
                WriteBuffered(line_buf, line_len)
                WriteByteBuffered(10)
            }
            
            DestroyFileBuffer(fb)
            Deallocate(line_buf, 4096)
        }
        FlushOutput()
        Deallocate(args_buffer, 4096)
        SystemCall(60, 0)
    }
    
    // Allocate arrays for file management
    file_fds = Allocate(Multiply(num_files, 8))
    is_stdin_map = Allocate(Multiply(num_files, 8))
    file_index = 0
    
    // Parse arguments again to open files
    pos = 0
    WhileLoop NotEqual(GetByte(args_buffer, pos), 0) {
        pos = Add(pos, 1)
    }
    pos = Add(pos, 1)
    
    WhileLoop LessThan(pos, 4096) {
        ch = GetByte(args_buffer, pos)
        IfCondition EqualTo(ch, 0) ThenBlock: {
            BreakLoop
        }
        
        IfCondition EqualTo(ch, 45) ThenBlock: {
            next_ch = GetByte(args_buffer, Add(pos, 1))
            
            IfCondition EqualTo(next_ch, 0) ThenBlock: {
                fd = 0
                StoreValue(Add(file_fds, Multiply(file_index, 8)), fd)
                StoreValue(Add(is_stdin_map, Multiply(file_index, 8)), 1)
                file_index = Add(file_index, 1)
                pos = SkipToNextArg(args_buffer, pos)
            } ElseBlock: {
                pos = SkipToNextArg(args_buffer, pos)
            }
        } ElseBlock: {
            file_path = Add(args_buffer, pos)
            fd = SystemCall(2, file_path, 0)
            
            IfCondition LessThan(fd, 0) ThenBlock: {
                WriteStderr("paste: ", 7)
                WriteStderr(file_path, GetStringLength(file_path))
                WriteStderr(": No such file or directory\n", 28)
                fd = -1
            }
            
            StoreValue(Add(file_fds, Multiply(file_index, 8)), fd)
            StoreValue(Add(is_stdin_map, Multiply(file_index, 8)), 0)
            file_index = Add(file_index, 1)
            pos = SkipToNextArg(args_buffer, pos)
        }
    }
    
    // Handle serial mode
    IfCondition NotEqual(PasteConfig.serial, 0) ThenBlock: {
        i = 0
        WhileLoop LessThan(i, num_files) {
            fd = Dereference(Add(file_fds, Multiply(i, 8)))
            
            IfCondition GreaterEqual(fd, 0) ThenBlock: {
                PasteSerial(fd)
                SystemCall(3, fd)
            }
            
            i = Add(i, 1)
        }
        
        FlushOutput()
        Deallocate(is_stdin_map, Multiply(num_files, 8))
        Deallocate(file_fds, Multiply(num_files, 8))
        Deallocate(args_buffer, 4096)
        SystemCall(60, 0)
    }
    
    // PARALLEL MODE - All logic in Main/SubRoutine context
    
    // Count stdin occurrences
    stdin_count = 0
    i = 0
    WhileLoop LessThan(i, num_files) {
        is_stdin = Dereference(Add(is_stdin_map, Multiply(i, 8)))
        IfCondition EqualTo(is_stdin, 1) ThenBlock: {
            stdin_count = Add(stdin_count, 1)
        }
        i = Add(i, 1)
    }
    
    // Create ONE shared stdin buffer
    stdin_fb = CreateFileBuffer()
    
    // Preload stdin if multiple stdin args
    IfCondition GreaterThan(stdin_count, 1) ThenBlock: {
        PreloadStdin(stdin_fb)
    }
    
    // Allocate line buffers and file buffers
    line_buffers = Allocate(Multiply(num_files, 8))
    file_buffers = Allocate(Multiply(num_files, 8))
    line_lengths = Allocate(Multiply(num_files, 8))  // NEW: Store lengths
    
    i = 0
    WhileLoop LessThan(i, num_files) {
        line_buf = Allocate(4096)
        StoreValue(Add(line_buffers, Multiply(i, 8)), line_buf)
        
        is_stdin = Dereference(Add(is_stdin_map, Multiply(i, 8)))
        IfCondition EqualTo(is_stdin, 1) ThenBlock: {
            StoreValue(Add(file_buffers, Multiply(i, 8)), stdin_fb)
        } ElseBlock: {
            fb = CreateFileBuffer()
            StoreValue(Add(file_buffers, Multiply(i, 8)), fb)
        }
        
        i = Add(i, 1)
    }
    
    // Main processing loop
    continue_processing = 1
    
    WhileLoop NotEqual(continue_processing, 0) {
        // Count active files
        active_count = 0
        i = 0
        WhileLoop LessThan(i, num_files) {
            fd = Dereference(Add(file_fds, Multiply(i, 8)))
            IfCondition GreaterEqual(fd, 0) ThenBlock: {
                active_count = Add(active_count, 1)
            }
            i = Add(i, 1)
        }
        
        IfCondition EqualTo(active_count, 0) ThenBlock: {
            continue_processing = 0
        } ElseBlock: {
            // Process one row
            row_has_data = 0
            
            // Read from all files
            i = 0
            WhileLoop LessThan(i, num_files) {
                fd = Dereference(Add(file_fds, Multiply(i, 8)))
                line_buf = Dereference(Add(line_buffers, Multiply(i, 8)))
                fb = Dereference(Add(file_buffers, Multiply(i, 8)))
                is_stdin = Dereference(Add(is_stdin_map, Multiply(i, 8)))
                
                line_len = -1
                
                IfCondition GreaterEqual(fd, 0) ThenBlock: {
                    IfCondition EqualTo(is_stdin, 1) ThenBlock: {
                        line_len = GetStdinLine(fb, line_buf, 4096)
                    } ElseBlock: {
                        line_len = GetSingleLineBuffered(fb, fd, line_buf, 4096)
                    }
                    
                    IfCondition LessThan(line_len, 0) ThenBlock: {
                        StoreValue(Add(file_fds, Multiply(i, 8)), -1)
                    } ElseBlock: {
                        row_has_data = 1
                    }
                }
                
                // Store length for this column
                StoreValue(Add(line_lengths, Multiply(i, 8)), line_len)
                
                i = Add(i, 1)
            }
            
            // Only write output if we had data in this row
            IfCondition NotEqual(row_has_data, 0) ThenBlock: {
                i = 0
                WhileLoop LessThan(i, num_files) {
                    line_len = Dereference(Add(line_lengths, Multiply(i, 8)))
                    line_buf = Dereference(Add(line_buffers, Multiply(i, 8)))
                    
                    // Write data if this column has it
                    IfCondition GreaterEqual(line_len, 0) ThenBlock: {
                        WriteBuffered(line_buf, line_len)
                    }
                    
                    // Write delimiter (except after last column)
                    IfCondition LessThan(i, Subtract(num_files, 1)) ThenBlock: {
                        WriteByteBuffered(PasteConfig.delimiter)
                    }
                    
                    i = Add(i, 1)
                }
                
                WriteByteBuffered(10)
            }
        }
    }
    
    // Cleanup
    i = 0
    WhileLoop LessThan(i, num_files) {
        line_buf = Dereference(Add(line_buffers, Multiply(i, 8)))
        Deallocate(line_buf, 4096)
        
        fd = Dereference(Add(file_fds, Multiply(i, 8)))
        IfCondition GreaterEqual(fd, 0) ThenBlock: {
            SystemCall(3, fd)
        }
        
        is_stdin = Dereference(Add(is_stdin_map, Multiply(i, 8)))
        IfCondition EqualTo(is_stdin, 0) ThenBlock: {
            fb = Dereference(Add(file_buffers, Multiply(i, 8)))
            DestroyFileBuffer(fb)
        }
        
        i = Add(i, 1)
    }
    
    DestroyFileBuffer(stdin_fb)
    Deallocate(file_buffers, Multiply(num_files, 8))
    Deallocate(line_buffers, Multiply(num_files, 8))
    Deallocate(line_lengths, Multiply(num_files, 8))  // NEW: Free lengths array
    FlushOutput()
    Deallocate(is_stdin_map, Multiply(num_files, 8))
    Deallocate(file_fds, Multiply(num_files, 8))
    Deallocate(args_buffer, 4096)
    SystemCall(60, 0)
}

RunTask(Main)