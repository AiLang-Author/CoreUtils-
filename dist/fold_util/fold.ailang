// fold.ailang - Wrap lines to specified width
// Usage: fold [-w WIDTH] [file]
// Default width: 80

FixedPool.FoldConfig {
    "width": Initialize=80
}

FixedPool.FoldConstants {
    "BUFFER_SIZE": Initialize=65536
}

Function.WriteStdout {
    Input: buffer: Address
    Input: len: Integer
    Body: {
        SystemCall(1, 1, buffer, len)
    }
}

Function.ProcessFold {
    Input: fd: Integer
    Body: {
        buffer = Allocate(FoldConstants.BUFFER_SIZE)
        line_pos = 0
        
        WhileLoop 1 {
            bytes_read = SystemCall(0, fd, buffer, FoldConstants.BUFFER_SIZE)
            IfCondition LessEqual(bytes_read, 0) ThenBlock: {
                // EOF - output newline if we have partial line
                IfCondition GreaterThan(line_pos, 0) ThenBlock: {
                    WriteStdout("\n", 1)
                }
                BreakLoop
            }
            
            i = 0
            WhileLoop LessThan(i, bytes_read) {
                ch = GetByte(buffer, i)
                
                IfCondition EqualTo(ch, 10) ThenBlock: {
                    // Newline - reset counter
                    WriteStdout(Add(buffer, i), 1)
                    line_pos = 0
                } ElseBlock: {
                    // Regular character
                    WriteStdout(Add(buffer, i), 1)
                    line_pos = Add(line_pos, 1)
                    
                    // Check if we need to wrap
                    IfCondition GreaterEqual(line_pos, FoldConfig.width) ThenBlock: {
                        WriteStdout("\n", 1)
                        line_pos = 0
                    }
                }
                
                i = Add(i, 1)
            }
        }
        
        Deallocate(buffer, FoldConstants.BUFFER_SIZE)
    }
}

Function.StringToInt {
    Input: str: Address
    Output: Integer
    Body: {
        result = 0
        i = 0
        
        WhileLoop 1 {
            ch = GetByte(str, i)
            IfCondition Or(LessThan(ch, 48), GreaterThan(ch, 57)) ThenBlock: {
                ReturnValue(result)
            }
            digit = Subtract(ch, 48)
            result = Add(Multiply(result, 10), digit)
            i = Add(i, 1)
        }
    }
}

Function.GetArgs {
    Output: Address
    Body: {
        fd = SystemCall(257, -100, "/proc/self/cmdline", 0, 0)
        IfCondition LessThan(fd, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        buffer = Allocate(4096)
        bytes_read = SystemCall(0, fd, buffer, 4096)
        SystemCall(3, fd)
        
        IfCondition LessEqual(bytes_read, 0) ThenBlock: {
            Deallocate(buffer, 4096)
            ReturnValue(0)
        }
        
        ReturnValue(buffer)
    }
}

SubRoutine.Main {
    args_buffer = GetArgs()
    
    IfCondition EqualTo(args_buffer, 0) ThenBlock: {
        ProcessFold(0)
        SystemCall(60, 0)
    }
    
    // Skip program name
    pos = 0
    WhileLoop NotEqual(GetByte(args_buffer, pos), 0) {
        pos = Add(pos, 1)
    }
    pos = Add(pos, 1)
    
    filename = 0
    
    // Parse arguments
    WhileLoop LessThan(pos, 4096) {
        ch = GetByte(args_buffer, pos)
        IfCondition EqualTo(ch, 0) ThenBlock: {
            BreakLoop
        }
        
        // Check for -w flag
        first = GetByte(args_buffer, pos)
        IfCondition EqualTo(first, 45) ThenBlock: {
            second = GetByte(args_buffer, Add(pos, 1))
            IfCondition EqualTo(second, 119) ThenBlock: {
                // -w flag
                WhileLoop NotEqual(GetByte(args_buffer, pos), 0) {
                    pos = Add(pos, 1)
                }
                pos = Add(pos, 1)
                
                // Next arg is width
                FoldConfig.width = StringToInt(Add(args_buffer, pos))
                
                WhileLoop NotEqual(GetByte(args_buffer, pos), 0) {
                    pos = Add(pos, 1)
                }
                pos = Add(pos, 1)
                ContinueLoop
            }
        }
        
        // It's a filename
        file_start = pos
        file_len = 0
        
        WhileLoop And(LessThan(pos, 4096), NotEqual(GetByte(args_buffer, pos), 0)) {
            file_len = Add(file_len, 1)
            pos = Add(pos, 1)
        }
        
        filename = Allocate(Add(file_len, 1))
        i = 0
        WhileLoop LessThan(i, file_len) {
            ch = GetByte(args_buffer, Add(file_start, i))
            SetByte(filename, i, ch)
            i = Add(i, 1)
        }
        SetByte(filename, file_len, 0)
        
        pos = Add(pos, 1)
    }
    
    Deallocate(args_buffer, 4096)
    
    IfCondition EqualTo(filename, 0) ThenBlock: {
        ProcessFold(0)
    } ElseBlock: {
        fd = SystemCall(2, filename, 0, 0)
        
        IfCondition LessThan(fd, 0) ThenBlock: {
            SystemCall(60, 1)
        }
        
        ProcessFold(fd)
        SystemCall(3, fd)
        Deallocate(filename, 0)
    }
    
    SystemCall(60, 0)
}

RunTask(Main)