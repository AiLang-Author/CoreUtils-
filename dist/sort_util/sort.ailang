// sort.ailang - Sort lines of text files (OPTIMIZED)
// Usage: sort [-r] [-n] [-u] [-k field] [file...]
// Flags: -r (reverse), -n (numeric), -u (unique), -k (sort by field)

FixedPool.SortConfig {
    "reverse": Initialize=0
    "numeric": Initialize=0
    "unique": Initialize=0
    "field_num": Initialize=0
    "has_field": Initialize=0
}

FixedPool.SortConstants {
    "MAX_LINES": Initialize=100000
    "MAX_LINE_LENGTH": Initialize=4096
    "BUFFER_SIZE": Initialize=65536
}

Function.WriteStdout {
    Input: buffer: Address
    Input: len: Integer
    Body: {
        SystemCall(1, 1, buffer, len)
    }
}

Function.WriteStderr {
    Input: str: Address
    Body: {
        len = StringLength(str)
        SystemCall(1, 2, str, len)
    }
}

// Extract field from line for -k option
Function.ExtractField {
    Input: line: Address
    Input: field_num: Integer
    Output: Address
    Body: {
        // Field numbers start at 1
        current_field = 1
        pos = 0
        len = StringLength(line)
        
        // Skip whitespace to find first field
        WhileLoop LessThan(pos, len) {
            ch = GetByte(line, pos)
            IfCondition NotEqual(ch, 32) ThenBlock: {
                BreakLoop
            }
            pos = Add(pos, 1)
        }
        
        // Find the target field
        WhileLoop LessThan(current_field, field_num) {
            // Skip current field
            WhileLoop LessThan(pos, len) {
                ch = GetByte(line, pos)
                pos = Add(pos, 1)
                IfCondition EqualTo(ch, 32) ThenBlock: {
                    BreakLoop
                }
            }
            
            // Skip whitespace to next field
            WhileLoop LessThan(pos, len) {
                ch = GetByte(line, pos)
                IfCondition NotEqual(ch, 32) ThenBlock: {
                    BreakLoop
                }
                pos = Add(pos, 1)
            }
            
            current_field = Add(current_field, 1)
        }
        
        // Extract the field
        field_start = pos
        WhileLoop LessThan(pos, len) {
            ch = GetByte(line, pos)
            IfCondition EqualTo(ch, 32) ThenBlock: {
                BreakLoop
            }
            pos = Add(pos, 1)
        }
        
        field_len = Subtract(pos, field_start)
        field = Allocate(Add(field_len, 1))
        i = 0
        WhileLoop LessThan(i, field_len) {
            SetByte(field, i, GetByte(line, Add(field_start, i)))
            i = Add(i, 1)
        }
        SetByte(field, field_len, 0)
        
        ReturnValue(field)
    }
}

// Parse string as number
Function.ParseNumber {
    Input: str: Address
    Output: Integer
    Body: {
        result = 0
        pos = 0
        is_negative = 0
        
        // Check for negative sign
        ch = GetByte(str, 0)
        IfCondition EqualTo(ch, 45) ThenBlock: {
            is_negative = 1
            pos = 1
        }
        
        // Parse digits
        WhileLoop 1 {
            ch = GetByte(str, pos)
            IfCondition EqualTo(ch, 0) ThenBlock: {
                BreakLoop
            }
            
            // Check if digit (48='0' to 57='9')
            IfCondition And(GreaterEqual(ch, 48), LessEqual(ch, 57)) ThenBlock: {
                digit = Subtract(ch, 48)
                result = Add(Multiply(result, 10), digit)
            }
            
            pos = Add(pos, 1)
        }
        
        IfCondition EqualTo(is_negative, 1) ThenBlock: {
            result = Subtract(0, result)
        }
        
        ReturnValue(result)
    }
}

// Compare strings - returns <0 if str1<str2, 0 if equal, >0 if str1>str2
Function.CompareStrings {
    Input: str1: Address
    Input: str2: Address
    Output: Integer
    Body: {
        len1 = StringLength(str1)
        len2 = StringLength(str2)
        
        min_len = len1
        IfCondition LessThan(len2, len1) ThenBlock: {
            min_len = len2
        }
        
        // Byte-by-byte comparison
        i = 0
        WhileLoop LessThan(i, min_len) {
            ch1 = GetByte(str1, i)
            ch2 = GetByte(str2, i)
            
            IfCondition LessThan(ch1, ch2) ThenBlock: {
                ReturnValue(-1)
            }
            IfCondition GreaterThan(ch1, ch2) ThenBlock: {
                ReturnValue(1)
            }
            
            i = Add(i, 1)
        }
        
        // All characters match up to min_len - compare lengths
        IfCondition LessThan(len1, len2) ThenBlock: {
            ReturnValue(-1)
        }
        IfCondition GreaterThan(len1, len2) ThenBlock: {
            ReturnValue(1)
        }
        
        ReturnValue(0)
    }
}

// Compare two lines based on config
Function.CompareLines {
    Input: line1: Address
    Input: line2: Address
    Output: Integer
    Body: {
        str1 = line1
        str2 = line2
        need_cleanup = 0
        
        // Extract fields if -k specified
        IfCondition EqualTo(SortConfig.has_field, 1) ThenBlock: {
            str1 = ExtractField(line1, SortConfig.field_num)
            str2 = ExtractField(line2, SortConfig.field_num)
            need_cleanup = 1
        }
        
        cmp = 0
        
        // Numeric comparison
        IfCondition EqualTo(SortConfig.numeric, 1) ThenBlock: {
            num1 = ParseNumber(str1)
            num2 = ParseNumber(str2)
            
            IfCondition LessThan(num1, num2) ThenBlock: {
                cmp = -1
            } ElseBlock: {
                IfCondition GreaterThan(num1, num2) ThenBlock: {
                    cmp = 1
                } ElseBlock: {
                    cmp = 0
                }
            }
        } ElseBlock: {
            // String comparison
            cmp = CompareStrings(str1, str2)
        }
        
        // Clean up field extractions
        IfCondition EqualTo(need_cleanup, 1) ThenBlock: {
            Deallocate(str1, 0)
            Deallocate(str2, 0)
        }
        
        // Reverse if needed
        IfCondition EqualTo(SortConfig.reverse, 1) ThenBlock: {
            cmp = Subtract(0, cmp)
        }
        
        ReturnValue(cmp)
    }
}

// Optimized partition using median-of-three pivot selection
Function.Partition {
    Input: lines: Address
    Input: low: Integer
    Input: high: Integer
    Output: Integer
    Body: {
        // Median-of-three pivot selection for better performance
        mid = Divide(Add(low, high), 2)
        
        // Get three candidates
        line_low = Dereference(Add(lines, Multiply(low, 8)))
        line_mid = Dereference(Add(lines, Multiply(mid, 8)))
        line_high = Dereference(Add(lines, Multiply(high, 8)))
        
        // Sort low, mid, high to find median
        cmp_low_mid = CompareLines(line_low, line_mid)
        cmp_mid_high = CompareLines(line_mid, line_high)
        cmp_low_high = CompareLines(line_low, line_high)
        
        pivot_idx = mid
        
        IfCondition GreaterThan(cmp_low_mid, 0) ThenBlock: {
            IfCondition GreaterThan(cmp_mid_high, 0) ThenBlock: {
                pivot_idx = mid
            } ElseBlock: {
                IfCondition GreaterThan(cmp_low_high, 0) ThenBlock: {
                    pivot_idx = high
                } ElseBlock: {
                    pivot_idx = low
                }
            }
        } ElseBlock: {
            IfCondition LessThan(cmp_mid_high, 0) ThenBlock: {
                pivot_idx = mid
            } ElseBlock: {
                IfCondition LessThan(cmp_low_high, 0) ThenBlock: {
                    pivot_idx = high
                } ElseBlock: {
                    pivot_idx = low
                }
            }
        }
        
        // Move pivot to end
        pivot = Dereference(Add(lines, Multiply(pivot_idx, 8)))
        temp = Dereference(Add(lines, Multiply(high, 8)))
        StoreValue(Add(lines, Multiply(pivot_idx, 8)), temp)
        StoreValue(Add(lines, Multiply(high, 8)), pivot)
        
        // Standard partition
        i = Subtract(low, 1)
        j = low
        
        WhileLoop LessThan(j, high) {
            line_j = Dereference(Add(lines, Multiply(j, 8)))
            cmp = CompareLines(line_j, pivot)
            
            IfCondition LessEqual(cmp, 0) ThenBlock: {
                i = Add(i, 1)
                
                // Swap lines[i] and lines[j]
                temp = Dereference(Add(lines, Multiply(i, 8)))
                StoreValue(Add(lines, Multiply(i, 8)), line_j)
                StoreValue(Add(lines, Multiply(j, 8)), temp)
            }
            
            j = Add(j, 1)
        }
        
        // Place pivot in correct position
        i = Add(i, 1)
        temp = Dereference(Add(lines, Multiply(i, 8)))
        StoreValue(Add(lines, Multiply(i, 8)), pivot)
        StoreValue(Add(lines, Multiply(high, 8)), temp)
        
        ReturnValue(i)
    }
}

// Optimized quicksort with insertion sort for small subarrays
Function.QuickSort {
    Input: lines: Address
    Input: low: Integer
    Input: high: Integer
    Body: {
        // Use insertion sort for small subarrays (< 10 elements)
        IfCondition LessThan(Subtract(high, low), 10) ThenBlock: {
            InsertionSort(lines, low, high)
            ReturnValue(0)
        }
        
        IfCondition LessThan(low, high) ThenBlock: {
            pivot_idx = Partition(lines, low, high)
            
            // Sort left partition
            QuickSort(lines, low, Subtract(pivot_idx, 1))
            
            // Sort right partition
            QuickSort(lines, Add(pivot_idx, 1), high)
        }
    }
}

// Insertion sort for small subarrays
Function.InsertionSort {
    Input: lines: Address
    Input: low: Integer
    Input: high: Integer
    Body: {
        i = Add(low, 1)
        WhileLoop LessEqual(i, high) {
            key = Dereference(Add(lines, Multiply(i, 8)))
            j = Subtract(i, 1)
            
            WhileLoop And(GreaterEqual(j, low), GreaterThan(CompareLines(Dereference(Add(lines, Multiply(j, 8))), key), 0)) {
                StoreValue(Add(lines, Multiply(Add(j, 1), 8)), Dereference(Add(lines, Multiply(j, 8))))
                j = Subtract(j, 1)
            }
            
            StoreValue(Add(lines, Multiply(Add(j, 1), 8)), key)
            i = Add(i, 1)
        }
    }
}

// Remove duplicate lines if -u flag
Function.RemoveDuplicates {
    Input: lines: Address
    Input: line_count: Integer
    Output: Integer
    Body: {
        IfCondition LessEqual(line_count, 1) ThenBlock: {
            ReturnValue(line_count)
        }
        
        write_pos = 1
        i = 1
        
        WhileLoop LessThan(i, line_count) {
            current = Dereference(Add(lines, Multiply(i, 8)))
            prev = Dereference(Add(lines, Multiply(Subtract(write_pos, 1), 8)))
            
            cmp = CompareStrings(current, prev)
            
            IfCondition NotEqual(cmp, 0) ThenBlock: {
                // Different from previous - keep it
                StoreValue(Add(lines, Multiply(write_pos, 8)), current)
                write_pos = Add(write_pos, 1)
            } ElseBlock: {
                // Duplicate - free the line
                Deallocate(current, 0)
            }
            
            i = Add(i, 1)
        }
        
        ReturnValue(write_pos)
    }
}

// Read all lines with buffered I/O
Function.ReadAllLines {
    Input: fd: Integer
    Output: Address
    Body: {
        lines = Allocate(Multiply(SortConstants.MAX_LINES, 8))
        line_count = 0
        
        buffer = Allocate(SortConstants.BUFFER_SIZE)
        line_buffer = Allocate(SortConstants.MAX_LINE_LENGTH)
        line_pos = 0
        
        buffer_pos = 0
        buffer_len = 0
        
        WhileLoop 1 {
            // Read more data if buffer empty
            IfCondition GreaterEqual(buffer_pos, buffer_len) ThenBlock: {
                buffer_len = SystemCall(0, fd, buffer, SortConstants.BUFFER_SIZE)
                IfCondition LessEqual(buffer_len, 0) ThenBlock: {
                    // EOF - save last line if exists
                    IfCondition GreaterThan(line_pos, 0) ThenBlock: {
                        line = Allocate(Add(line_pos, 1))
                        MemCopy(line, line_buffer, line_pos)
                        SetByte(line, line_pos, 0)
                        StoreValue(Add(lines, Multiply(line_count, 8)), line)
                        line_count = Add(line_count, 1)
                    }
                    BreakLoop
                }
                buffer_pos = 0
            }
            
            // Process buffer using MemChr to find newlines
            remaining = Subtract(buffer_len, buffer_pos)
            search_ptr = Add(buffer, buffer_pos)
            newline_offset = MemChr(search_ptr, 10, remaining)
            
            IfCondition GreaterEqual(newline_offset, 0) ThenBlock: {
                // Found newline - copy line
                copy_len = newline_offset
                IfCondition GreaterThan(copy_len, 0) ThenBlock: {
                    MemCopy(Add(line_buffer, line_pos), search_ptr, copy_len)
                    line_pos = Add(line_pos, copy_len)
                }
                
                // Save line
                line = Allocate(Add(line_pos, 1))
                MemCopy(line, line_buffer, line_pos)
                SetByte(line, line_pos, 0)
                StoreValue(Add(lines, Multiply(line_count, 8)), line)
                line_count = Add(line_count, 1)
                line_pos = 0
                
                buffer_pos = Add(buffer_pos, Add(newline_offset, 1))
            } ElseBlock: {
                // No newline in remaining buffer - copy to line buffer
                MemCopy(Add(line_buffer, line_pos), search_ptr, remaining)
                line_pos = Add(line_pos, remaining)
                buffer_pos = buffer_len
            }
        }
        
        Deallocate(line_buffer, SortConstants.MAX_LINE_LENGTH)
        Deallocate(buffer, SortConstants.BUFFER_SIZE)
        
        // Return [line_count, lines_array]
        result = Allocate(16)
        StoreValue(result, line_count)
        StoreValue(Add(result, 8), lines)
        
        ReturnValue(result)
    }
}

Function.SortAndPrint {
    Input: fd: Integer
    Body: {
        // Read all lines
        result = ReadAllLines(fd)
        line_count = Dereference(result)
        lines = Dereference(Add(result, 8))
        
        // Sort lines
        IfCondition GreaterThan(line_count, 0) ThenBlock: {
            QuickSort(lines, 0, Subtract(line_count, 1))
            
            // Remove duplicates if -u flag
            IfCondition EqualTo(SortConfig.unique, 1) ThenBlock: {
                line_count = RemoveDuplicates(lines, line_count)
            }
        }
        
        // Print sorted lines
        i = 0
        WhileLoop LessThan(i, line_count) {
            line = Dereference(Add(lines, Multiply(i, 8)))
            len = StringLength(line)
            WriteStdout(line, len)
            WriteStdout("\n", 1)
            Deallocate(line, 0)
            i = Add(i, 1)
        }
        
        Deallocate(lines, Multiply(SortConstants.MAX_LINES, 8))
        Deallocate(result, 16)
    }
}

Function.GetArgs {
    Output: Address
    Body: {
        fd = SystemCall(257, -100, "/proc/self/cmdline", 0, 0)
        IfCondition LessThan(fd, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        buffer = Allocate(4096)
        bytes_read = SystemCall(0, fd, buffer, 4096)
        SystemCall(3, fd)
        
        IfCondition LessEqual(bytes_read, 0) ThenBlock: {
            Deallocate(buffer, 4096)
            ReturnValue(0)
        }
        
        ReturnValue(buffer)
    }
}

SubRoutine.Main {
    args_buffer = GetArgs()
    
    IfCondition EqualTo(args_buffer, 0) ThenBlock: {
        SortAndPrint(0)
        SystemCall(60, 0)
    }
    
    // Skip program name
    pos = 0
    WhileLoop NotEqual(GetByte(args_buffer, pos), 0) {
        pos = Add(pos, 1)
    }
    pos = Add(pos, 1)
    
    // Parse flags
    filename = 0
    
    WhileLoop LessThan(pos, 4096) {
        ch = GetByte(args_buffer, pos)
        IfCondition EqualTo(ch, 0) ThenBlock: {
            BreakLoop
        }
        
        first = GetByte(args_buffer, pos)
        
        IfCondition EqualTo(first, 45) ThenBlock: {
            // Flag
            flag_start = pos
            flag_len = 0
            
            WhileLoop And(LessThan(pos, 4096), NotEqual(GetByte(args_buffer, pos), 0)) {
                flag_len = Add(flag_len, 1)
                pos = Add(pos, 1)
            }
            
            flag = Allocate(Add(flag_len, 1))
            i = 0
            WhileLoop LessThan(i, flag_len) {
                SetByte(flag, i, GetByte(args_buffer, Add(flag_start, i)))
                i = Add(i, 1)
            }
            SetByte(flag, flag_len, 0)
            
            second = GetByte(flag, 1)
            
            // -r: reverse
            IfCondition EqualTo(second, 114) ThenBlock: {
                SortConfig.reverse = 1
            }
            
            // -n: numeric
            IfCondition EqualTo(second, 110) ThenBlock: {
                SortConfig.numeric = 1
            }
            
            // -u: unique
            IfCondition EqualTo(second, 117) ThenBlock: {
                SortConfig.unique = 1
            }
            
            // -k: field number
            IfCondition EqualTo(second, 107) ThenBlock: {
                SortConfig.has_field = 1
                pos = Add(pos, 1)
                
                // Read field number
                field_start = pos
                field_len = 0
                
                WhileLoop And(LessThan(pos, 4096), NotEqual(GetByte(args_buffer, pos), 0)) {
                    field_len = Add(field_len, 1)
                    pos = Add(pos, 1)
                }
                
                field_str = Allocate(Add(field_len, 1))
                i = 0
                WhileLoop LessThan(i, field_len) {
                    SetByte(field_str, i, GetByte(args_buffer, Add(field_start, i)))
                    i = Add(i, 1)
                }
                SetByte(field_str, field_len, 0)
                
                SortConfig.field_num = ParseNumber(field_str)
                Deallocate(field_str, Add(field_len, 1))
            }
            
            Deallocate(flag, Add(flag_len, 1))
        } ElseBlock: {
            // Filename
            file_start = pos
            file_len = 0
            
            WhileLoop And(LessThan(pos, 4096), NotEqual(GetByte(args_buffer, pos), 0)) {
                file_len = Add(file_len, 1)
                pos = Add(pos, 1)
            }
            
            filename = Allocate(Add(file_len, 1))
            i = 0
            WhileLoop LessThan(i, file_len) {
                SetByte(filename, i, GetByte(args_buffer, Add(file_start, i)))
                i = Add(i, 1)
            }
            SetByte(filename, file_len, 0)
        }
        
        pos = Add(pos, 1)
    }
    
    Deallocate(args_buffer, 4096)
    
    // Sort input
    IfCondition EqualTo(filename, 0) ThenBlock: {
        SortAndPrint(0)
    } ElseBlock: {
        fd = SystemCall(2, filename, 0, 0)
        
        IfCondition LessThan(fd, 0) ThenBlock: {
            WriteStderr("sort: cannot open file\n")
            SystemCall(60, 1)
        }
        
        SortAndPrint(fd)
        SystemCall(3, fd)
        Deallocate(filename, 0)
    }
    
    SystemCall(60, 0)
}

RunTask(Main)