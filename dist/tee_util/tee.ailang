// tee.ailang - Read stdin, write to stdout AND file(s)
// Usage: command | tee file1.txt [file2.txt ...]

FixedPool.TeeConstants {
    "BUFFER_SIZE": Initialize=65536
    "MAX_FILES": Initialize=100
}

Function.WriteStderr {
    Input: str: Address
    Body: {
        len = StringLength(str)
        SystemCall(1, 2, str, len)
    }
}

Function.SysOpen {
    Input: filename: Address
    Output: Integer
    Body: {
        // O_WRONLY | O_CREAT | O_TRUNC = 1 | 64 | 512 = 577
        // Mode 0644 = 420
        ReturnValue(SystemCall(2, filename, 577, 420))
    }
}

Function.SysWrite {
    Input: fd: Integer
    Input: buffer: Address
    Input: count: Integer
    Output: Integer
    Body: {
        ReturnValue(SystemCall(1, fd, buffer, count))
    }
}

Function.SysRead {
    Input: fd: Integer
    Input: buffer: Address
    Input: count: Integer
    Output: Integer
    Body: {
        ReturnValue(SystemCall(0, fd, buffer, count))
    }
}

Function.SysClose {
    Input: fd: Integer
    Body: {
        SystemCall(3, fd)
    }
}

Function.GetArgs {
    Output: Address
    Body: {
        fd = SystemCall(257, -100, "/proc/self/cmdline", 0, 0)
        IfCondition LessThan(fd, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        buffer = Allocate(4096)
        bytes_read = SystemCall(0, fd, buffer, 4096)
        SystemCall(3, fd)
        
        IfCondition LessEqual(bytes_read, 0) ThenBlock: {
            Deallocate(buffer, 4096)
            ReturnValue(0)
        }
        
        ReturnValue(buffer)
    }
}

SubRoutine.Main {
    args_buffer = GetArgs()
    
    IfCondition EqualTo(args_buffer, 0) ThenBlock: {
        // No args is fine - just echo stdin to stdout
        buffer = Allocate(TeeConstants.BUFFER_SIZE)
        
        WhileLoop 1 {
            bytes_read = SysRead(0, buffer, TeeConstants.BUFFER_SIZE)
            IfCondition LessEqual(bytes_read, 0) ThenBlock: {
                BreakLoop
            }
            SysWrite(1, buffer, bytes_read)
        }
        
        Deallocate(buffer, TeeConstants.BUFFER_SIZE)
        SystemCall(60, 0)
    }
    
    // Skip program name
    pos = 0
    WhileLoop NotEqual(GetByte(args_buffer, pos), 0) {
        pos = Add(pos, 1)
    }
    pos = Add(pos, 1)
    
    // Collect file arguments
    file_fds = Allocate(Multiply(TeeConstants.MAX_FILES, 8))
    file_count = 0
    
    WhileLoop LessThan(pos, 4096) {
        ch = GetByte(args_buffer, pos)
        IfCondition EqualTo(ch, 0) ThenBlock: {
            BreakLoop
        }
        
        // Get filename
        file_start = pos
        file_len = 0
        
        WhileLoop And(LessThan(pos, 4096), NotEqual(GetByte(args_buffer, pos), 0)) {
            file_len = Add(file_len, 1)
            pos = Add(pos, 1)
        }
        
        // Create filename string
        filename = Allocate(Add(file_len, 1))
        i = 0
        WhileLoop LessThan(i, file_len) {
            ch = GetByte(args_buffer, Add(file_start, i))
            SetByte(filename, i, ch)
            i = Add(i, 1)
        }
        SetByte(filename, file_len, 0)
        
        // Open file
        fd = SysOpen(filename)
        
        IfCondition LessThan(fd, 0) ThenBlock: {
            WriteStderr("tee: ")
            WriteStderr(filename)
            WriteStderr(": cannot open for writing\n")
            Deallocate(filename, Add(file_len, 1))
        } ElseBlock: {
            StoreValue(Add(file_fds, Multiply(file_count, 8)), fd)
            file_count = Add(file_count, 1)
            Deallocate(filename, Add(file_len, 1))
        }
        
        pos = Add(pos, 1)
    }
    
    Deallocate(args_buffer, 4096)
    
    // Main tee loop: read stdin, write to stdout AND all files
    buffer = Allocate(TeeConstants.BUFFER_SIZE)
    
    WhileLoop 1 {
        bytes_read = SysRead(0, buffer, TeeConstants.BUFFER_SIZE)
        
        IfCondition LessEqual(bytes_read, 0) ThenBlock: {
            BreakLoop
        }
        
        // Write to stdout
        SysWrite(1, buffer, bytes_read)
        
        // Write to all files
        i = 0
        WhileLoop LessThan(i, file_count) {
            fd = Dereference(Add(file_fds, Multiply(i, 8)))
            SysWrite(fd, buffer, bytes_read)
            i = Add(i, 1)
        }
    }
    
    // Close all files
    i = 0
    WhileLoop LessThan(i, file_count) {
        fd = Dereference(Add(file_fds, Multiply(i, 8)))
        SysClose(fd)
        i = Add(i, 1)
    }
    
    Deallocate(buffer, TeeConstants.BUFFER_SIZE)
    Deallocate(file_fds, Multiply(TeeConstants.MAX_FILES, 8))
    
    SystemCall(60, 0)
}

RunTask(Main)