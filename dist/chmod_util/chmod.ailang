// chmod.ailang - Change file mode bits
// Usage: chmod [OPTION]... MODE FILE...
// GNU coreutils compatible

FixedPool.ChmodConfig {
    "recursive": Initialize=0
    "verbose": Initialize=0
    "changes": Initialize=0
    "silent": Initialize=0
    "preserve_root": Initialize=1
}

FixedPool.ChmodStats {
    "changed": Initialize=0
    "failed": Initialize=0
    "skipped": Initialize=0
}

// ============================================================================
// UTILITY FUNCTIONS
// ============================================================================

Function.WriteStdout {
    Input: str: Address
    Body: {
        len = StringLength(str)
        SystemCall(1, 1, str, len)
    }
}

Function.WriteStderr {
    Input: str: Address
    Body: {
        len = StringLength(str)
        SystemCall(1, 2, str, len)
    }
}

Function.WriteVerbose {
    Input: str: Address
    Body: {
        IfCondition EqualTo(ChmodConfig.verbose, 1) ThenBlock: {
            WriteStdout(str)
        }
    }
}

Function.WriteChange {
    Input: str: Address
    Body: {
        IfCondition EqualTo(ChmodConfig.changes, 1) ThenBlock: {
            WriteStdout(str)
        }
    }
}

Function.WriteError {
    Input: str: Address
    Body: {
        IfCondition EqualTo(ChmodConfig.silent, 0) ThenBlock: {
            WriteStderr(str)
        }
    }
}

Function.IntToString {
    Input: num: Integer
    Output: Address
    Body: {
        IfCondition EqualTo(num, 0) ThenBlock: {
            str = Allocate(2)
            SetByte(str, 0, 48)
            SetByte(str, 1, 0)
            ReturnValue(str)
        }
        
        temp = num
        digits = 0
        WhileLoop GreaterThan(temp, 0) {
            temp = Divide(temp, 10)
            digits = Add(digits, 1)
        }
        
        str = Allocate(Add(digits, 1))
        
        i = Subtract(digits, 1)
        temp = num
        WhileLoop GreaterThan(temp, 0) {
            digit = Modulo(temp, 10)
            SetByte(str, i, Add(48, digit))
            temp = Divide(temp, 10)
            i = Subtract(i, 1)
        }
        
        SetByte(str, digits, 0)
        ReturnValue(str)
    }
}

// ============================================================================
// MODE PARSING
// ============================================================================

Function.ParseOctalMode {
    Input: mode_str: Address
    Output: Integer
    Body: {
        mode_val = 0
        idx = 0
        
        WhileLoop 1 {
            digit = GetByte(mode_str, idx)
            
            IfCondition EqualTo(digit, 0) ThenBlock: {
                BreakLoop
            }
            
            IfCondition Or(LessThan(digit, 48), GreaterThan(digit, 55)) ThenBlock: {
                ReturnValue(-1)
            }
            
            mode_val = Multiply(mode_val, 8)
            mode_val = Add(mode_val, Subtract(digit, 48))
            
            idx = Add(idx, 1)
        }
        
        ReturnValue(mode_val)
    }
}

Function.ParseSymbolicMode {
    Input: mode_str: Address
    Input: current_mode: Integer
    Output: Integer
    Body: {
        new_mode = current_mode
        who_mask = 0
        op = 0
        perms = 0
        idx = 0
        
        // Parse WHO (u, g, o, a)
        WhileLoop 1 {
            ch = GetByte(mode_str, idx)
            
            IfCondition EqualTo(ch, 117) ThenBlock: {  // 'u'
                who_mask = BitwiseOr(who_mask, 448)  // 0700
                idx = Add(idx, 1)
            } ElseBlock: {
                IfCondition EqualTo(ch, 103) ThenBlock: {  // 'g'
                    who_mask = BitwiseOr(who_mask, 56)  // 0070
                    idx = Add(idx, 1)
                } ElseBlock: {
                    IfCondition EqualTo(ch, 111) ThenBlock: {  // 'o'
                        who_mask = BitwiseOr(who_mask, 7)  // 0007
                        idx = Add(idx, 1)
                    } ElseBlock: {
                        IfCondition EqualTo(ch, 97) ThenBlock: {  // 'a'
                            who_mask = 511  // 0777
                            idx = Add(idx, 1)
                        } ElseBlock: {
                            BreakLoop
                        }
                    }
                }
            }
        }
        
        // If no WHO, default to 'a'
        IfCondition EqualTo(who_mask, 0) ThenBlock: {
            who_mask = 511
        }
        
        // Parse OPERATION (+, -, =)
        op = GetByte(mode_str, idx)
        IfCondition EqualTo(op, 43) ThenBlock: {  // '+'
            idx = Add(idx, 1)
        } ElseBlock: {
            IfCondition EqualTo(op, 45) ThenBlock: {  // '-'
                idx = Add(idx, 1)
            } ElseBlock: {
                IfCondition EqualTo(op, 61) ThenBlock: {  // '='
                    idx = Add(idx, 1)
                } ElseBlock: {
                    ReturnValue(-1)
                }
            }
        }
        
        // Parse PERMISSIONS (r, w, x)
        WhileLoop 1 {
            ch = GetByte(mode_str, idx)
            
            IfCondition EqualTo(ch, 0) ThenBlock: {
                BreakLoop
            }
            
            IfCondition EqualTo(ch, 114) ThenBlock: {  // 'r'
                perms = BitwiseOr(perms, 292)  // r for u,g,o: 0444
            } ElseBlock: {
                IfCondition EqualTo(ch, 119) ThenBlock: {  // 'w'
                    perms = BitwiseOr(perms, 146)  // w for u,g,o: 0222
                } ElseBlock: {
                    IfCondition EqualTo(ch, 120) ThenBlock: {  // 'x'
                        perms = BitwiseOr(perms, 73)  // x for u,g,o: 0111
                    } ElseBlock: {
                        BreakLoop
                    }
                }
            }
            
            idx = Add(idx, 1)
        }
        
        // Apply WHO mask to permissions
        perms = BitwiseAnd(perms, who_mask)
        
        // Apply operation
        IfCondition EqualTo(op, 43) ThenBlock: {  // '+'
            new_mode = BitwiseOr(current_mode, perms)
        } ElseBlock: {
            IfCondition EqualTo(op, 45) ThenBlock: {  // '-'
                new_mode = BitwiseAnd(current_mode, BitwiseNot(perms))
            } ElseBlock: {  // '='
                new_mode = BitwiseAnd(current_mode, BitwiseNot(who_mask))
                new_mode = BitwiseOr(new_mode, perms)
            }
        }
        
        ReturnValue(new_mode)
    }
}

// ============================================================================
// FILE OPERATIONS
// ============================================================================

Function.GetFileMode {
    Input: path: Address
    Output: Integer
    Body: {
        statbuf = Allocate(144)
        result = SystemCall(4, path, statbuf)
        
        IfCondition LessThan(result, 0) ThenBlock: {
            Deallocate(statbuf, 144)
            ReturnValue(-1)
        }
        
        mode = Dereference(Add(statbuf, 24))
        Deallocate(statbuf, 144)
        ReturnValue(mode)
    }
}

Function.FormatMode {
    Input: mode: Integer
    Output: Address
    Body: {
        // Extract permission bits only (0777)
        perms = BitwiseAnd(mode, 511)
        
        buffer = Allocate(4)
        
        // User permissions (bits 6-8): 0700 = 448
        user = BitwiseAnd(perms, 448)
        user = Divide(user, 64)
        SetByte(buffer, 0, Add(48, user))
        
        // Group permissions (bits 3-5): 0070 = 56
        group = BitwiseAnd(perms, 56)
        group = Divide(group, 8)
        SetByte(buffer, 1, Add(48, group))
        
        // Other permissions (bits 0-2): 0007 = 7
        other = BitwiseAnd(perms, 7)
        SetByte(buffer, 2, Add(48, other))
        
        SetByte(buffer, 3, 0)
        ReturnValue(buffer)
    }
}

Function.IsDirectory {
    Input: path: Address
    Output: Integer
    Body: {
        statbuf = Allocate(144)
        result = SystemCall(4, path, statbuf)
        
        IfCondition LessThan(result, 0) ThenBlock: {
            Deallocate(statbuf, 144)
            ReturnValue(0)
        }
        
        mode = Dereference(Add(statbuf, 24))
        Deallocate(statbuf, 144)
        
        file_type = BitwiseAnd(mode, 61440)  // S_IFMT
        ReturnValue(EqualTo(file_type, 16384))  // S_IFDIR
    }
}

Function.ChmodFile {
    Input: path: Address
    Input: new_mode: Integer
    Output: Integer
    Body: {
        // Get current mode
        old_mode = GetFileMode(path)
        
        IfCondition LessThan(old_mode, 0) ThenBlock: {
            WriteError("cannot access '")
            WriteError(path)
            WriteError("': No such file or directory\n")
            ChmodStats.failed = Add(ChmodStats.failed, 1)
            ReturnValue(1)
        }
        
        // Extract just permission bits from both old and new
        old_perms = BitwiseAnd(old_mode, 511)
        new_perms = BitwiseAnd(new_mode, 511)
        
        IfCondition EqualTo(old_perms, new_perms) ThenBlock: {
            WriteVerbose("mode of '")
            WriteVerbose(path)
            WriteVerbose("' retained as ")
            
            mode_str = FormatMode(old_mode)
            WriteVerbose(mode_str)
            WriteVerbose("\n")
            Deallocate(mode_str, 4)
            
            ChmodStats.skipped = Add(ChmodStats.skipped, 1)
            ReturnValue(0)
        }
        
        // IMPORTANT: Preserve file type bits, only change permissions
        // Keep upper bits from old_mode, use new permission bits
        file_type = BitwiseAnd(old_mode, 61440)  // S_IFMT mask  
        final_mode = BitwiseOr(file_type, new_perms)
        
        // Call chmod syscall with combined mode
        // chmod(path, mode) - syscall 90
        result = SystemCall(90, path, final_mode)
        
        IfCondition LessThan(result, 0) ThenBlock: {
            WriteError("changing permissions of '")
            WriteError(path)
            WriteError("': Operation not permitted\n")
            ChmodStats.failed = Add(ChmodStats.failed, 1)
            ReturnValue(1)
        }
        
        // Report change
        WriteChange("mode of '")
        WriteChange(path)
        WriteChange("' changed from ")
        
        old_str = FormatMode(old_mode)
        WriteChange(old_str)
        Deallocate(old_str, 4)
        
        WriteChange(" to ")
        
        new_str = FormatMode(final_mode)
        WriteChange(new_str)
        WriteChange("\n")
        Deallocate(new_str, 4)
        
        ChmodStats.changed = Add(ChmodStats.changed, 1)
        ReturnValue(0)
    }
}

Function.BuildPath {
    Input: dir: Address
    Input: name: Address
    Output: Address
    Body: {
        dir_len = StringLength(dir)
        name_len = StringLength(name)
        
        needs_slash = 1
        IfCondition GreaterThan(dir_len, 0) ThenBlock: {
            last_char = GetByte(dir, Subtract(dir_len, 1))
            IfCondition EqualTo(last_char, 47) ThenBlock: {
                needs_slash = 0
            }
        }
        
        total_len = Add(Add(dir_len, name_len), Add(needs_slash, 1))
        path = Allocate(total_len)
        
        // Copy directory
        i = 0
        WhileLoop LessThan(i, dir_len) {
            SetByte(path, i, GetByte(dir, i))
            i = Add(i, 1)
        }
        
        // Add slash if needed
        IfCondition EqualTo(needs_slash, 1) ThenBlock: {
            SetByte(path, i, 47)
            i = Add(i, 1)
        }
        
        // Copy filename
        j = 0
        WhileLoop LessThan(j, name_len) {
            SetByte(path, i, GetByte(name, j))
            i = Add(i, 1)
            j = Add(j, 1)
        }
        
        SetByte(path, i, 0)
        ReturnValue(path)
    }
}

// ============================================================================
// RECURSIVE CHMOD
// ============================================================================

Function.ChmodRecursive {
    Input: path: Address
    Input: mode: Integer
    Output: Integer
    Body: {
        // Check for preserve-root safety BEFORE opening
        IfCondition EqualTo(ChmodConfig.preserve_root, 1) ThenBlock: {
            first_char = GetByte(path, 0)
            second_char = GetByte(path, 1)
            
            // Check if path is exactly "/"
            IfCondition EqualTo(first_char, 47) ThenBlock: {  // '/'
                IfCondition EqualTo(second_char, 0) ThenBlock: {
                    WriteError("it is dangerous to operate recursively on '/'\n")
                    WriteError("use --no-preserve-root to override this failsafe\n")
                    ReturnValue(1)
                }
            }
        }
        
        // Open directory with O_RDONLY | O_DIRECTORY flags
        // O_RDONLY = 0, O_DIRECTORY = 0x10000 (65536)
        fd = SystemCall(2, path, 65536)
        
        IfCondition LessThan(fd, 0) ThenBlock: {
            WriteError("cannot open directory '")
            WriteError(path)
            WriteError("'\n")
            ReturnValue(1)
        }
        
        // Allocate buffer for directory entries
        buffer = Allocate(4096)
        
        // CRITICAL: getdents64 may not return all entries in one call!
        // We must loop until it returns 0 (end of directory)
        WhileLoop 1 {
            // Read a batch of directory entries
            // syscall 217 = getdents64(fd, buffer, count)
            nread = SystemCall(217, fd, buffer, 4096)
            
            // If nread <= 0, we've read all entries (or error occurred)
            IfCondition LessEqual(nread, 0) ThenBlock: {
                BreakLoop
            }
            
            // Process all entries in this batch
            offset = 0
            
            WhileLoop LessThan(offset, nread) {
                entry = Add(buffer, offset)
                
                // Parse linux_dirent64 structure:
                // struct linux_dirent64 {
                //     u64 d_ino;           // offset 0  (8 bytes)
                //     i64 d_off;           // offset 8  (8 bytes)
                //     u16 d_reclen;        // offset 16 (2 bytes) <- THIS ONE
                //     u8  d_type;          // offset 18 (1 byte)
                //     char d_name[];       // offset 19 (variable)
                // }
                
                // Read d_reclen (2 bytes, little-endian)
                reclen_lo = GetByte(entry, 16)
                reclen_hi = GetByte(entry, 17)
                reclen = Add(reclen_lo, Multiply(reclen_hi, 256))
                
                // Read d_type
                d_type = GetByte(entry, 18)
                
                // Get pointer to d_name (null-terminated string)
                name = Add(entry, 19)
                
                // Skip "." and ".." entries
                skip = 0
                first_char = GetByte(name, 0)
                
                IfCondition EqualTo(first_char, 46) ThenBlock: {  // '.' character
                    second_char = GetByte(name, 1)
                    
                    // Check for "." (single dot)
                    IfCondition EqualTo(second_char, 0) ThenBlock: {
                        skip = 1
                    } ElseBlock: {
                        // Check for ".." (double dot)
                        IfCondition EqualTo(second_char, 46) ThenBlock: {
                            third_char = GetByte(name, 2)
                            IfCondition EqualTo(third_char, 0) ThenBlock: {
                                skip = 1
                            }
                        }
                    }
                }
                
                // Process non-dot entries
                IfCondition EqualTo(skip, 0) ThenBlock: {
                    // Build full path: parent/child
                    full_path = BuildPath(path, name)
                    
                    // Check if this entry is a directory
                    is_dir = IsDirectory(full_path)
                    
                    // Recursively chmod directories, or just chmod files
                    IfCondition EqualTo(is_dir, 1) ThenBlock: {
                        ChmodRecursive(full_path, mode)
                    } ElseBlock: {
                        ChmodFile(full_path, mode)
                    }
                    
                    // Clean up the allocated path
                    Deallocate(full_path, 0)
                }
                
                // Move to next entry
                offset = Add(offset, reclen)
            }
            
            // IMPORTANT: Loop continues here!
            // This will call getdents64 again to get the next batch
            // Only breaks when getdents64 returns 0 (no more entries)
        }
        
        // Clean up
        SystemCall(3, fd)  // close(fd)
        Deallocate(buffer, 4096)
        
        // CRITICAL: chmod the directory itself AFTER processing contents
        // This ensures we can still read the directory while recursing
        result = ChmodFile(path, mode)
        
        ReturnValue(result)
    }
}

Function.ProcessPath {
    Input: path: Address
    Input: mode: Integer
    Output: Integer
    Body: {
        IfCondition EqualTo(ChmodConfig.recursive, 1) ThenBlock: {
            is_dir = IsDirectory(path)
            IfCondition EqualTo(is_dir, 1) ThenBlock: {
                ReturnValue(ChmodRecursive(path, mode))
            }
        }
        
        ReturnValue(ChmodFile(path, mode))
    }
}

// ============================================================================
// HELP
// ============================================================================

Function.ShowHelp {
    Body: {
        WriteStdout("Usage: chmod [OPTION]... MODE FILE...\n")
        WriteStdout("Change the mode of each FILE to MODE.\n\n")
        WriteStdout("Options:\n")
        WriteStdout("  -c, --changes          like verbose but report only when a change is made\n")
        WriteStdout("  -f, --silent, --quiet  suppress most error messages\n")
        WriteStdout("  -v, --verbose          output a diagnostic for every file processed\n")
        WriteStdout("  -R, --recursive        change files and directories recursively\n")
        WriteStdout("      --preserve-root    fail to operate recursively on '/'\n")
        WriteStdout("      --no-preserve-root do not treat '/' specially (the default)\n")
        WriteStdout("  -h, --help             display this help and exit\n\n")
        WriteStdout("MODE can be:\n")
        WriteStdout("  Octal: 0755, 644, etc.\n")
        WriteStdout("  Symbolic: u+x, go-w, a=r, etc.\n\n")
        WriteStdout("Examples:\n")
        WriteStdout("  chmod 755 file.txt      Set rwxr-xr-x permissions\n")
        WriteStdout("  chmod u+x script.sh     Add execute for user\n")
        WriteStdout("  chmod go-w file.txt     Remove write for group and others\n")
        WriteStdout("  chmod -R 755 directory  Recursively set permissions\n")
    }
}

// ============================================================================
// ARGUMENT PARSING
// ============================================================================

Function.GetArgs {
    Output: Address
    Body: {
        fd = SystemCall(257, -100, "/proc/self/cmdline", 0, 0)
        IfCondition LessThan(fd, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        buffer = Allocate(4096)
        bytes_read = SystemCall(0, fd, buffer, 4096)
        SystemCall(3, fd)
        
        IfCondition LessEqual(bytes_read, 0) ThenBlock: {
            Deallocate(buffer, 4096)
            ReturnValue(0)
        }
        
        ReturnValue(buffer)
    }
}

Function.StringCompare {
    Input: str1: Address
    Input: str2: Address
    Output: Integer
    Body: {
        i = 0
        WhileLoop 1 {
            ch1 = GetByte(str1, i)
            ch2 = GetByte(str2, i)
            
            IfCondition NotEqual(ch1, ch2) ThenBlock: {
                ReturnValue(0)
            }
            
            IfCondition EqualTo(ch1, 0) ThenBlock: {
                ReturnValue(1)
            }
            
            i = Add(i, 1)
        }
        ReturnValue(1)
    }
}

// ============================================================================
// MAIN
// ============================================================================

SubRoutine.Main {
    args_buffer = GetArgs()
    
    IfCondition EqualTo(args_buffer, 0) ThenBlock: {
        WriteStderr("chmod: failed to read arguments\n")
        SystemCall(60, 1)
    }
    
    // Skip program name
    pos = 0
    WhileLoop NotEqual(GetByte(args_buffer, pos), 0) {
        pos = Add(pos, 1)
    }
    pos = Add(pos, 1)
    
    mode_specified = 0
    mode_str = 0
    mode = 0
    
    max_files = 256
    files = ArrayCreate(max_files)
    file_count = 0
    
    // Parse arguments
    WhileLoop LessThan(pos, 4096) {
        ch = GetByte(args_buffer, pos)
        IfCondition EqualTo(ch, 0) ThenBlock: {
            BreakLoop
        }
        
        first = GetByte(args_buffer, pos)
        
        IfCondition EqualTo(first, 45) ThenBlock: {
            // Flag
            arg_start = pos
            arg_len = 0
            
            WhileLoop And(LessThan(pos, 4096), NotEqual(GetByte(args_buffer, pos), 0)) {
                arg_len = Add(arg_len, 1)
                pos = Add(pos, 1)
            }
            
            flag = Allocate(Add(arg_len, 1))
            i = 0
            WhileLoop LessThan(i, arg_len) {
                SetByte(flag, i, GetByte(args_buffer, Add(arg_start, i)))
                i = Add(i, 1)
            }
            SetByte(flag, arg_len, 0)
            
            IfCondition StringCompare(flag, "--help") ThenBlock: {
                ShowHelp()
                Deallocate(flag, Add(arg_len, 1))
                ArrayDestroy(files)
                Deallocate(args_buffer, 4096)
                SystemCall(60, 0)
            }
            
            IfCondition StringCompare(flag, "--verbose") ThenBlock: {
                ChmodConfig.verbose = 1
            }
            
            IfCondition StringCompare(flag, "--changes") ThenBlock: {
                ChmodConfig.changes = 1
            }
            
            IfCondition StringCompare(flag, "--silent") ThenBlock: {
                ChmodConfig.silent = 1
            }
            
            IfCondition StringCompare(flag, "--quiet") ThenBlock: {
                ChmodConfig.silent = 1
            }
            
            IfCondition StringCompare(flag, "--recursive") ThenBlock: {
                ChmodConfig.recursive = 1
            }
            
            IfCondition StringCompare(flag, "--preserve-root") ThenBlock: {
                ChmodConfig.preserve_root = 1
            }
            
            IfCondition StringCompare(flag, "--no-preserve-root") ThenBlock: {
                ChmodConfig.preserve_root = 0
            }
            
            // Parse short options
            i = 1
            WhileLoop LessThan(i, arg_len) {
                opt = GetByte(flag, i)
                
                IfCondition EqualTo(opt, 104) ThenBlock: {  // 'h'
                    ShowHelp()
                    Deallocate(flag, Add(arg_len, 1))
                    ArrayDestroy(files)
                    Deallocate(args_buffer, 4096)
                    SystemCall(60, 0)
                }
                
                IfCondition EqualTo(opt, 118) ThenBlock: { ChmodConfig.verbose = 1 }
                IfCondition EqualTo(opt, 99) ThenBlock: { ChmodConfig.changes = 1 }
                IfCondition EqualTo(opt, 102) ThenBlock: { ChmodConfig.silent = 1 }
                IfCondition EqualTo(opt, 82) ThenBlock: { ChmodConfig.recursive = 1 }
                
                i = Add(i, 1)
            }
            
            Deallocate(flag, Add(arg_len, 1))
        } ElseBlock: {
            // Not a flag - get pointer directly from args_buffer (already null-terminated)
            arg = Add(args_buffer, pos)
            
            IfCondition EqualTo(mode_specified, 0) ThenBlock: {
                // This is the MODE - save pointer
                mode_str = arg
                
                // Try to parse as octal
                mode = ParseOctalMode(arg)
                
                IfCondition LessThan(mode, 0) ThenBlock: {
                    // Flag for symbolic mode (parse per file)
                    mode = -2
                }
                
                mode_specified = 1
            } ElseBlock: {
                // This is a FILE - save pointer directly
                IfCondition LessThan(file_count, max_files) ThenBlock: {
                    ArraySet(files, file_count, arg)
                    file_count = Add(file_count, 1)
                }
            }
            
            // Skip to next argument
            WhileLoop And(LessThan(pos, 4096), NotEqual(GetByte(args_buffer, pos), 0)) {
                pos = Add(pos, 1)
            }
        }
        
        pos = Add(pos, 1)
    }
    
    // Check if we have MODE and files
    IfCondition EqualTo(mode_specified, 0) ThenBlock: {
        WriteStderr("chmod: missing operand\n")
        WriteStderr("Try 'chmod --help' for more information.\n")
        ArrayDestroy(files)
        Deallocate(args_buffer, 4096)
        SystemCall(60, 1)
    }
    
    IfCondition EqualTo(file_count, 0) ThenBlock: {
        WriteStderr("chmod: missing operand after '")
        WriteStderr(mode_str)
        WriteStderr("'\n")
        WriteStderr("Try 'chmod --help' for more information.\n")
        ArrayDestroy(files)
        Deallocate(args_buffer, 4096)
        SystemCall(60, 1)
    }
    
    // Process each file
    had_errors = 0
    
    i = 0
    WhileLoop LessThan(i, file_count) {
        path = ArrayGet(files, i)
        
        // For symbolic mode, parse relative to current file mode
        file_mode = mode
        IfCondition EqualTo(mode, -2) ThenBlock: {
            current = GetFileMode(path)
            IfCondition GreaterEqual(current, 0) ThenBlock: {
                file_mode = ParseSymbolicMode(mode_str, current)
                
                IfCondition LessThan(file_mode, 0) ThenBlock: {
                    WriteStderr("chmod: invalid mode: '")
                    WriteStderr(mode_str)
                    WriteStderr("'\n")
                    ArrayDestroy(files)
                    Deallocate(args_buffer, 4096)
                    SystemCall(60, 1)
                }
            } ElseBlock: {
                had_errors = 1
                i = Add(i, 1)
                ContinueLoop
            }
        }
        
        result = ProcessPath(path, file_mode)
        
        IfCondition NotEqual(result, 0) ThenBlock: {
            had_errors = 1
        }
        
        i = Add(i, 1)
    }
    
    ArrayDestroy(files)
    Deallocate(args_buffer, 4096)
    
    SystemCall(60, had_errors)
}

RunTask(Main)