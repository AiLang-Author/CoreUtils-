// chgrp.ailang - Change group ownership
// Usage: chgrp [OPTIONS] GROUP FILE...

FixedPool.ChgrpConstants {
    "AT_FDCWD": Initialize=-100
    "AT_SYMLINK_NOFOLLOW": Initialize=256
}

FixedPool.ChgrpConfig {
    "no_dereference": Initialize=0
    "verbose": Initialize=0
}

Function.WriteStdout {
    Input: buffer: Address
    Input: len: Integer
    Body: {
        SystemCall(1, 1, buffer, len)
    }
}

Function.WriteStderr {
    Input: buffer: Address
    Input: len: Integer
    Body: {
        SystemCall(1, 2, buffer, len)
    }
}

Function.GetStringLength {
    Input: str: Address
    Output: Integer
    Body: {
        len = 0
        WhileLoop NotEqual(GetByte(str, len), 0) {
            len = Add(len, 1)
        }
        ReturnValue(len)
    }
}

Function.ConvertNumberToString {
    Input: num: Integer
    Output: Address
    Body: {
        buffer = Allocate(32)
        
        IfCondition EqualTo(num, 0) ThenBlock: {
            SetByte(buffer, 0, 48)
            SetByte(buffer, 1, 0)
            ReturnValue(buffer)
        }
        
        is_neg = 0
        IfCondition LessThan(num, 0) ThenBlock: {
            is_neg = 1
            num = Subtract(0, num)
        }
        
        pos = 0
        temp = Allocate(32)
        
        WhileLoop GreaterThan(num, 0) {
            digit = Modulo(num, 10)
            SetByte(temp, pos, Add(48, digit))
            pos = Add(pos, 1)
            num = Divide(num, 10)
        }
        
        write_pos = 0
        IfCondition NotEqual(is_neg, 0) ThenBlock: {
            SetByte(buffer, 0, 45)
            write_pos = 1
        }
        
        i = Subtract(pos, 1)
        WhileLoop GreaterEqual(i, 0) {
            ch = GetByte(temp, i)
            SetByte(buffer, write_pos, ch)
            write_pos = Add(write_pos, 1)
            i = Subtract(i, 1)
        }
        
        SetByte(buffer, write_pos, 0)
        Deallocate(temp, 32)
        
        ReturnValue(buffer)
    }
}

// Parse numeric GID
Function.ParseNumeric {
    Input: str: Address
    Output: Integer
    Body: {
        result = 0
        i = 0
        
        WhileLoop LessThan(i, 20) {
            ch = GetByte(str, i)
            
            IfCondition EqualTo(ch, 0) ThenBlock: {
                BreakLoop
            }
            
            // Check if digit
            IfCondition Or(LessThan(ch, 48), GreaterThan(ch, 57)) ThenBlock: {
                ReturnValue(-1)
            }
            
            digit = Subtract(ch, 48)
            result = Add(Multiply(result, 10), digit)
            i = Add(i, 1)
        }
        
        ReturnValue(result)
    }
}

// Compare strings up to n characters
Function.StringCompareN {
    Input: s1: Address
    Input: s2: Address
    Input: n: Integer
    Output: Integer
    Body: {
        i = 0
        
        WhileLoop LessThan(i, n) {
            c1 = GetByte(s1, i)
            c2 = GetByte(s2, i)
            
            IfCondition NotEqual(c1, c2) ThenBlock: {
                ReturnValue(1)
            }
            
            IfCondition EqualTo(c1, 0) ThenBlock: {
                ReturnValue(0)
            }
            
            i = Add(i, 1)
        }
        
        // Check if s2 ends here
        c2 = GetByte(s2, n)
        IfCondition EqualTo(c2, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        ReturnValue(1)
    }
}

// Parse a single line from /etc/group
Function.ParseGroupLine {
    Input: line: Address
    Input: length: Integer
    Input: target_name: Address
    Output: Integer
    Body: {
        // Format: groupname:x:gid:users
        
        name_end = 0
        i = 0
        
        // Find first colon (end of group name)
        WhileLoop LessThan(i, length) {
            IfCondition EqualTo(GetByte(line, i), 58) ThenBlock: {
                name_end = i
                BreakLoop
            }
            i = Add(i, 1)
        }
        
        IfCondition EqualTo(name_end, 0) ThenBlock: {
            ReturnValue(-1)
        }
        
        // Check if name matches
        matches = StringCompareN(line, target_name, name_end)
        IfCondition NotEqual(matches, 0) ThenBlock: {
            ReturnValue(-1)
        }
        
        // Skip to second colon (before GID)
        i = Add(name_end, 1)
        WhileLoop LessThan(i, length) {
            IfCondition EqualTo(GetByte(line, i), 58) ThenBlock: {
                i = Add(i, 1)
                BreakLoop
            }
            i = Add(i, 1)
        }
        
        // Parse GID
        gid = 0
        WhileLoop LessThan(i, length) {
            ch = GetByte(line, i)
            
            // Stop at colon or newline
            IfCondition Or(EqualTo(ch, 58), EqualTo(ch, 10)) ThenBlock: {
                BreakLoop
            }
            
            // Parse digit
            IfCondition And(GreaterEqual(ch, 48), LessEqual(ch, 57)) ThenBlock: {
                digit = Subtract(ch, 48)
                gid = Add(Multiply(gid, 10), digit)
            }
            
            i = Add(i, 1)
        }
        
        ReturnValue(gid)
    }
}

// Parse /etc/group file
Function.ParseGroupFile {
    Input: buffer: Address
    Input: size: Integer
    Input: target_name: Address
    Output: Integer
    Body: {
        line_start = 0
        i = 0
        
        WhileLoop LessThan(i, size) {
            ch = GetByte(buffer, i)
            
            // New line
            IfCondition EqualTo(ch, 10) ThenBlock: {
                // Parse this line
                line_len = Subtract(i, line_start)
                IfCondition GreaterThan(line_len, 0) ThenBlock: {
                    gid = ParseGroupLine(Add(buffer, line_start), line_len, target_name)
                    
                    IfCondition GreaterEqual(gid, 0) ThenBlock: {
                        ReturnValue(gid)
                    }
                }
                
                line_start = Add(i, 1)
            }
            
            i = Add(i, 1)
        }
        
        ReturnValue(-1)
    }
}

// Lookup group name in /etc/group
Function.LookupGroupName {
    Input: name: Address
    Output: Integer
    Body: {
        // Open /etc/group
        fd = SystemCall(2, "/etc/group", 0)
        
        IfCondition LessThan(fd, 0) ThenBlock: {
            WriteStderr("chgrp: cannot open /etc/group\n", 30)
            ReturnValue(-1)
        }
        
        // Read file
        buffer = Allocate(8192)
        bytes_read = SystemCall(0, fd, buffer, 8192)
        SystemCall(3, fd)
        
        IfCondition LessEqual(bytes_read, 0) ThenBlock: {
            Deallocate(buffer, 8192)
            ReturnValue(-1)
        }
        
        // Parse /etc/group format: groupname:x:gid:users
        gid = ParseGroupFile(buffer, bytes_read, name)
        
        Deallocate(buffer, 8192)
        ReturnValue(gid)
    }
}

// Parse group name or GID
Function.ParseGroup {
    Input: group_str: Address
    Output: Integer
    Body: {
        // Try to parse as numeric GID first
        gid = ParseNumeric(group_str)
        
        IfCondition GreaterEqual(gid, 0) ThenBlock: {
            ReturnValue(gid)
        }
        
        // Otherwise, look up group name in /etc/group
        gid = LookupGroupName(group_str)
        ReturnValue(gid)
    }
}

// Change group ownership of a file
Function.ChangeGroup {
    Input: path: Address
    Input: gid: Integer
    Output: Integer
    Body: {
        flags = 0
        
        IfCondition NotEqual(ChgrpConfig.no_dereference, 0) ThenBlock: {
            flags = ChgrpConstants.AT_SYMLINK_NOFOLLOW
        }
        
        // fchownat syscall: 260 on x86_64
        // int fchownat(int dirfd, const char *pathname, uid_t owner, gid_t group, int flags);
        // Use -1 for owner to leave it unchanged
        result = SystemCall(260, ChgrpConstants.AT_FDCWD, path, -1, gid, flags)
        
        IfCondition LessThan(result, 0) ThenBlock: {
            WriteStderr("chgrp: cannot change group of '", 32)
            WriteStderr(path, GetStringLength(path))
            WriteStderr("': Operation not permitted\n", 27)
            ReturnValue(1)
        }
        
        // Verbose output
        IfCondition NotEqual(ChgrpConfig.verbose, 0) ThenBlock: {
            WriteStdout("changed group of '", 18)
            WriteStdout(path, GetStringLength(path))
            WriteStdout("' to ", 5)
            gid_str = ConvertNumberToString(gid)
            WriteStdout(gid_str, GetStringLength(gid_str))
            WriteStdout("\n", 1)
            Deallocate(gid_str, 32)
        }
        
        ReturnValue(0)
    }
}

Function.GetArgs {
    Output: Address
    Body: {
        fd = SystemCall(257, -100, "/proc/self/cmdline", 0, 0)
        IfCondition LessThan(fd, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        buffer = Allocate(4096)
        bytes_read = SystemCall(0, fd, buffer, 4096)
        SystemCall(3, fd)
        
        IfCondition LessEqual(bytes_read, 0) ThenBlock: {
            Deallocate(buffer, 4096)
            ReturnValue(0)
        }
        
        ReturnValue(buffer)
    }
}

SubRoutine.Main {
    args_buffer = GetArgs()
    
    IfCondition EqualTo(args_buffer, 0) ThenBlock: {
        WriteStderr("chgrp: cannot read arguments\n", 29)
        SystemCall(60, 1)
    }
    
    // Skip program name
    pos = 0
    WhileLoop NotEqual(GetByte(args_buffer, pos), 0) {
        pos = Add(pos, 1)
    }
    pos = Add(pos, 1)
    
    // Parse options and get group
    group_spec = 0
    group_len = 0
    
    // Check for options
    WhileLoop LessThan(pos, 4096) {
        ch = GetByte(args_buffer, pos)
        IfCondition EqualTo(ch, 0) ThenBlock: {
            BreakLoop
        }
        
        // Check if this is an option
        IfCondition EqualTo(ch, 45) ThenBlock: {
            next_ch = GetByte(args_buffer, Add(pos, 1))
            
            // -h (no dereference)
            IfCondition EqualTo(next_ch, 104) ThenBlock: {
                ChgrpConfig.no_dereference = 1
            }
            
            // -v (verbose)
            IfCondition EqualTo(next_ch, 118) ThenBlock: {
                ChgrpConfig.verbose = 1
            }
            
            // Skip to next argument
            WhileLoop NotEqual(GetByte(args_buffer, pos), 0) {
                pos = Add(pos, 1)
            }
            pos = Add(pos, 1)
        } ElseBlock: {
            // Found group argument
            group_spec = Add(args_buffer, pos)
            
            // Count length
            WhileLoop NotEqual(GetByte(args_buffer, pos), 0) {
                group_len = Add(group_len, 1)
                pos = Add(pos, 1)
            }
            pos = Add(pos, 1)
            BreakLoop
        }
    }
    
    IfCondition EqualTo(group_len, 0) ThenBlock: {
        WriteStderr("chgrp: missing operand\n", 23)
        WriteStderr("Try 'chgrp --help' for more information.\n", 42)
        Deallocate(args_buffer, 4096)
        SystemCall(60, 1)
    }
    
    // Parse group
    gid = ParseGroup(group_spec)
    
    IfCondition LessThan(gid, 0) ThenBlock: {
        WriteStderr("chgrp: invalid group: '", 23)
        WriteStderr(group_spec, group_len)
        WriteStderr("'\n", 2)
        Deallocate(args_buffer, 4096)
        SystemCall(60, 1)
    }
    
    // Check if we have files to process
    file_count = 0
    temp_pos = pos
    WhileLoop LessThan(temp_pos, 4096) {
        ch = GetByte(args_buffer, temp_pos)
        IfCondition EqualTo(ch, 0) ThenBlock: {
            BreakLoop
        }
        file_count = Add(file_count, 1)
        temp_pos = Add(temp_pos, 1)
    }
    
    IfCondition EqualTo(file_count, 0) ThenBlock: {
        WriteStderr("chgrp: missing operand after '", 31)
        WriteStderr(group_spec, group_len)
        WriteStderr("'\n", 2)
        Deallocate(args_buffer, 4096)
        SystemCall(60, 1)
    }
    
    // Process each file
    errors = 0
    
    WhileLoop LessThan(pos, 4096) {
        file_start = pos
        file_len = 0
        
        WhileLoop And(LessThan(pos, 4096), NotEqual(GetByte(args_buffer, pos), 0)) {
            file_len = Add(file_len, 1)
            pos = Add(pos, 1)
        }
        
        IfCondition EqualTo(file_len, 0) ThenBlock: {
            BreakLoop
        }
        
        file_path = Add(args_buffer, file_start)
        
        result = ChangeGroup(file_path, gid)
        IfCondition NotEqual(result, 0) ThenBlock: {
            errors = Add(errors, 1)
        }
        
        pos = Add(pos, 1)
        
        // Check for double null (end of args)
        IfCondition EqualTo(GetByte(args_buffer, pos), 0) ThenBlock: {
            BreakLoop
        }
    }
    
    Deallocate(args_buffer, 4096)
    
    IfCondition GreaterThan(errors, 0) ThenBlock: {
        SystemCall(60, 1)
    }
    
    SystemCall(60, 0)
}

RunTask(Main)