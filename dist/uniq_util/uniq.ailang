// uniq.ailang - FULLY OPTIMIZED with buffered I/O
// Usage: uniq [file]

FixedPool.UniqConstants {
    "BUFFER_SIZE": Initialize=262144     
    "OUTPUT_BUFFER_SIZE": Initialize=524288 
    "MAX_LINE_LENGTH": Initialize=4096
}

FixedPool.OutputBuffer {
    "buffer": Initialize=0
    "position": Initialize=0
}

Function.InitOutputBuffer {
    Body: {
        OutputBuffer.buffer = Allocate(UniqConstants.OUTPUT_BUFFER_SIZE)
        OutputBuffer.position = 0
    }
}

Function.FlushOutputBuffer {
    Body: {
        IfCondition GreaterThan(OutputBuffer.position, 0) ThenBlock: {
            SystemCall(1, 1, OutputBuffer.buffer, OutputBuffer.position)
            OutputBuffer.position = 0
        }
    }
}

Function.BuffWrite {
    Input: data: Address
    Input: len: Integer
    Body: {
        // If data won't fit, flush first
        space = Subtract(UniqConstants.OUTPUT_BUFFER_SIZE, OutputBuffer.position)
        
        IfCondition LessThan(space, len) ThenBlock: {
            FlushOutputBuffer()
        }
        
        // Use MemCopy to add to buffer
        MemCopy(Add(OutputBuffer.buffer, OutputBuffer.position), data, len)
        OutputBuffer.position = Add(OutputBuffer.position, len)
    }
}

Function.BuffWriteByte {
    Input: byte: Integer
    Body: {
        IfCondition GreaterEqual(OutputBuffer.position, UniqConstants.OUTPUT_BUFFER_SIZE) ThenBlock: {
            FlushOutputBuffer()
        }
        
        SetByte(OutputBuffer.buffer, OutputBuffer.position, byte)
        OutputBuffer.position = Add(OutputBuffer.position, 1)
    }
}

Function.WriteStderr {
    Input: str: Address
    Body: {
        len = StringLength(str)
        SystemCall(1, 2, str, len)
    }
}

Function.SysOpen {
    Input: filename: Address
    Output: Integer
    Body: {
        ReturnValue(SystemCall(2, filename, 0, 0))
    }
}

Function.SysRead {
    Input: fd: Integer
    Input: buffer: Address
    Input: count: Integer
    Output: Integer
    Body: {
        ReturnValue(SystemCall(0, fd, buffer, count))
    }
}

Function.SysClose {
    Input: fd: Integer
    Body: {
        SystemCall(3, fd)
    }
}

Function.ProcessUniq {
    Input: fd: Integer
    Body: {
        InitOutputBuffer()
        
        buffer = Allocate(UniqConstants.BUFFER_SIZE)
        prev_line = Allocate(UniqConstants.MAX_LINE_LENGTH)
        curr_line = Allocate(UniqConstants.MAX_LINE_LENGTH)
        
        prev_len = 0
        curr_len = 0
        
        buffer_pos = 0
        buffer_len = 0
        
        first_line = 1
        
        WhileLoop 1 {
            // Read more data if needed
            IfCondition GreaterEqual(buffer_pos, buffer_len) ThenBlock: {
                buffer_len = SysRead(fd, buffer, UniqConstants.BUFFER_SIZE)
                IfCondition LessEqual(buffer_len, 0) ThenBlock: {
                    // EOF - output last line if exists
                    IfCondition GreaterThan(curr_len, 0) ThenBlock: {
                        BuffWrite(curr_line, curr_len)
                        BuffWriteByte(10)
                    }
                    FlushOutputBuffer()
                    BreakLoop
                }
                buffer_pos = 0
            }
            
            // Find next newline using MemChr (SSE2)
            remaining = Subtract(buffer_len, buffer_pos)
            search_ptr = Add(buffer, buffer_pos)
            newline_offset = MemChr(search_ptr, 10, remaining)
            
            IfCondition EqualTo(newline_offset, -1) ThenBlock: {
                // No newline found - copy remaining to curr_line buffer
                bytes_to_copy = remaining
                space_left = Subtract(UniqConstants.MAX_LINE_LENGTH, curr_len)
                
                IfCondition GreaterThan(bytes_to_copy, space_left) ThenBlock: {
                    bytes_to_copy = space_left
                }
                
                IfCondition GreaterThan(bytes_to_copy, 0) ThenBlock: {
                    MemCopy(Add(curr_line, curr_len), search_ptr, bytes_to_copy)
                    curr_len = Add(curr_len, bytes_to_copy)
                }
                
                buffer_pos = buffer_len
                ContinueLoop
            }
            
            // Found newline! Copy line segment
            bytes_to_copy = newline_offset
            space_left = Subtract(UniqConstants.MAX_LINE_LENGTH, curr_len)
            
            IfCondition GreaterThan(bytes_to_copy, space_left) ThenBlock: {
                bytes_to_copy = space_left
            }
            
            IfCondition GreaterThan(bytes_to_copy, 0) ThenBlock: {
                MemCopy(Add(curr_line, curr_len), search_ptr, bytes_to_copy)
                curr_len = Add(curr_len, bytes_to_copy)
            }
            
            // Compare with previous line using MemCompare (SSE2)
            IfCondition EqualTo(first_line, 1) ThenBlock: {
                // First line - buffer it
                BuffWrite(curr_line, curr_len)
                BuffWriteByte(10)
                
                // Copy to prev using MemCopy
                MemCopy(prev_line, curr_line, curr_len)
                prev_len = curr_len
                first_line = 0
            } ElseBlock: {
                // Use MemCompare for fast comparison!
                is_different = 1
                
                IfCondition EqualTo(curr_len, prev_len) ThenBlock: {
                    cmp_result = MemCompare(curr_line, prev_line, curr_len)
                    IfCondition EqualTo(cmp_result, 0) ThenBlock: {
                        is_different = 0
                    }
                }
                
                IfCondition EqualTo(is_different, 1) ThenBlock: {
                    // Different - buffer it
                    BuffWrite(curr_line, curr_len)
                    BuffWriteByte(10)
                    
                    // Copy to prev using MemCopy
                    MemCopy(prev_line, curr_line, curr_len)
                    prev_len = curr_len
                }
                // If same, skip (duplicate)
            }
            
            // Move to next line
            buffer_pos = Add(buffer_pos, Add(newline_offset, 1))
            curr_len = 0
        }
        
        Deallocate(curr_line, UniqConstants.MAX_LINE_LENGTH)
        Deallocate(prev_line, UniqConstants.MAX_LINE_LENGTH)
        Deallocate(buffer, UniqConstants.BUFFER_SIZE)
        Deallocate(OutputBuffer.buffer, UniqConstants.OUTPUT_BUFFER_SIZE)
    }
}

Function.GetArgs {
    Output: Address
    Body: {
        fd = SystemCall(257, -100, "/proc/self/cmdline", 0, 0)
        IfCondition LessThan(fd, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        buffer = Allocate(4096)
        bytes_read = SystemCall(0, fd, buffer, 4096)
        SystemCall(3, fd)
        
        IfCondition LessEqual(bytes_read, 0) ThenBlock: {
            Deallocate(buffer, 4096)
            ReturnValue(0)
        }
        
        ReturnValue(buffer)
    }
}

SubRoutine.Main {
    args_buffer = GetArgs()
    
    IfCondition EqualTo(args_buffer, 0) ThenBlock: {
        ProcessUniq(0)
        SystemCall(60, 0)
    }
    
    // Skip program name
    pos = 0
    WhileLoop NotEqual(GetByte(args_buffer, pos), 0) {
        pos = Add(pos, 1)
    }
    pos = Add(pos, 1)
    
    // Get filename if provided
    filename = 0
    
    ch = GetByte(args_buffer, pos)
    IfCondition NotEqual(ch, 0) ThenBlock: {
        file_start = pos
        file_len = 0
        
        WhileLoop And(LessThan(pos, 4096), NotEqual(GetByte(args_buffer, pos), 0)) {
            file_len = Add(file_len, 1)
            pos = Add(pos, 1)
        }
        
        filename = Allocate(Add(file_len, 1))
        i = 0
        WhileLoop LessThan(i, file_len) {
            ch = GetByte(args_buffer, Add(file_start, i))
            SetByte(filename, i, ch)
            i = Add(i, 1)
        }
        SetByte(filename, file_len, 0)
    }
    
    Deallocate(args_buffer, 4096)
    
    IfCondition EqualTo(filename, 0) ThenBlock: {
        ProcessUniq(0)
    } ElseBlock: {
        fd = SysOpen(filename)
        
        IfCondition LessThan(fd, 0) ThenBlock: {
            WriteStderr("uniq: ")
            WriteStderr(filename)
            WriteStderr(": cannot open\n")
            Deallocate(filename, 0)
            SystemCall(60, 1)
        }
        
        ProcessUniq(fd)
        SysClose(fd)
        Deallocate(filename, 0)
    }
    
    SystemCall(60, 0)
}

RunTask(Main)