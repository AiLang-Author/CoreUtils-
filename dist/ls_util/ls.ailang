// ls.ailang - Directory Listing OPTIMIZED v2
// Optimizations: cached stat results, early-exit bubble sort
// NO LIBRARIES - Pure syscalls

FixedPool.LsConstants {
    "BUFFER_SIZE": Initialize=32768
    "STAT_SIZE": Initialize=144
    "PATH_MAX": Initialize=4096
    "MAX_ENTRIES": Initialize=2000
    "ENTRY_SIZE": Initialize=32
    "AT_FDCWD": Initialize=-100
    "O_RDONLY": Initialize=0
    "O_DIRECTORY": Initialize=65536
    "DT_UNKNOWN": Initialize=0
    "DT_DIR": Initialize=4
    "DT_REG": Initialize=8
    "DT_LNK": Initialize=10
    "S_IFMT": Initialize=61440
    "S_IFDIR": Initialize=16384
    "S_IFREG": Initialize=32768
    "S_IFLNK": Initialize=40960
}

FixedPool.LsConfig {
    "show_all": Initialize=0
    "long_format": Initialize=0
    "human_readable": Initialize=0
    "sort_by_time": Initialize=0
    "reverse_sort": Initialize=0
    "total_blocks": Initialize=0
    "print_dir_name": Initialize=0
    "recursive": Initialize=0
}

FixedPool.OutputBuf {
    "buf": Initialize=0
    "pos": Initialize=0
    "cap": Initialize=4096
}

FixedPool.MonthNames {
    "m0": Initialize=0
    "m1": Initialize=0
    "m2": Initialize=0
    "m3": Initialize=0
    "m4": Initialize=0
    "m5": Initialize=0
    "m6": Initialize=0
    "m7": Initialize=0
    "m8": Initialize=0
    "m9": Initialize=0
    "m10": Initialize=0
    "m11": Initialize=0
}

SubRoutine.InitMonthNames {
    MonthNames.m0 = "Jan"
    MonthNames.m1 = "Feb"
    MonthNames.m2 = "Mar"
    MonthNames.m3 = "Apr"
    MonthNames.m4 = "May"
    MonthNames.m5 = "Jun"
    MonthNames.m6 = "Jul"
    MonthNames.m7 = "Aug"
    MonthNames.m8 = "Sep"
    MonthNames.m9 = "Oct"
    MonthNames.m10 = "Nov"
    MonthNames.m11 = "Dec"
}

Function.WriteStdout {
    Input: str: Address
    Body: {
        len = StringLength(str)
        IfCondition GreaterThan(len, 0) ThenBlock: {
            SystemCall(1, 1, str, len)
        }
    }
}

SubRoutine.InitBuffer {
    OutputBuf.buf = Allocate(OutputBuf.cap)
    OutputBuf.pos = 0
}

SubRoutine.FlushBuffer {
    IfCondition GreaterThan(OutputBuf.pos, 0) ThenBlock: {
        SystemCall(1, 1, OutputBuf.buf, OutputBuf.pos)
        OutputBuf.pos = 0
    }
}

Function.WriteBuffered {
    Input: str: Address
    Body: {
        len = StringLength(str)
        remaining = Subtract(OutputBuf.cap, OutputBuf.pos)
        IfCondition GreaterThan(len, remaining) ThenBlock: {
            RunTask(FlushBuffer)
        }
        i = 0
        WhileLoop LessThan(i, len) {
            ch = GetByte(str, i)
            SetByte(OutputBuf.buf, Add(OutputBuf.pos, i), ch)
            i = Add(i, 1)
        }
        OutputBuf.pos = Add(OutputBuf.pos, len)
    }
}

Function.WriteStderr {
    Input: str: Address
    Body: {
        len = StringLength(str)
        IfCondition GreaterThan(len, 0) ThenBlock: {
            SystemCall(1, 2, str, len)
        }
    }
}

Function.WriteChar {
    Input: ch: Integer
    Body: {
        temp = Allocate(2)
        SetByte(temp, 0, ch)
        SetByte(temp, 1, 0)
        WriteBuffered(temp)
        Deallocate(temp, 2)
    }
}

Function.GetUInt16 {
    Input: buffer: Address
    Input: offset: Integer
    Output: Integer
    Body: {
        ptr = Add(buffer, offset)
        byte0 = GetByte(ptr, 0)
        byte1 = GetByte(ptr, 1)
        value = Add(byte0, Multiply(byte1, 256))
        ReturnValue(value)
    }
}

Function.GetUInt32 {
    Input: buffer: Address
    Input: offset: Integer
    Output: Integer
    Body: {
        ptr = Add(buffer, offset)
        byte0 = GetByte(ptr, 0)
        byte1 = GetByte(ptr, 1)
        byte2 = GetByte(ptr, 2)
        byte3 = GetByte(ptr, 3)
        
        value = byte0
        value = Add(value, Multiply(byte1, 256))
        value = Add(value, Multiply(byte2, 65536))
        value = Add(value, Multiply(byte3, 16777216))
        ReturnValue(value)
    }
}

Function.GetUInt64 {
    Input: buffer: Address
    Input: offset: Integer
    Output: Integer
    Body: {
        ReturnValue(GetUInt32(buffer, offset))
    }
}

Function.IsDotEntry {
    Input: name: Address
    Output: Integer
    Body: {
        first = GetByte(name, 0)
        second = GetByte(name, 1)
        third = GetByte(name, 2)
        
        is_dot = And(EqualTo(first, 46), EqualTo(second, 0))
        IfCondition is_dot ThenBlock: {
            ReturnValue(1)
        }
        
        is_dotdot = And(EqualTo(first, 46), And(EqualTo(second, 46), EqualTo(third, 0)))
        IfCondition is_dotdot ThenBlock: {
            ReturnValue(1)
        }
        
        ReturnValue(0)
    }
}

Function.ShouldSkipDots {
    Input: name: Address
    Output: Integer
    Body: {
        is_dot = IsDotEntry(name)
        
        IfCondition EqualTo(is_dot, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        IfCondition EqualTo(LsConfig.show_all, 1) ThenBlock: {
            ReturnValue(0)
        }
        
        ReturnValue(1)
    }
}

Function.StoreEntry {
    Input: entries: Address
    Input: index: Integer
    Input: name: Address
    Input: mtime: Integer
    Input: blocks: Integer
    Input: d_type: Integer
    Body: {
        base = Multiply(index, LsConstants.ENTRY_SIZE)
        StoreValue(Add(entries, base), name)
        StoreValue(Add(entries, Add(base, 8)), mtime)
        StoreValue(Add(entries, Add(base, 16)), blocks)
        SetByte(entries, Add(base, 24), d_type)
    }
}

Function.GetEntryName {
    Input: entries: Address
    Input: index: Integer
    Output: Address
    Body: {
        base = Multiply(index, LsConstants.ENTRY_SIZE)
        ReturnValue(Dereference(Add(entries, base)))
    }
}

Function.GetEntryMtime {
    Input: entries: Address
    Input: index: Integer
    Output: Integer
    Body: {
        base = Multiply(index, LsConstants.ENTRY_SIZE)
        ReturnValue(Dereference(Add(entries, Add(base, 8))))
    }
}

Function.GetEntryBlocks {
    Input: entries: Address
    Input: index: Integer
    Output: Integer
    Body: {
        base = Multiply(index, LsConstants.ENTRY_SIZE)
        ReturnValue(Dereference(Add(entries, Add(base, 16))))
    }
}

Function.GetEntryType {
    Input: entries: Address
    Input: index: Integer
    Output: Integer
    Body: {
        base = Multiply(index, LsConstants.ENTRY_SIZE)
        ReturnValue(GetByte(entries, Add(base, 24)))
    }
}

Function.SwapEntries {
    Input: entries: Address
    Input: i: Integer
    Input: j: Integer
    Body: {
        base1 = Multiply(i, LsConstants.ENTRY_SIZE)
        base2 = Multiply(j, LsConstants.ENTRY_SIZE)
        
        name1 = Dereference(Add(entries, base1))
        name2 = Dereference(Add(entries, base2))
        StoreValue(Add(entries, base1), name2)
        StoreValue(Add(entries, base2), name1)
        
        mtime1 = Dereference(Add(entries, Add(base1, 8)))
        mtime2 = Dereference(Add(entries, Add(base2, 8)))
        StoreValue(Add(entries, Add(base1, 8)), mtime2)
        StoreValue(Add(entries, Add(base2, 8)), mtime1)
        
        blocks1 = Dereference(Add(entries, Add(base1, 16)))
        blocks2 = Dereference(Add(entries, Add(base2, 16)))
        StoreValue(Add(entries, Add(base1, 16)), blocks2)
        StoreValue(Add(entries, Add(base2, 16)), blocks1)
        
        type1 = GetByte(entries, Add(base1, 24))
        type2 = GetByte(entries, Add(base2, 24))
        SetByte(entries, Add(base1, 24), type2)
        SetByte(entries, Add(base2, 24), type1)
    }
}

Function.StrCmp {
    Input: str1: Address
    Input: str2: Integer
    Output: Integer
    Body: {
        i = 0
        
        WhileLoop 1 {
            ch1 = GetByte(str1, i)
            ch2 = GetByte(str2, i)
            
            IfCondition NotEqual(ch1, ch2) ThenBlock: {
                ReturnValue(Subtract(ch1, ch2))
            }
            
            IfCondition EqualTo(ch1, 0) ThenBlock: {
                ReturnValue(0)
            }
            
            i = Add(i, 1)
        }
        
        ReturnValue(0)
    }
}

Function.ShouldSwap {
    Input: entries: Address
    Input: i: Integer
    Input: j: Integer
    Output: Integer
    Body: {
        name1 = GetEntryName(entries, i)
        name2 = GetEntryName(entries, j)
        
        result = 0
        
        IfCondition EqualTo(LsConfig.sort_by_time, 1) ThenBlock: {
            mtime1 = GetEntryMtime(entries, i)
            mtime2 = GetEntryMtime(entries, j)
            
            IfCondition LessThan(mtime1, mtime2) ThenBlock: {
                result = 1
            } ElseBlock: {
                IfCondition EqualTo(mtime1, mtime2) ThenBlock: {
                    cmp = StrCmp(name1, name2)
                    IfCondition GreaterThan(cmp, 0) ThenBlock: {
                        result = 1
                    }
                }
            }
        } ElseBlock: {
            cmp = StrCmp(name1, name2)
            IfCondition GreaterThan(cmp, 0) ThenBlock: {
                result = 1
            }
        }
        
        IfCondition EqualTo(LsConfig.reverse_sort, 1) ThenBlock: {
            IfCondition EqualTo(result, 1) ThenBlock: {
                result = 0
            } ElseBlock: {
                result = 1
            }
        }
        
        ReturnValue(result)
    }
}

Function.SortEntries {
    Input: entries: Address
    Input: count: Integer
    Body: {
        IfCondition LessEqual(count, 1) ThenBlock: {
            ReturnValue(0)
        }
        
        i = 0
        WhileLoop LessThan(i, Subtract(count, 1)) {
            swapped = 0
            j = 0
            WhileLoop LessThan(j, Subtract(Subtract(count, i), 1)) {
                should_swap = ShouldSwap(entries, j, Add(j, 1))
                
                IfCondition EqualTo(should_swap, 1) ThenBlock: {
                    SwapEntries(entries, j, Add(j, 1))
                    swapped = 1
                }
                
                j = Add(j, 1)
            }
            
            IfCondition EqualTo(swapped, 0) ThenBlock: {
                BreakLoop
            }
            
            i = Add(i, 1)
        }
    }
}

Function.IsFlag {
    Input: str: Address
    Output: Integer
    Body: {
        first_char = GetByte(str, 0)
        ReturnValue(EqualTo(first_char, 45))
    }
}

Function.ParseFlags {
    Input: flag_str: Address
    Body: {
        i = 1
        
        WhileLoop NotEqual(GetByte(flag_str, i), 0) {
            ch = GetByte(flag_str, i)
            
            IfCondition EqualTo(ch, 97) ThenBlock: { 
                LsConfig.show_all = 1 
            }
            IfCondition EqualTo(ch, 108) ThenBlock: { 
                LsConfig.long_format = 1 
            }
            IfCondition EqualTo(ch, 104) ThenBlock: { 
                LsConfig.human_readable = 1 
            }
            IfCondition EqualTo(ch, 116) ThenBlock: { 
                LsConfig.sort_by_time = 1
            }
            IfCondition EqualTo(ch, 114) ThenBlock: { 
                LsConfig.reverse_sort = 1
            }
            IfCondition EqualTo(ch, 82) ThenBlock: { 
                LsConfig.recursive = 1
            }
            
            i = Add(i, 1)
        }
    }
}

Function.FormatSize {
    Input: size: Integer
    Output: Address
    Body: {
        IfCondition EqualTo(LsConfig.human_readable, 0) ThenBlock: {
            ReturnValue(NumberToString(size))
        }
        
        IfCondition LessThan(size, 1024) ThenBlock: {
            result = NumberToString(size)
            ReturnValue(result)
        }
        
        IfCondition LessThan(size, 1048576) ThenBlock: {
            kb = Divide(size, 1024)
            result = NumberToString(kb)
            result = StringConcat(result, "K")
            ReturnValue(result)
        }
        
        IfCondition LessThan(size, 1073741824) ThenBlock: {
            mb = Divide(size, 1048576)
            result = NumberToString(mb)
            result = StringConcat(result, "M")
            ReturnValue(result)
        }
        
        gb = Divide(size, 1073741824)
        result = NumberToString(gb)
        result = StringConcat(result, "G")
        ReturnValue(result)
    }
}

Function.GetMonthName {
    Input: month: Integer
    Output: Address
    Body: {
        IfCondition EqualTo(month, 0) ThenBlock: { ReturnValue(MonthNames.m0) }
        IfCondition EqualTo(month, 1) ThenBlock: { ReturnValue(MonthNames.m1) }
        IfCondition EqualTo(month, 2) ThenBlock: { ReturnValue(MonthNames.m2) }
        IfCondition EqualTo(month, 3) ThenBlock: { ReturnValue(MonthNames.m3) }
        IfCondition EqualTo(month, 4) ThenBlock: { ReturnValue(MonthNames.m4) }
        IfCondition EqualTo(month, 5) ThenBlock: { ReturnValue(MonthNames.m5) }
        IfCondition EqualTo(month, 6) ThenBlock: { ReturnValue(MonthNames.m6) }
        IfCondition EqualTo(month, 7) ThenBlock: { ReturnValue(MonthNames.m7) }
        IfCondition EqualTo(month, 8) ThenBlock: { ReturnValue(MonthNames.m8) }
        IfCondition EqualTo(month, 9) ThenBlock: { ReturnValue(MonthNames.m9) }
        IfCondition EqualTo(month, 10) ThenBlock: { ReturnValue(MonthNames.m10) }
        IfCondition EqualTo(month, 11) ThenBlock: { ReturnValue(MonthNames.m11) }
        ReturnValue("???")
    }
}

Function.PrintTimestamp {
    Input: mtime: Integer
    Body: {
        days = Divide(mtime, 86400)
        years = Divide(days, 365)
        days_in_year = Modulo(days, 365)
        month = Divide(days_in_year, 30)
        
        IfCondition GreaterThan(month, 11) ThenBlock: {
            month = 11
        }
        
        day = Modulo(days_in_year, 30)
        IfCondition EqualTo(day, 0) ThenBlock: {
            day = 1
        }
        
        time_of_day = Modulo(mtime, 86400)
        hours = Divide(time_of_day, 3600)
        minutes = Divide(Modulo(time_of_day, 3600), 60)
        
        month_name = GetMonthName(month)
        WriteBuffered(month_name)
        WriteBuffered(" ")
        
        day_str = NumberToString(day)
        IfCondition LessThan(day, 10) ThenBlock: {
            WriteBuffered(" ")
        }
        WriteBuffered(day_str)
        WriteBuffered(" ")
        
        IfCondition LessThan(hours, 10) ThenBlock: {
            WriteBuffered("0")
        }
        hours_str = NumberToString(hours)
        WriteBuffered(hours_str)
        WriteBuffered(":")
        
        IfCondition LessThan(minutes, 10) ThenBlock: {
            WriteBuffered("0")
        }
        minutes_str = NumberToString(minutes)
        WriteBuffered(minutes_str)
    }
}

Function.PrintPermBit {
    Input: mode: Integer
    Input: bit: Integer
    Input: letter: Integer
    Body: {
        has_perm = BitwiseAnd(mode, bit)
        IfCondition NotEqual(has_perm, 0) ThenBlock: {
            WriteChar(letter)
        } ElseBlock: {
            WriteChar(45)
        }
    }
}

Function.PrintPermissions {
    Input: mode: Integer
    Body: {
        file_type = BitwiseAnd(mode, LsConstants.S_IFMT)
        
        IfCondition EqualTo(file_type, LsConstants.S_IFDIR) ThenBlock: {
            WriteChar(100)
        } ElseBlock: {
            IfCondition EqualTo(file_type, LsConstants.S_IFLNK) ThenBlock: {
                WriteChar(108)
            } ElseBlock: {
                WriteChar(45)
            }
        }
        
        PrintPermBit(mode, 256, 114)
        PrintPermBit(mode, 128, 119)
        PrintPermBit(mode, 64, 120)
        PrintPermBit(mode, 32, 114)
        PrintPermBit(mode, 16, 119)
        PrintPermBit(mode, 8, 120)
        PrintPermBit(mode, 4, 114)
        PrintPermBit(mode, 2, 119)
        PrintPermBit(mode, 1, 120)
    }
}

Function.ReadLinkAt {
    Input: dirfd: Integer
    Input: path: Address
    Output: Address
    Body: {
        link_buf = Allocate(LsConstants.PATH_MAX)
        bytes = SystemCall(267, dirfd, path, link_buf, LsConstants.PATH_MAX)
        
        IfCondition LessEqual(bytes, 0) ThenBlock: {
            Deallocate(link_buf, LsConstants.PATH_MAX)
            ReturnValue(0)
        }
        
        SetByte(link_buf, bytes, 0)
        ReturnValue(link_buf)
    }
}

Function.PrintLongFormat {
    Input: dirfd: Integer
    Input: filename: Address
    Output: Integer
    Body: {
        statbuf = Allocate(LsConstants.STAT_SIZE)
        result = SystemCall(262, dirfd, filename, statbuf, 256)
        
        IfCondition LessThan(result, 0) ThenBlock: {
            WriteBuffered("?????????? ? ? ? ? ? ")
            WriteBuffered(filename)
            WriteBuffered("\n")
            Deallocate(statbuf, LsConstants.STAT_SIZE)
            ReturnValue(1)
        }
        
        st_mode = GetUInt32(statbuf, 24)
        st_nlink = GetUInt64(statbuf, 16)
        st_uid = GetUInt32(statbuf, 28)
        st_gid = GetUInt32(statbuf, 32)
        st_size = GetUInt64(statbuf, 48)
        st_mtime = GetUInt64(statbuf, 88)
        st_blocks = GetUInt64(statbuf, 64)
        
        LsConfig.total_blocks = Add(LsConfig.total_blocks, st_blocks)
        
        PrintPermissions(st_mode)
        WriteBuffered(" ")
        
        nlink_str = NumberToString(st_nlink)
        WriteBuffered(nlink_str)
        WriteBuffered(" ")
        
        uid_str = NumberToString(st_uid)
        WriteBuffered(uid_str)
        WriteBuffered(" ")
        
        gid_str = NumberToString(st_gid)
        WriteBuffered(gid_str)
        WriteBuffered(" ")
        
        size_str = FormatSize(st_size)
        WriteBuffered(size_str)
        WriteBuffered(" ")
        
        PrintTimestamp(st_mtime)
        WriteBuffered(" ")
        
        WriteBuffered(filename)
        
        file_type = BitwiseAnd(st_mode, LsConstants.S_IFMT)
        IfCondition EqualTo(file_type, LsConstants.S_IFLNK) ThenBlock: {
            link_target = ReadLinkAt(dirfd, filename)
            IfCondition NotEqual(link_target, 0) ThenBlock: {
                WriteBuffered(" -> ")
                WriteBuffered(link_target)
                Deallocate(link_target, LsConstants.PATH_MAX)
            }
        }
        
        WriteBuffered("\n")
        
        Deallocate(statbuf, LsConstants.STAT_SIZE)
        ReturnValue(0)
    }
}

Function.CheckFileExists {
    Input: path: Address
    Output: Integer
    Body: {
        statbuf = Allocate(LsConstants.STAT_SIZE)
        result = SystemCall(262, LsConstants.AT_FDCWD, path, statbuf, 0)
        Deallocate(statbuf, LsConstants.STAT_SIZE)
        ReturnValue(GreaterEqual(result, 0))
    }
}

Function.IsDirectory {
    Input: path: Address
    Output: Integer
    Body: {
        statbuf = Allocate(LsConstants.STAT_SIZE)
        result = SystemCall(262, LsConstants.AT_FDCWD, path, statbuf, 0)
        
        IfCondition LessThan(result, 0) ThenBlock: {
            Deallocate(statbuf, LsConstants.STAT_SIZE)
            ReturnValue(0)
        }
        
        st_mode = GetUInt32(statbuf, 24)
        Deallocate(statbuf, LsConstants.STAT_SIZE)
        
        is_dir = BitwiseAnd(st_mode, 0x4000)
        ReturnValue(NotEqual(is_dir, 0))
    }
}

Function.IsDirectoryAt {
    Input: dirfd: Integer
    Input: name: Address
    Output: Integer
    Body: {
        statbuf = Allocate(LsConstants.STAT_SIZE)
        result = SystemCall(262, dirfd, name, statbuf, 0)
        
        IfCondition LessThan(result, 0) ThenBlock: {
            Deallocate(statbuf, LsConstants.STAT_SIZE)
            ReturnValue(0)
        }
        
        st_mode = GetUInt32(statbuf, 24)
        Deallocate(statbuf, LsConstants.STAT_SIZE)
        
        is_dir = BitwiseAnd(st_mode, 0x4000)
        ReturnValue(NotEqual(is_dir, 0))
    }
}

Function.BuildPath {
    Input: parent: Address
    Input: child: Address
    Output: Address
    Body: {
        parent_len = StringLength(parent)
        child_len = StringLength(child)
        
        total_len = Add(Add(parent_len, child_len), 2)
        result = Allocate(total_len)
        
        i = 0
        WhileLoop LessThan(i, parent_len) {
            SetByte(result, i, GetByte(parent, i))
            i = Add(i, 1)
        }
        
        SetByte(result, parent_len, 47)
        
        j = 0
        WhileLoop LessThan(j, child_len) {
            SetByte(result, Add(Add(parent_len, 1), j), GetByte(child, j))
            j = Add(j, 1)
        }
        
        SetByte(result, Subtract(total_len, 1), 0)
        
        ReturnValue(result)
    }
}

Function.PrintDirectory {
    Input: path: Address
    Output: Integer
    Body: {
        result = PrintDirectoryRecursive(path, 0, 0)
        ReturnValue(result)
    }
}

Function.PrintDirectoryRecursive {
    Input: path: Address
    Input: depth: Integer
    Input: print_header: Integer
    Output: Integer
    Body: {
        IfCondition GreaterThan(depth, 100) ThenBlock: {
            WriteStderr("ls: recursion too deep\n")
            ReturnValue(1)
        }
        
        IfCondition EqualTo(print_header, 1) ThenBlock: {
            WriteBuffered("\n")
            WriteBuffered(path)
            WriteBuffered(":\n")
        }
        flags = BitwiseOr(LsConstants.O_RDONLY, LsConstants.O_DIRECTORY)
        fd = SystemCall(257, LsConstants.AT_FDCWD, path, flags, 0)
        
        IfCondition LessThan(fd, 0) ThenBlock: {
            WriteStderr("ls: cannot access '")
            WriteStderr(path)
            WriteStderr("': No such file or directory\n")
            ReturnValue(1)
        }
        
        buffer = Allocate(LsConstants.BUFFER_SIZE)
        bytes_read = SystemCall(217, fd, buffer, LsConstants.BUFFER_SIZE)
        
        IfCondition LessThan(bytes_read, 0) ThenBlock: {
            WriteStderr("ls: reading directory failed\n")
            SystemCall(3, fd)
            Deallocate(buffer, LsConstants.BUFFER_SIZE)
            ReturnValue(1)
        }
        
        LsConfig.total_blocks = 0
        
        need_sort = 1
        
        subdirs = Allocate(Multiply(200, 8))
        subdir_count = 0
        
        IfCondition EqualTo(need_sort, 0) ThenBlock: {
            IfCondition EqualTo(LsConfig.long_format, 1) ThenBlock: {
                pos = 0
                WhileLoop LessThan(pos, bytes_read) {
                    d_reclen = GetUInt16(buffer, Add(pos, 16))
                    d_name_ptr = Add(buffer, Add(pos, 19))
                    
                    should_skip = ShouldSkipDots(d_name_ptr)
                    
                    IfCondition EqualTo(LsConfig.show_all, 0) ThenBlock: {
                        first_char = GetByte(d_name_ptr, 0)
                        IfCondition EqualTo(first_char, 46) ThenBlock: {
                            should_skip = 1
                        }
                    }
                    
                    IfCondition EqualTo(should_skip, 0) ThenBlock: {
                        statbuf = Allocate(LsConstants.STAT_SIZE)
                        result = SystemCall(262, fd, d_name_ptr, statbuf, 256)
                        IfCondition GreaterEqual(result, 0) ThenBlock: {
                            st_blocks = GetUInt64(statbuf, 64)
                            LsConfig.total_blocks = Add(LsConfig.total_blocks, st_blocks)
                        }
                        Deallocate(statbuf, LsConstants.STAT_SIZE)
                    }
                    
                    pos = Add(pos, d_reclen)
                }
                
                WriteBuffered("total ")
                total_kb = Divide(LsConfig.total_blocks, 2)
                
                IfCondition EqualTo(LsConfig.human_readable, 1) ThenBlock: {
                    total_str = FormatSize(Multiply(total_kb, 1024))
                } ElseBlock: {
                    total_str = NumberToString(total_kb)
                }
                
                WriteBuffered(total_str)
                WriteBuffered("\n")
                LsConfig.total_blocks = 0
            }
            
            pos = 0
            WhileLoop LessThan(pos, bytes_read) {
                d_reclen = GetUInt16(buffer, Add(pos, 16))
                d_type = GetByte(buffer, Add(pos, 18))
                d_name_ptr = Add(buffer, Add(pos, 19))
                
                should_skip = ShouldSkipDots(d_name_ptr)
                
                IfCondition EqualTo(LsConfig.show_all, 0) ThenBlock: {
                    first_char = GetByte(d_name_ptr, 0)
                    IfCondition EqualTo(first_char, 46) ThenBlock: {
                        should_skip = 1
                    }
                }
                
                IfCondition EqualTo(should_skip, 0) ThenBlock: {
                    IfCondition EqualTo(LsConfig.long_format, 1) ThenBlock: {
                        PrintLongFormat(fd, d_name_ptr)
                    } ElseBlock: {
                        WriteBuffered(d_name_ptr)
                        WriteBuffered("\n")
                    }
                    
                    // Check if directory for recursion
                    is_directory = 0
                    
                    IfCondition EqualTo(d_type, LsConstants.DT_DIR) ThenBlock: {
                        is_directory = 1
                    } ElseBlock: {
                        IfCondition EqualTo(d_type, LsConstants.DT_UNKNOWN) ThenBlock: {
                            is_directory = IsDirectoryAt(fd, d_name_ptr)
                        }
                    }
                    
                    IfCondition EqualTo(is_directory, 1) ThenBlock: {
                        is_dot_entry = IsDotEntry(d_name_ptr)
                        IfCondition EqualTo(is_dot_entry, 0) ThenBlock: {
                            IfCondition LessThan(subdir_count, 200) ThenBlock: {
                                name_len = StringLength(d_name_ptr)
                                subdir_copy = Allocate(Add(name_len, 1))
                                k = 0
                                WhileLoop LessThan(k, name_len) {
                                    SetByte(subdir_copy, k, GetByte(d_name_ptr, k))
                                    k = Add(k, 1)
                                }
                                SetByte(subdir_copy, name_len, 0)
                                StoreValue(Add(subdirs, Multiply(subdir_count, 8)), subdir_copy)
                                subdir_count = Add(subdir_count, 1)
                            }
                        }
                    }
                }
                
                pos = Add(pos, d_reclen)
            }
            
            Deallocate(buffer, LsConstants.BUFFER_SIZE)
            SystemCall(3, fd)
            
            IfCondition EqualTo(LsConfig.recursive, 1) ThenBlock: {
                i = 0
                WhileLoop LessThan(i, subdir_count) {
                    subdir_name = Dereference(Add(subdirs, Multiply(i, 8)))
                    full_path = BuildPath(path, subdir_name)
                    
                    PrintDirectoryRecursive(full_path, Add(depth, 1), 1)
                    
                    Deallocate(full_path, 0)
                    Deallocate(subdir_name, 0)
                    i = Add(i, 1)
                }
            } ElseBlock: {
                i = 0
                WhileLoop LessThan(i, subdir_count) {
                    subdir_name = Dereference(Add(subdirs, Multiply(i, 8)))
                    Deallocate(subdir_name, 0)
                    i = Add(i, 1)
                }
            }
            
            Deallocate(subdirs, Multiply(200, 8))
            ReturnValue(0)
        }
        
        entries = Allocate(Multiply(LsConstants.MAX_ENTRIES, LsConstants.ENTRY_SIZE))
        entry_count = 0
        
        pos = 0
        WhileLoop LessThan(pos, bytes_read) {
            d_reclen = GetUInt16(buffer, Add(pos, 16))
            d_type = GetByte(buffer, Add(pos, 18))
            d_name_ptr = Add(buffer, Add(pos, 19))
            
            should_skip = ShouldSkipDots(d_name_ptr)
            
            IfCondition EqualTo(LsConfig.show_all, 0) ThenBlock: {
                first_char = GetByte(d_name_ptr, 0)
                IfCondition EqualTo(first_char, 46) ThenBlock: {
                    should_skip = 1
                }
            }
            
            IfCondition EqualTo(should_skip, 0) ThenBlock: {
                name_len = StringLength(d_name_ptr)
                name_copy = Allocate(Add(name_len, 1))
                i = 0
                WhileLoop LessThan(i, name_len) {
                    ch = GetByte(d_name_ptr, i)
                    SetByte(name_copy, i, ch)
                    i = Add(i, 1)
                }
                SetByte(name_copy, name_len, 0)
                
                mtime = 0
                blocks = 0
                
                // Only stat if we need the info
                need_stat = Or(EqualTo(LsConfig.sort_by_time, 1), EqualTo(LsConfig.long_format, 1))
                
                IfCondition EqualTo(need_stat, 1) ThenBlock: {
                    statbuf = Allocate(LsConstants.STAT_SIZE)
                    result = SystemCall(262, fd, d_name_ptr, statbuf, 256)
                    IfCondition GreaterEqual(result, 0) ThenBlock: {
                        mtime = GetUInt64(statbuf, 88)
                        blocks = GetUInt64(statbuf, 64)
                    }
                    Deallocate(statbuf, LsConstants.STAT_SIZE)
                }
                
                StoreEntry(entries, entry_count, name_copy, mtime, blocks, d_type)
                entry_count = Add(entry_count, 1)
                
                IfCondition GreaterEqual(entry_count, LsConstants.MAX_ENTRIES) ThenBlock: {
                    BreakLoop
                }
            }
            
            pos = Add(pos, d_reclen)
        }
        
        SortEntries(entries, entry_count)
        
        i = 0
        WhileLoop LessThan(i, entry_count) {
            filename = GetEntryName(entries, i)
            d_type = GetEntryType(entries, i)
            
            // Check if this is a directory
            is_directory = 0
            IfCondition EqualTo(d_type, LsConstants.DT_DIR) ThenBlock: {
                is_directory = 1
            } ElseBlock: {
                IfCondition EqualTo(d_type, LsConstants.DT_UNKNOWN) ThenBlock: {
                    is_directory = IsDirectoryAt(fd, filename)
                }
            }
            
            // If directory and not dot entry, add to subdirs
            IfCondition EqualTo(is_directory, 1) ThenBlock: {
                is_dot_entry = IsDotEntry(filename)
                IfCondition EqualTo(is_dot_entry, 0) ThenBlock: {
                    IfCondition LessThan(subdir_count, 200) ThenBlock: {
                        name_len = StringLength(filename)
                        subdir_copy = Allocate(Add(name_len, 1))
                        k = 0
                        WhileLoop LessThan(k, name_len) {
                            SetByte(subdir_copy, k, GetByte(filename, k))
                            k = Add(k, 1)
                        }
                        SetByte(subdir_copy, name_len, 0)
                        StoreValue(Add(subdirs, Multiply(subdir_count, 8)), subdir_copy)
                        subdir_count = Add(subdir_count, 1)
                    }
                }
            }
            i = Add(i, 1)
        }
        
        IfCondition EqualTo(LsConfig.long_format, 1) ThenBlock: {
            LsConfig.total_blocks = 0
            i = 0
            WhileLoop LessThan(i, entry_count) {
                blocks = GetEntryBlocks(entries, i)
                LsConfig.total_blocks = Add(LsConfig.total_blocks, blocks)
                i = Add(i, 1)
            }
            
            WriteBuffered("total ")
            total_kb = Divide(LsConfig.total_blocks, 2)
            
            IfCondition EqualTo(LsConfig.human_readable, 1) ThenBlock: {
                total_str = FormatSize(Multiply(total_kb, 1024))
            } ElseBlock: {
                total_str = NumberToString(total_kb)
            }
            
            WriteBuffered(total_str)
            WriteBuffered("\n")
        }
        
        i = 0
        WhileLoop LessThan(i, entry_count) {
            filename = GetEntryName(entries, i)
            
            IfCondition EqualTo(LsConfig.long_format, 1) ThenBlock: {
                PrintLongFormat(fd, filename)
            } ElseBlock: {
                WriteBuffered(filename)
                WriteBuffered("\n")
            }
            
            i = Add(i, 1)
        }
        
        i = 0
        WhileLoop LessThan(i, entry_count) {
            filename = GetEntryName(entries, i)
            Deallocate(filename, 0)
            i = Add(i, 1)
        }
        
        Deallocate(entries, Multiply(LsConstants.MAX_ENTRIES, LsConstants.ENTRY_SIZE))
        Deallocate(buffer, LsConstants.BUFFER_SIZE)
        SystemCall(3, fd)
        
        IfCondition EqualTo(LsConfig.recursive, 1) ThenBlock: {
            i = 0
            WhileLoop LessThan(i, subdir_count) {
                subdir_name = Dereference(Add(subdirs, Multiply(i, 8)))
                full_path = BuildPath(path, subdir_name)
                
                PrintDirectoryRecursive(full_path, Add(depth, 1), 1)
                
                Deallocate(full_path, 0)
                Deallocate(subdir_name, 0)
                i = Add(i, 1)
            }
        } ElseBlock: {
            i = 0
            WhileLoop LessThan(i, subdir_count) {
                subdir_name = Dereference(Add(subdirs, Multiply(i, 8)))
                Deallocate(subdir_name, 0)
                i = Add(i, 1)
            }
        }
        
        Deallocate(subdirs, Multiply(200, 8))
        
        ReturnValue(0)
    }
}

Function.PrintFile {
    Input: path: Address
    Output: Integer
    Body: {
        exists = CheckFileExists(path)
        IfCondition EqualTo(exists, 0) ThenBlock: {
            WriteStderr("ls: cannot access '")
            WriteStderr(path)
            WriteStderr("': No such file or directory\n")
            ReturnValue(1)
        }
        
        IfCondition EqualTo(LsConfig.long_format, 1) ThenBlock: {
            PrintLongFormat(LsConstants.AT_FDCWD, path)
        } ElseBlock: {
            WriteBuffered(path)
            WriteBuffered("\n")
        }
        ReturnValue(0)
    }
}

Function.ProcessPath {
    Input: path: Address
    Output: Integer
    Body: {
        is_dir = IsDirectory(path)
        
        IfCondition EqualTo(is_dir, 1) ThenBlock: {
            IfCondition EqualTo(LsConfig.recursive, 1) ThenBlock: {
                WriteBuffered(path)
                WriteBuffered(":\n")
                result = PrintDirectoryRecursive(path, 0, 0)
            } ElseBlock: {
                result = PrintDirectory(path)
            }
            ReturnValue(result)
        } ElseBlock: {
            result = PrintFile(path)
            ReturnValue(result)
        }
    }
}

Function.GetArgs {
    Output: Address
    Body: {
        cmdline_path = "/proc/self/cmdline"
        fd = SystemCall(257, LsConstants.AT_FDCWD, cmdline_path, LsConstants.O_RDONLY, 0)
        
        IfCondition LessThan(fd, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        buffer = Allocate(4096)
        bytes_read = SystemCall(0, fd, buffer, 4096)
        SystemCall(3, fd)
        
        IfCondition LessEqual(bytes_read, 0) ThenBlock: {
            Deallocate(buffer, 4096)
            ReturnValue(0)
        }
        
        ReturnValue(buffer)
    }
}

SubRoutine.Main {
    RunTask(InitMonthNames)
    RunTask(InitBuffer)
    
    args_buffer = GetArgs()
    
    IfCondition EqualTo(args_buffer, 0) ThenBlock: {
        ProcessPath(".")
        RunTask(FlushBuffer)
        HaltProgram()
    }
    
    pos = 0
    WhileLoop NotEqual(GetByte(args_buffer, pos), 0) {
        pos = Add(pos, 1)
    }
    pos = Add(pos, 1)
    
    file_paths = Allocate(Multiply(100, 8))
    file_count = 0
    exit_code = 0
    
    WhileLoop LessThan(pos, 4096) {
        ch = GetByte(args_buffer, pos)
        IfCondition EqualTo(ch, 0) ThenBlock: {
            BreakLoop
        }
        
        arg_start = pos
        arg_len = 0
        
        WhileLoop And(LessThan(pos, 4096), NotEqual(GetByte(args_buffer, pos), 0)) {
            arg_len = Add(arg_len, 1)
            pos = Add(pos, 1)
        }
        
        arg = Allocate(Add(arg_len, 1))
        i = 0
        WhileLoop LessThan(i, arg_len) {
            ch = GetByte(args_buffer, Add(arg_start, i))
            SetByte(arg, i, ch)
            i = Add(i, 1)
        }
        SetByte(arg, arg_len, 0)
        
        is_flag = IsFlag(arg)
        
        IfCondition EqualTo(is_flag, 1) ThenBlock: {
            ParseFlags(arg)
            Deallocate(arg, 0)
        } ElseBlock: {
            StoreValue(Add(file_paths, Multiply(file_count, 8)), arg)
            file_count = Add(file_count, 1)
        }
        
        pos = Add(pos, 1)
    }
    
    Deallocate(args_buffer, 4096)
    
    IfCondition EqualTo(file_count, 0) ThenBlock: {
        ProcessPath(".")
        Deallocate(file_paths, Multiply(100, 8))
        RunTask(FlushBuffer)
        HaltProgram()
    }
    
    IfCondition GreaterThan(file_count, 1) ThenBlock: {
        need_sort = Or(EqualTo(LsConfig.sort_by_time, 1), EqualTo(LsConfig.reverse_sort, 1))
        
        i = 0
        WhileLoop LessThan(i, Subtract(file_count, 1)) {
            j = 0
            WhileLoop LessThan(j, Subtract(Subtract(file_count, i), 1)) {
                path1 = Dereference(Add(file_paths, Multiply(j, 8)))
                path2 = Dereference(Add(file_paths, Multiply(Add(j, 1), 8)))
                
                should_swap = 0
                
                cmp = StrCmp(path1, path2)
                IfCondition GreaterThan(cmp, 0) ThenBlock: {
                    should_swap = 1
                }
                
                IfCondition EqualTo(LsConfig.reverse_sort, 1) ThenBlock: {
                    IfCondition EqualTo(should_swap, 1) ThenBlock: {
                        should_swap = 0
                    } ElseBlock: {
                        should_swap = 1
                    }
                }
                
                IfCondition EqualTo(should_swap, 1) ThenBlock: {
                    StoreValue(Add(file_paths, Multiply(j, 8)), path2)
                    StoreValue(Add(file_paths, Multiply(Add(j, 1), 8)), path1)
                }
                
                j = Add(j, 1)
            }
            i = Add(i, 1)
        }
    }
    
    i = 0
    WhileLoop LessThan(i, file_count) {
        path = Dereference(Add(file_paths, Multiply(i, 8)))
        result = ProcessPath(path)
        
        IfCondition NotEqual(result, 0) ThenBlock: {
            exit_code = 1
        }
        
        Deallocate(path, 0)
        i = Add(i, 1)
    }
    
    Deallocate(file_paths, Multiply(100, 8))
    
    RunTask(FlushBuffer)
    Deallocate(OutputBuf.buf, OutputBuf.cap)
    
    IfCondition NotEqual(exit_code, 0) ThenBlock: {
        SystemCall(60, exit_code)
    }
    
    HaltProgram()
}

RunTask(Main)