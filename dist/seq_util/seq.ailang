// seq.ailang - Print number sequences
// Usage: seq [FIRST [INCREMENT]] LAST

FixedPool.SeqBuffer {
    "buffer": Initialize=0
    "position": Initialize=0
    "size": Initialize=65536
}

Function.InitBuffer {
    Body: {
        SeqBuffer.buffer = Allocate(SeqBuffer.size)
        SeqBuffer.position = 0
    }
}

Function.FlushBuffer {
    Body: {
        IfCondition GreaterThan(SeqBuffer.position, 0) ThenBlock: {
            SystemCall(1, 1, SeqBuffer.buffer, SeqBuffer.position)
            SeqBuffer.position = 0
        }
    }
}

Function.BufferByte {
    Input: byte: Integer
    Body: {
        IfCondition GreaterEqual(SeqBuffer.position, SeqBuffer.size) ThenBlock: {
            FlushBuffer()
        }
        SetByte(SeqBuffer.buffer, SeqBuffer.position, byte)
        SeqBuffer.position = Add(SeqBuffer.position, 1)
    }
}

Function.WriteNumber {
    Input: num: Integer
    Body: {
        IfCondition LessThan(num, 0) ThenBlock: {
            BufferByte(45)
            num = Subtract(0, num)
        }
        
        // Fast paths for common cases
        IfCondition LessThan(num, 10) ThenBlock: {
            BufferByte(Add(48, num))
            BufferByte(10)
            ReturnValue(0)
        }
        
        IfCondition LessThan(num, 100) ThenBlock: {
            BufferByte(Add(48, Divide(num, 10)))
            BufferByte(Add(48, Modulo(num, 10)))
            BufferByte(10)
            ReturnValue(0)
        }
        
        IfCondition LessThan(num, 1000) ThenBlock: {
            BufferByte(Add(48, Divide(num, 100)))
            temp = Modulo(num, 100)
            BufferByte(Add(48, Divide(temp, 10)))
            BufferByte(Add(48, Modulo(temp, 10)))
            BufferByte(10)
            ReturnValue(0)
        }
        
        IfCondition LessThan(num, 10000) ThenBlock: {
            BufferByte(Add(48, Divide(num, 1000)))
            temp = Modulo(num, 1000)
            BufferByte(Add(48, Divide(temp, 100)))
            temp = Modulo(temp, 100)
            BufferByte(Add(48, Divide(temp, 10)))
            BufferByte(Add(48, Modulo(temp, 10)))
            BufferByte(10)
            ReturnValue(0)
        }
        
        IfCondition LessThan(num, 100000) ThenBlock: {
            BufferByte(Add(48, Divide(num, 10000)))
            temp = Modulo(num, 10000)
            BufferByte(Add(48, Divide(temp, 1000)))
            temp = Modulo(temp, 1000)
            BufferByte(Add(48, Divide(temp, 100)))
            temp = Modulo(temp, 100)
            BufferByte(Add(48, Divide(temp, 10)))
            BufferByte(Add(48, Modulo(temp, 10)))
            BufferByte(10)
            ReturnValue(0)
        }
        
        // Fallback for huge numbers (rare)
        temp = num
        digits = 0
        WhileLoop GreaterThan(temp, 0) {
            temp = Divide(temp, 10)
            digits = Add(digits, 1)
        }
        
        i = Subtract(digits, 1)
        temp = num
        WhileLoop GreaterEqual(i, 0) {
            divisor = 1
            j = 0
            WhileLoop LessThan(j, i) {
                divisor = Multiply(divisor, 10)
                j = Add(j, 1)
            }
            digit = Divide(temp, divisor)
            BufferByte(Add(48, digit))
            temp = Subtract(temp, Multiply(digit, divisor))
            i = Subtract(i, 1)
        }
        BufferByte(10)
    }
}

Function.StringToInt {
    Input: str: Address
    Output: Integer
    Body: {
        result = 0
        i = 0
        negative = 0
        
        first = GetByte(str, 0)
        IfCondition EqualTo(first, 45) ThenBlock: {
            negative = 1
            i = 1
        }
        
        WhileLoop 1 {
            ch = GetByte(str, i)
            IfCondition Or(LessThan(ch, 48), GreaterThan(ch, 57)) ThenBlock: {
                BreakLoop
            }
            digit = Subtract(ch, 48)
            result = Add(Multiply(result, 10), digit)
            i = Add(i, 1)
        }
        
        IfCondition EqualTo(negative, 1) ThenBlock: {
            result = Subtract(0, result)
        }
        
        ReturnValue(result)
    }
}

Function.GetArgs {
    Output: Address
    Body: {
        cmdline_path = "/proc/self/cmdline"
        fd = SystemCall(257, -100, cmdline_path, 0, 0)
        
        IfCondition LessThan(fd, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        buffer = Allocate(4096)
        bytes_read = SystemCall(0, fd, buffer, 4096)
        SystemCall(3, fd)
        
        IfCondition LessEqual(bytes_read, 0) ThenBlock: {
            Deallocate(buffer, 4096)
            ReturnValue(0)
        }
        
        ReturnValue(buffer)
    }
}

SubRoutine.Main {
    InitBuffer()
    
    args_buffer = GetArgs()
    
    // Skip program name
    pos = 0
    WhileLoop NotEqual(GetByte(args_buffer, pos), 0) {
        pos = Add(pos, 1)
    }
    pos = Add(pos, 1)
    
    // Collect arguments
    args = Allocate(24)  // 3 args max
    arg_count = 0
    
    WhileLoop LessThan(pos, 4096) {
        ch = GetByte(args_buffer, pos)
        IfCondition EqualTo(ch, 0) ThenBlock: {
            BreakLoop
        }
        
        arg_start = pos
        arg_len = 0
        
        WhileLoop And(LessThan(pos, 4096), NotEqual(GetByte(args_buffer, pos), 0)) {
            arg_len = Add(arg_len, 1)
            pos = Add(pos, 1)
        }
        
        arg = Allocate(Add(arg_len, 1))
        i = 0
        WhileLoop LessThan(i, arg_len) {
            ch = GetByte(args_buffer, Add(arg_start, i))
            SetByte(arg, i, ch)
            i = Add(i, 1)
        }
        SetByte(arg, arg_len, 0)
        
        StoreValue(Add(args, Multiply(arg_count, 8)), arg)
        arg_count = Add(arg_count, 1)
        pos = Add(pos, 1)
    }
    
    Deallocate(args_buffer, 4096)
    
    // Parse arguments: seq LAST or seq FIRST LAST or seq FIRST INCREMENT LAST
    first = 1
    increment = 1
    last = 0
    
    IfCondition EqualTo(arg_count, 1) ThenBlock: {
        // seq LAST
        last = StringToInt(Dereference(args))
    } ElseBlock: {
        IfCondition EqualTo(arg_count, 2) ThenBlock: {
            // seq FIRST LAST
            first = StringToInt(Dereference(args))
            last = StringToInt(Dereference(Add(args, 8)))
        } ElseBlock: {
            IfCondition EqualTo(arg_count, 3) ThenBlock: {
                // seq FIRST INCREMENT LAST
                first = StringToInt(Dereference(args))
                increment = StringToInt(Dereference(Add(args, 8)))
                last = StringToInt(Dereference(Add(args, 16)))
            }
        }
    }
    
    // Generate sequence
    IfCondition GreaterThan(increment, 0) ThenBlock: {
        current = first
        WhileLoop LessEqual(current, last) {
            WriteNumber(current)
            current = Add(current, increment)
        }
    } ElseBlock: {
        IfCondition LessThan(increment, 0) ThenBlock: {
            current = first
            WhileLoop GreaterEqual(current, last) {
                WriteNumber(current)
                current = Add(current, increment)
            }
        }
    }
    
    FlushBuffer()
    Deallocate(SeqBuffer.buffer, SeqBuffer.size)
    Deallocate(args, 24)
    SystemCall(60, 0)
}

RunTask(Main)