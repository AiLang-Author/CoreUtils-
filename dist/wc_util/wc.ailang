// wc_optimized.ailang - Fast word, line, character, and byte counter
// Optimized with MemChr, buffered output, and pointer arithmetic
// Version 2.2 - With DebugPerf timing

FixedPool.WcConfig {
    "count_lines": Initialize=0       
    "count_words": Initialize=0       
    "count_chars": Initialize=0       
    "max_line_length": Initialize=0
    "show_all": Initialize=1          
}

FixedPool.WcCounts {
    "lines": Initialize=0
    "words": Initialize=0
    "chars": Initialize=0
    "max_line": Initialize=0
    "current_line_len": Initialize=0
    "in_word": Initialize=0
}

FixedPool.WcConstants {
    "BUFFER_SIZE": Initialize=262144  
    "MAX_FILES": Initialize=100
}

FixedPool.WcTotals {
    "total_lines": Initialize=0
    "total_words": Initialize=0
    "total_chars": Initialize=0
    "total_max_line": Initialize=0
}

FixedPool.OutputBuffer {
    "buffer": Initialize=0
    "position": Initialize=0
    "size": Initialize=65536
}

FixedPool.Spaces {
    "pad7": Initialize="       "  
}

// === BUFFERED OUTPUT FUNCTIONS ===

Function.InitBuffers {
    Body: {
        OutputBuffer.buffer = Allocate(OutputBuffer.size)
        OutputBuffer.position = 0
    }
}

Function.FlushOutput {
    Body: {
        IfCondition GreaterThan(OutputBuffer.position, 0) ThenBlock: {
            SystemCall(1, 1, OutputBuffer.buffer, OutputBuffer.position)
            OutputBuffer.position = 0
        }
    }
}

Function.WriteBuffered {
    Input: data: Address
    Input: len: Integer
    Body: {
        space_left = Subtract(OutputBuffer.size, OutputBuffer.position)
        IfCondition LessThan(space_left, len) ThenBlock: {
            FlushOutput()
        }
        
        MemCopy(Add(OutputBuffer.buffer, OutputBuffer.position), data, len)
        OutputBuffer.position = Add(OutputBuffer.position, len)
    }
}

Function.WriteByteBuffered {
    Input: byte: Integer
    Body: {
        IfCondition GreaterEqual(OutputBuffer.position, OutputBuffer.size) ThenBlock: {
            FlushOutput()
        }
        SetByte(OutputBuffer.buffer, OutputBuffer.position, byte)
        OutputBuffer.position = Add(OutputBuffer.position, 1)
    }
}

Function.WriteStderr {
    Input: buffer: Address
    Input: len: Integer
    Body: {
        SystemCall(1, 2, buffer, len)
    }
}

Function.GetStringLength {
    Input: str: Address
    Output: Integer
    Body: {
        len = 0
        WhileLoop NotEqual(GetByte(str, len), 0) {
            len = Add(len, 1)
        }
        ReturnValue(len)
    }
}

// === STRING UTILITIES ===

Function.StringsMatch {
    Input: str1: Address
    Input: str2: Address
    Output: Integer
    Body: {
        i = 0
        WhileLoop 1 {
            ch1 = GetByte(str1, i)
            ch2 = GetByte(str2, i)
            
            IfCondition NotEqual(ch1, ch2) ThenBlock: {
                ReturnValue(0)
            }
            
            IfCondition EqualTo(ch1, 0) ThenBlock: {
                ReturnValue(1)
            }
            
            i = Add(i, 1)
        }
        ReturnValue(0)
    }
}

Function.CheckIfFlag {
    Input: str: Address
    Output: Integer
    Body: {
        first = GetByte(str, 0)
        second = GetByte(str, 1)
        
        IfCondition And(EqualTo(first, 45), NotEqual(second, 0)) ThenBlock: {
            ReturnValue(1)
        }
        ReturnValue(0)
    }
}

// === COUNTING LOGIC ===

Function.ResetCounts {
    Body: {
        WcCounts.lines = 0
        WcCounts.words = 0
        WcCounts.chars = 0
        WcCounts.max_line = 0
        WcCounts.current_line_len = 0
        WcCounts.in_word = 0
    }
}

Function.CountFileOptimized {
    Input: fd: Integer
    Body: {
        buffer = Allocate(WcConstants.BUFFER_SIZE)
        
        need_words = WcConfig.count_words
        need_max_line = WcConfig.max_line_length
        
        IfCondition EqualTo(WcConfig.show_all, 1) ThenBlock: {
            need_words = 1
        }
        
        keep_reading = 1
        WhileLoop EqualTo(keep_reading, 1) {
            bytes_read = SystemCall(0, fd, buffer, WcConstants.BUFFER_SIZE)
            
            IfCondition LessEqual(bytes_read, 0) ThenBlock: {
                keep_reading = 0
            } ElseBlock: {
                WcCounts.chars = Add(WcCounts.chars, bytes_read)
                
                // Fast line count using MemChr
                scan_pos = 0
                WhileLoop LessThan(scan_pos, bytes_read) {
                    search_start = Add(buffer, scan_pos)
                    search_len = Subtract(bytes_read, scan_pos)
                    newline_offset = MemChr(search_start, 10, search_len)
                    
                    IfCondition LessThan(newline_offset, 0) ThenBlock: {
                        IfCondition NotEqual(need_max_line, 0) ThenBlock: {
                            WcCounts.current_line_len = Add(WcCounts.current_line_len, search_len)
                        }
                        BreakLoop
                    } ElseBlock: {
                        WcCounts.lines = Add(WcCounts.lines, 1)
                        
                        IfCondition NotEqual(need_max_line, 0) ThenBlock: {
                            line_len = Add(WcCounts.current_line_len, newline_offset)
                            IfCondition GreaterThan(line_len, WcCounts.max_line) ThenBlock: {
                                WcCounts.max_line = line_len
                            }
                            WcCounts.current_line_len = 0
                        }
                        
                        scan_pos = Add(scan_pos, Add(newline_offset, 1))
                    }
                }
                
                // Word counting - only if needed
                IfCondition NotEqual(need_words, 0) ThenBlock: {
                    ptr = buffer
                    end_ptr = Add(buffer, bytes_read)
                    
                    WhileLoop LessThan(ptr, end_ptr) {
                        ch = GetByte(ptr, 0)
                        
                        is_space = 0
                        Branch ch {
                            Case 9: { is_space = 1 }
                            Case 10: { is_space = 1 }
                            Case 13: { is_space = 1 }
                            Case 32: { is_space = 1 }
                            Default: { is_space = 0 }
                        }
                        
                        Fork EqualTo(is_space, 1) TrueBlock: {
                            WcCounts.in_word = 0
                        } FalseBlock: {
                            Fork EqualTo(WcCounts.in_word, 0) TrueBlock: {
                                WcCounts.words = Add(WcCounts.words, 1)
                                WcCounts.in_word = 1
                            } FalseBlock: {
                            }
                        }
                        
                        ptr = Add(ptr, 1)
                    }
                }
            }
        }
        
        IfCondition And(NotEqual(need_max_line, 0), GreaterThan(WcCounts.current_line_len, WcCounts.max_line)) ThenBlock: {
            WcCounts.max_line = WcCounts.current_line_len
        }
        
        Deallocate(buffer, WcConstants.BUFFER_SIZE)
    }
}

// === BUFFERED OUTPUT FORMATTING ===

Function.PrintFormattedNumber {
    Input: num: Integer
    Body: {
        num_str = NumberToString(num)
        num_len = GetStringLength(num_str)
        
        spaces_needed = Subtract(7, num_len)
        
        IfCondition LessThan(spaces_needed, 0) ThenBlock: {
            spaces_needed = 0
        }
        IfCondition GreaterThan(spaces_needed, 7) ThenBlock: {
            spaces_needed = 7
        }
        
        IfCondition GreaterThan(spaces_needed, 0) ThenBlock: {
            WriteBuffered(Spaces.pad7, spaces_needed)
        }
        
        WriteBuffered(num_str, num_len)
        WriteByteBuffered(32)
    }
}

Function.PrintResults {
    Input: filename: Address
    Body: {
        should_show_lines = 0
        IfCondition EqualTo(WcConfig.show_all, 1) ThenBlock: {
            should_show_lines = 1
        } ElseBlock: {
            IfCondition EqualTo(WcConfig.count_lines, 1) ThenBlock: {
                should_show_lines = 1
            }
        }
        
        IfCondition EqualTo(should_show_lines, 1) ThenBlock: {
            PrintFormattedNumber(WcCounts.lines)
        }
        
        should_show_words = 0
        IfCondition EqualTo(WcConfig.show_all, 1) ThenBlock: {
            should_show_words = 1
        } ElseBlock: {
            IfCondition EqualTo(WcConfig.count_words, 1) ThenBlock: {
                should_show_words = 1
            }
        }
        
        IfCondition EqualTo(should_show_words, 1) ThenBlock: {
            PrintFormattedNumber(WcCounts.words)
        }
        
        should_show_chars = 0
        IfCondition EqualTo(WcConfig.show_all, 1) ThenBlock: {
            should_show_chars = 1
        } ElseBlock: {
            IfCondition EqualTo(WcConfig.count_chars, 1) ThenBlock: {
                should_show_chars = 1
            }
        }
        
        IfCondition EqualTo(should_show_chars, 1) ThenBlock: {
            PrintFormattedNumber(WcCounts.chars)
        }
        
        IfCondition EqualTo(WcConfig.max_line_length, 1) ThenBlock: {
            PrintFormattedNumber(WcCounts.max_line)
        }
        
        IfCondition NotEqual(filename, 0) ThenBlock: {
            WriteByteBuffered(32)
            fname_len = GetStringLength(filename)
            WriteBuffered(filename, fname_len)
        }
        
        WriteByteBuffered(10)
    }
}

// === FILE PROCESSING ===

Function.ProcessSingleFile {
    Input: filename: Address
    Output: Integer
    Body: {
        ResetCounts()
        
        fd = SystemCall(2, filename, 0, 0)
        
        IfCondition LessThan(fd, 0) ThenBlock: {
            WriteStderr("wc: ", 4)
            fname_len = GetStringLength(filename)
            WriteStderr(filename, fname_len)
            WriteStderr(": No such file or directory\n", 28)
            ReturnValue(1)
        }
        
        CountFileOptimized(fd)
        SystemCall(3, fd)
        
        PrintResults(filename)
        
        WcTotals.total_lines = Add(WcTotals.total_lines, WcCounts.lines)
        WcTotals.total_words = Add(WcTotals.total_words, WcCounts.words)
        WcTotals.total_chars = Add(WcTotals.total_chars, WcCounts.chars)
        
        IfCondition GreaterThan(WcCounts.max_line, WcTotals.total_max_line) ThenBlock: {
            WcTotals.total_max_line = WcCounts.max_line
        }
        
        ReturnValue(0)
    }
}

Function.ProcessStdinInput {
    Body: {
        ResetCounts()
        CountFileOptimized(0)
        PrintResults(0)
    }
}

// === FLAG PARSING ===

Function.HandleFlags {
    Input: flag_str: Address
    Body: {
        i = 1
        
        WcConfig.show_all = 0
        
        WhileLoop NotEqual(GetByte(flag_str, i), 0) {
            ch = GetByte(flag_str, i)
            
            IfCondition EqualTo(ch, 108) ThenBlock: {
                WcConfig.count_lines = 1
            }
            
            IfCondition EqualTo(ch, 119) ThenBlock: {
                WcConfig.count_words = 1
            }
            
            IfCondition Or(EqualTo(ch, 99), EqualTo(ch, 109)) ThenBlock: {
                WcConfig.count_chars = 1
            }
            
            IfCondition EqualTo(ch, 76) ThenBlock: {
                WcConfig.max_line_length = 1
            }
            
            i = Add(i, 1)
        }
    }
}

// === ARGUMENT PARSING ===

Function.GetArgs {
    Output: Address
    Body: {
        cmdline_path = "/proc/self/cmdline"
        fd = SystemCall(257, -100, cmdline_path, 0, 0)
        
        IfCondition LessThan(fd, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        buffer = Allocate(4096)
        bytes_read = SystemCall(0, fd, buffer, 4096)
        SystemCall(3, fd)
        
        IfCondition LessEqual(bytes_read, 0) ThenBlock: {
            Deallocate(buffer, 4096)
            ReturnValue(0)
        }
        
        ReturnValue(buffer)
    }
}

Function.ShowHelp {
    Body: {
        help_msg = "Usage: wc [OPTION]... [FILE]...
Print newline, word, and byte counts for each FILE.

  -c              print the byte counts
  -m              print the character counts
  -l              print the newline counts
  -L              print the maximum display width
  -w              print the word counts
      --help      display this help and exit
      --version   output version information and exit

With no FILE, or when FILE is -, read standard input.
"
        WriteBuffered(help_msg, GetStringLength(help_msg))
        FlushOutput()
    }
}

Function.ShowVersion {
    Body: {
        version_msg = "wc (AILang coreutils) 2.2 - Optimized with profiling
Written in AILang - Performance focused
Compatible with GNU wc
"
        WriteBuffered(version_msg, GetStringLength(version_msg))
        FlushOutput()
    }
}

// === MAIN ===

SubRoutine.Main {
    DebugPerf.Start("Main_Total")
    
    InitBuffers()
    
    args_buffer = GetArgs()
    
    IfCondition EqualTo(args_buffer, 0) ThenBlock: {
        DebugPerf.Start("Process_Stdin")
        ProcessStdinInput()
        DebugPerf.End("Process_Stdin")
        FlushOutput()
        SystemCall(60, 0)
    }
    
    pos = 0
    WhileLoop NotEqual(GetByte(args_buffer, pos), 0) {
        pos = Add(pos, 1)
    }
    pos = Add(pos, 1)
    
    file_paths = Allocate(Multiply(WcConstants.MAX_FILES, 8))
    file_count = 0
    exit_code = 0
    
    WhileLoop LessThan(pos, 4096) {
        ch = GetByte(args_buffer, pos)
        IfCondition EqualTo(ch, 0) ThenBlock: {
            BreakLoop
        }
        
        arg_start = pos
        arg_len = 0
        
        WhileLoop And(LessThan(pos, 4096), NotEqual(GetByte(args_buffer, pos), 0)) {
            arg_len = Add(arg_len, 1)
            pos = Add(pos, 1)
        }
        
        arg = Allocate(Add(arg_len, 1))
        i = 0
        WhileLoop LessThan(i, arg_len) {
            ch = GetByte(args_buffer, Add(arg_start, i))
            SetByte(arg, i, ch)
            i = Add(i, 1)
        }
        SetByte(arg, arg_len, 0)
        
        is_flag = CheckIfFlag(arg)
        
        IfCondition EqualTo(is_flag, 1) ThenBlock: {
            second = GetByte(arg, 1)
            IfCondition EqualTo(second, 45) ThenBlock: {
                is_help = StringsMatch(arg, "--help")
                IfCondition EqualTo(is_help, 1) ThenBlock: {
                    ShowHelp()
                    SystemCall(60, 0)
                }
                
                is_version = StringsMatch(arg, "--version")
                IfCondition EqualTo(is_version, 1) ThenBlock: {
                    ShowVersion()
                    SystemCall(60, 0)
                }
            }
            
            HandleFlags(arg)
            Deallocate(arg, 0)
        } ElseBlock: {
            first = GetByte(arg, 0)
            second = GetByte(arg, 1)
            is_dash = And(EqualTo(first, 45), EqualTo(second, 0))
            
            IfCondition EqualTo(is_dash, 1) ThenBlock: {
                DebugPerf.Start("Process_Stdin")
                ProcessStdinInput()
                DebugPerf.End("Process_Stdin")
                file_count = Add(file_count, 1)
                Deallocate(arg, 0)
            } ElseBlock: {
                StoreValue(Add(file_paths, Multiply(file_count, 8)), arg)
                file_count = Add(file_count, 1)
            }
        }
        
        pos = Add(pos, 1)
    }
    
    Deallocate(args_buffer, 4096)
    
    IfCondition EqualTo(file_count, 0) ThenBlock: {
        DebugPerf.Start("Process_Stdin")
        ProcessStdinInput()
        DebugPerf.End("Process_Stdin")
        FlushOutput()
        Deallocate(file_paths, Multiply(WcConstants.MAX_FILES, 8))
        SystemCall(60, 0)
    }
    
    DebugPerf.Start("Process_All_Files")
    i = 0
    WhileLoop LessThan(i, file_count) {
        path = Dereference(Add(file_paths, Multiply(i, 8)))
        
        DebugPerf.Start("Process_Single_File")
        result = ProcessSingleFile(path)
        DebugPerf.End("Process_Single_File")
        
        IfCondition NotEqual(result, 0) ThenBlock: {
            exit_code = 1
        }
        
        Deallocate(path, 0)
        i = Add(i, 1)
    }
    DebugPerf.End("Process_All_Files")
    
    IfCondition GreaterThan(file_count, 1) ThenBlock: {
        WcCounts.lines = WcTotals.total_lines
        WcCounts.words = WcTotals.total_words
        WcCounts.chars = WcTotals.total_chars
        WcCounts.max_line = WcTotals.total_max_line
        
        PrintResults("total")
    }
    
    FlushOutput()
    Deallocate(file_paths, Multiply(WcConstants.MAX_FILES, 8))
    
    DebugPerf.End("Main_Total")
    
    IfCondition NotEqual(exit_code, 0) ThenBlock: {
        SystemCall(60, exit_code)
    }
    
    SystemCall(60, 0)
}

RunTask(Main)