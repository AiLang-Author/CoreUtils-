// mv.ailang - GNU-Compatible Move/Rename Utility
// Usage: mv [OPTION]... SOURCE... DIRECTORY
//        mv [OPTION]... SOURCE DEST
// Rename SOURCE to DEST, or move SOURCE(s) to DIRECTORY.
//
// Options:
//   -f, --force                  do not prompt before overwriting
//   -i, --interactive            prompt before overwrite
//   -n, --no-clobber             do not overwrite an existing file
//   -v, --verbose                explain what is being done
//   -b, --backup                 make a backup of each existing destination file
//   -u, --update                 move only when the SOURCE file is newer
//   --help                       display this help and exit
//   --version                    output version information and exit

FixedPool.MvConfig {
    "force": Initialize=0
    "interactive": Initialize=0
    "no_clobber": Initialize=0
    "verbose": Initialize=0
    "backup": Initialize=0
    "update": Initialize=0
}

FixedPool.MvStats {
    "moved": Initialize=0
    "errors": Initialize=0
    "skipped": Initialize=0
}

FixedPool.MvConstants {
    "EEXIST": Initialize=17
    "ENOENT": Initialize=2
    "EACCES": Initialize=13
    "EXDEV": Initialize=18
    "EISDIR": Initialize=21
    "ENOTDIR": Initialize=20
    "BUFFER_SIZE": Initialize=65536
    "O_RDONLY": Initialize=0
    "O_WRONLY": Initialize=1
    "O_CREAT": Initialize=64
    "O_TRUNC": Initialize=512
}

// ============================================================================
// UTILITY FUNCTIONS
// ============================================================================

Function.WriteStdout {
    Input: str: Address
    Body: {
        len = StringLength(str)
        SystemCall(1, 1, str, len)
    }
}

Function.WriteStderr {
    Input: str: Address
    Body: {
        len = StringLength(str)
        SystemCall(1, 2, str, len)
    }
}

Function.IntToString {
    Input: num: Integer
    Output: Address
    Body: {
        IfCondition EqualTo(num, 0) ThenBlock: {
            str = Allocate(2)
            SetByte(str, 0, 48)
            SetByte(str, 1, 0)
            ReturnValue(str)
        }
        
        is_negative = LessThan(num, 0)
        abs_num = num
        IfCondition EqualTo(is_negative, 1) ThenBlock: {
            abs_num = Subtract(0, num)
        }
        
        temp = abs_num
        digits = 0
        WhileLoop GreaterThan(temp, 0) {
            temp = Divide(temp, 10)
            digits = Add(digits, 1)
        }
        
        total_len = digits
        IfCondition EqualTo(is_negative, 1) ThenBlock: {
            total_len = Add(total_len, 1)
        }
        
        str = Allocate(Add(total_len, 1))
        
        pos = 0
        IfCondition EqualTo(is_negative, 1) ThenBlock: {
            SetByte(str, 0, 45)
            pos = 1
        }
        
        i = Subtract(total_len, 1)
        temp = abs_num
        WhileLoop GreaterThan(temp, 0) {
            digit = Modulo(temp, 10)
            SetByte(str, i, Add(48, digit))
            temp = Divide(temp, 10)
            i = Subtract(i, 1)
        }
        
        SetByte(str, total_len, 0)
        ReturnValue(str)
    }
}

Function.PathExists {
    Input: path: Address
    Output: Integer
    Body: {
        statbuf = Allocate(144)
        result = SystemCall(4, path, statbuf)
        Deallocate(statbuf, 144)
        ReturnValue(GreaterEqual(result, 0))
    }
}

Function.IsDirectory {
    Input: path: Address
    Output: Integer
    Body: {
        statbuf = Allocate(144)
        result = SystemCall(4, path, statbuf)
        
        IfCondition LessThan(result, 0) ThenBlock: {
            Deallocate(statbuf, 144)
            ReturnValue(0)
        }
        
        st_mode = Dereference(Add(statbuf, 24))
        Deallocate(statbuf, 144)
        
        is_dir = BitwiseAnd(st_mode, 16384)
        ReturnValue(NotEqual(is_dir, 0))
    }
}

Function.GetModTime {
    Input: path: Address
    Output: Integer
    Body: {
        statbuf = Allocate(144)
        result = SystemCall(4, path, statbuf)
        
        IfCondition LessThan(result, 0) ThenBlock: {
            Deallocate(statbuf, 144)
            ReturnValue(0)
        }
        
        mtime = Dereference(Add(statbuf, 88))
        Deallocate(statbuf, 144)
        ReturnValue(mtime)
    }
}

Function.GetFileMode {
    Input: path: Address
    Output: Integer
    Body: {
        statbuf = Allocate(144)
        result = SystemCall(4, path, statbuf)
        
        IfCondition LessThan(result, 0) ThenBlock: {
            Deallocate(statbuf, 144)
            ReturnValue(420)
        }
        
        st_mode = Dereference(Add(statbuf, 24))
        Deallocate(statbuf, 144)
        
        permissions = BitwiseAnd(st_mode, 4095)
        ReturnValue(permissions)
    }
}

Function.BuildPath {
    Input: dir: Address
    Input: file: Address
    Output: Address
    Body: {
        dir_len = StringLength(dir)
        file_len = StringLength(file)
        
        needs_slash = 1
        IfCondition GreaterThan(dir_len, 0) ThenBlock: {
            last_char = GetByte(dir, Subtract(dir_len, 1))
            IfCondition EqualTo(last_char, 47) ThenBlock: {
                needs_slash = 0
            }
        }
        
        total_len = Add(Add(dir_len, file_len), Add(needs_slash, 1))
        path = Allocate(total_len)
        
        i = 0
        WhileLoop LessThan(i, dir_len) {
            SetByte(path, i, GetByte(dir, i))
            i = Add(i, 1)
        }
        
        IfCondition EqualTo(needs_slash, 1) ThenBlock: {
            SetByte(path, i, 47)
            i = Add(i, 1)
        }
        
        j = 0
        WhileLoop LessThan(j, file_len) {
            SetByte(path, i, GetByte(file, j))
            i = Add(i, 1)
            j = Add(j, 1)
        }
        
        SetByte(path, i, 0)
        ReturnValue(path)
    }
}

Function.GetBasename {
    Input: path: Address
    Output: Address
    Body: {
        len = StringLength(path)
        
        real_len = len
        WhileLoop And(GreaterThan(real_len, 0), 
                     EqualTo(GetByte(path, Subtract(real_len, 1)), 47)) {
            real_len = Subtract(real_len, 1)
        }
        
        last_slash = -1
        i = 0
        WhileLoop LessThan(i, real_len) {
            IfCondition EqualTo(GetByte(path, i), 47) ThenBlock: {
                last_slash = i
            }
            i = Add(i, 1)
        }
        
        start = Add(last_slash, 1)
        basename_len = Subtract(real_len, start)
        
        IfCondition EqualTo(basename_len, 0) ThenBlock: {
            basename = Allocate(2)
            SetByte(basename, 0, 47)
            SetByte(basename, 1, 0)
            ReturnValue(basename)
        }
        
        basename = Allocate(Add(basename_len, 1))
        i = 0
        WhileLoop LessThan(i, basename_len) {
            SetByte(basename, i, GetByte(path, Add(start, i)))
            i = Add(i, 1)
        }
        SetByte(basename, basename_len, 0)
        
        ReturnValue(basename)
    }
}

Function.GetErrorString {
    Input: errno: Integer
    Output: Address
    Body: {
        abs_errno = errno
        IfCondition LessThan(errno, 0) ThenBlock: {
            abs_errno = Subtract(0, errno)
        }
        
        IfCondition EqualTo(abs_errno, MvConstants.EEXIST) ThenBlock: {
            ReturnValue("File exists")
        }
        
        IfCondition EqualTo(abs_errno, MvConstants.ENOENT) ThenBlock: {
            ReturnValue("No such file or directory")
        }
        
        IfCondition EqualTo(abs_errno, MvConstants.EACCES) ThenBlock: {
            ReturnValue("Permission denied")
        }
        
        IfCondition EqualTo(abs_errno, MvConstants.EXDEV) ThenBlock: {
            ReturnValue("Invalid cross-device link")
        }
        
        IfCondition EqualTo(abs_errno, MvConstants.EISDIR) ThenBlock: {
            ReturnValue("Is a directory")
        }
        
        IfCondition EqualTo(abs_errno, MvConstants.ENOTDIR) ThenBlock: {
            ReturnValue("Not a directory")
        }
        
        ReturnValue("Unknown error")
    }
}

Function.PromptUser {
    Input: prompt: Address
    Output: Integer
    Body: {
        WriteStderr(prompt)
        
        response = Allocate(8)
        bytes = SystemCall(0, 0, response, 8)
        
        IfCondition LessEqual(bytes, 0) ThenBlock: {
            Deallocate(response, 8)
            ReturnValue(0)
        }
        
        ch = GetByte(response, 0)
        Deallocate(response, 8)
        
        result = Or(EqualTo(ch, 121), EqualTo(ch, 89))
        ReturnValue(result)
    }
}

// ============================================================================
// COPY AND REMOVE (for cross-device moves)
// ============================================================================

Function.DuplicateFile {
    Input: source: Address
    Input: dest: Address
    Output: Integer
    Body: {
        src_fd = SystemCall(2, source, MvConstants.O_RDONLY, 0)
        IfCondition LessThan(src_fd, 0) ThenBlock: {
            WriteStderr("mv: cannot open '")
            WriteStderr(source)
            WriteStderr("': ")
            WriteStderr(GetErrorString(src_fd))
            WriteStderr("\n")
            ReturnValue(1)
        }
        
        mode = GetFileMode(source)
        
        flags = BitwiseOr(MvConstants.O_WRONLY, MvConstants.O_CREAT)
        flags = BitwiseOr(flags, MvConstants.O_TRUNC)
        
        dst_fd = SystemCall(2, dest, flags, mode)
        IfCondition LessThan(dst_fd, 0) ThenBlock: {
            WriteStderr("mv: cannot create '")
            WriteStderr(dest)
            WriteStderr("': ")
            WriteStderr(GetErrorString(dst_fd))
            WriteStderr("\n")
            SystemCall(3, src_fd)
            ReturnValue(1)
        }
        
        buffer = Allocate(MvConstants.BUFFER_SIZE)
        
        WhileLoop 1 {
            bytes_read = SystemCall(0, src_fd, buffer, MvConstants.BUFFER_SIZE)
            
            IfCondition LessEqual(bytes_read, 0) ThenBlock: {
                BreakLoop
            }
            
            bytes_written = SystemCall(1, dst_fd, buffer, bytes_read)
            
            IfCondition NotEqual(bytes_written, bytes_read) ThenBlock: {
                WriteStderr("mv: write error\n")
                Deallocate(buffer, MvConstants.BUFFER_SIZE)
                SystemCall(3, src_fd)
                SystemCall(3, dst_fd)
                ReturnValue(1)
            }
        }
        
        Deallocate(buffer, MvConstants.BUFFER_SIZE)
        SystemCall(3, src_fd)
        SystemCall(3, dst_fd)
        
        ReturnValue(0)
    }
}

// ============================================================================
// CORE MOVE FUNCTION
// ============================================================================

Function.RelocateFile {
    Input: source: Address
    Input: dest: Address
    Output: Integer
    Body: {
        dest_exists = PathExists(dest)
        
        IfCondition EqualTo(dest_exists, 1) ThenBlock: {
            IfCondition EqualTo(MvConfig.no_clobber, 1) ThenBlock: {
                IfCondition EqualTo(MvConfig.verbose, 1) ThenBlock: {
                    WriteStderr("skipped '")
                    WriteStderr(dest)
                    WriteStderr("' (already exists)\n")
                }
                MvStats.skipped = Add(MvStats.skipped, 1)
                ReturnValue(0)
            }
            
            IfCondition EqualTo(MvConfig.update, 1) ThenBlock: {
                src_mtime = GetModTime(source)
                dst_mtime = GetModTime(dest)
                
                IfCondition LessEqual(src_mtime, dst_mtime) ThenBlock: {
                    IfCondition EqualTo(MvConfig.verbose, 1) ThenBlock: {
                        WriteStderr("skipped '")
                        WriteStderr(dest)
                        WriteStderr("' (up to date)\n")
                    }
                    MvStats.skipped = Add(MvStats.skipped, 1)
                    ReturnValue(0)
                }
            }
            
            IfCondition EqualTo(MvConfig.interactive, 1) ThenBlock: {
                WriteStderr("mv: overwrite '")
                WriteStderr(dest)
                WriteStderr("'? ")
                
                response = PromptUser("")
                IfCondition EqualTo(response, 0) ThenBlock: {
                    MvStats.skipped = Add(MvStats.skipped, 1)
                    ReturnValue(0)
                }
            }
        }
        
        result = SystemCall(82, source, dest)
        
        IfCondition GreaterEqual(result, 0) ThenBlock: {
            MvStats.moved = Add(MvStats.moved, 1)
            
            IfCondition EqualTo(MvConfig.verbose, 1) ThenBlock: {
                WriteStderr("'")
                WriteStderr(source)
                WriteStderr("' -> '")
                WriteStderr(dest)
                WriteStderr("'\n")
            }
            
            ReturnValue(0)
        }
        
        abs_error = Subtract(0, result)
        
        IfCondition EqualTo(abs_error, MvConstants.EXDEV) ThenBlock: {
            copy_result = DuplicateFile(source, dest)
            
            IfCondition EqualTo(copy_result, 0) ThenBlock: {
                unlink_result = SystemCall(87, source)
                
                IfCondition LessThan(unlink_result, 0) ThenBlock: {
                    WriteStderr("mv: cannot remove '")
                    WriteStderr(source)
                    WriteStderr("': ")
                    WriteStderr(GetErrorString(unlink_result))
                    WriteStderr("\n")
                    MvStats.errors = Add(MvStats.errors, 1)
                    ReturnValue(1)
                }
                
                MvStats.moved = Add(MvStats.moved, 1)
                
                IfCondition EqualTo(MvConfig.verbose, 1) ThenBlock: {
                    WriteStderr("'")
                    WriteStderr(source)
                    WriteStderr("' -> '")
                    WriteStderr(dest)
                    WriteStderr("' (copied across devices)\n")
                }
                
                ReturnValue(0)
            }
            
            ReturnValue(1)
        }
        
        WriteStderr("mv: cannot move '")
        WriteStderr(source)
        WriteStderr("' to '")
        WriteStderr(dest)
        WriteStderr("': ")
        WriteStderr(GetErrorString(result))
        WriteStderr("\n")
        
        MvStats.errors = Add(MvStats.errors, 1)
        ReturnValue(1)
    }
}

// ============================================================================
// ARGUMENT PARSING
// ============================================================================

Function.GetArgs {
    Output: Address
    Body: {
        fd = SystemCall(257, -100, "/proc/self/cmdline", 0, 0)
        IfCondition LessThan(fd, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        buffer = Allocate(4096)
        bytes_read = SystemCall(0, fd, buffer, 4096)
        SystemCall(3, fd)
        
        IfCondition LessEqual(bytes_read, 0) ThenBlock: {
            Deallocate(buffer, 4096)
            ReturnValue(0)
        }
        
        ReturnValue(buffer)
    }
}

Function.StringCompare {
    Input: str1: Address
    Input: str2: Address
    Output: Integer
    Body: {
        i = 0
        WhileLoop 1 {
            ch1 = GetByte(str1, i)
            ch2 = GetByte(str2, i)
            
            IfCondition NotEqual(ch1, ch2) ThenBlock: {
                ReturnValue(0)
            }
            
            IfCondition EqualTo(ch1, 0) ThenBlock: {
                ReturnValue(1)
            }
            
            i = Add(i, 1)
        }
        ReturnValue(1)
    }
}

Function.ShowHelp {
    Body: {
        WriteStdout("Usage: mv [OPTION]... SOURCE... DIRECTORY\n")
        WriteStdout("  or:  mv [OPTION]... SOURCE DEST\n")
        WriteStdout("Rename SOURCE to DEST, or move SOURCE(s) to DIRECTORY.\n")
        WriteStdout("\n")
        WriteStdout("Mandatory arguments to long options are mandatory for short options too.\n")
        WriteStdout("  -f, --force              do not prompt before overwriting\n")
        WriteStdout("  -i, --interactive        prompt before overwrite\n")
        WriteStdout("  -n, --no-clobber         do not overwrite an existing file\n")
        WriteStdout("  -u, --update             move only when the SOURCE file is newer\n")
        WriteStdout("                             than the destination file or when the\n")
        WriteStdout("                             destination file is missing\n")
        WriteStdout("  -v, --verbose            explain what is being done\n")
        WriteStdout("      --help               display this help and exit\n")
        WriteStdout("      --version            output version information and exit\n")
        WriteStdout("\n")
        WriteStdout("The backup suffix is '~', unless set with --suffix or SIMPLE_BACKUP_SUFFIX.\n")
        WriteStdout("\n")
        WriteStdout("GNU coreutils compatible mv implementation in AiLang.\n")
    }
}

Function.ShowVersion {
    Body: {
        WriteStdout("mv (AiLang coreutils) 1.0\n")
        WriteStdout("Copyright (C) 2025 AiLang Project\n")
        WriteStdout("License: MIT\n")
        WriteStdout("\n")
        WriteStdout("Written in AiLang - A language designed for human and LLM comprehension.\n")
    }
}

// ============================================================================
// MAIN ROUTINE
// ============================================================================

SubRoutine.Main {
    args_buffer = GetArgs()
    
    IfCondition EqualTo(args_buffer, 0) ThenBlock: {
        WriteStderr("mv: failed to read arguments\n")
        SystemCall(60, 1)
    }
    
    pos = 0
    WhileLoop NotEqual(GetByte(args_buffer, pos), 0) {
        pos = Add(pos, 1)
    }
    pos = Add(pos, 1)
    
    max_sources = 256
    sources = ArrayCreate(max_sources)
    source_count = 0
    
    WhileLoop LessThan(pos, 4096) {
        ch = GetByte(args_buffer, pos)
        IfCondition EqualTo(ch, 0) ThenBlock: {
            BreakLoop
        }
        
        first = GetByte(args_buffer, pos)
        
        IfCondition EqualTo(first, 45) ThenBlock: {
            arg_start = pos
            arg_len = 0
            
            WhileLoop And(LessThan(pos, 4096), NotEqual(GetByte(args_buffer, pos), 0)) {
                arg_len = Add(arg_len, 1)
                pos = Add(pos, 1)
            }
            
            flag = Allocate(Add(arg_len, 1))
            i = 0
            WhileLoop LessThan(i, arg_len) {
                SetByte(flag, i, GetByte(args_buffer, Add(arg_start, i)))
                i = Add(i, 1)
            }
            SetByte(flag, arg_len, 0)
            
            IfCondition StringCompare(flag, "--help") ThenBlock: {
                ShowHelp()
                Deallocate(flag, Add(arg_len, 1))
                ArrayDestroy(sources)
                Deallocate(args_buffer, 4096)
                SystemCall(60, 0)
            }
            
            IfCondition StringCompare(flag, "--version") ThenBlock: {
                ShowVersion()
                Deallocate(flag, Add(arg_len, 1))
                ArrayDestroy(sources)
                Deallocate(args_buffer, 4096)
                SystemCall(60, 0)
            }
            
            IfCondition StringCompare(flag, "--force") ThenBlock: {
                MvConfig.force = 1
                MvConfig.interactive = 0
            }
            
            IfCondition StringCompare(flag, "--interactive") ThenBlock: {
                MvConfig.interactive = 1
            }
            
            IfCondition StringCompare(flag, "--no-clobber") ThenBlock: {
                MvConfig.no_clobber = 1
            }
            
            IfCondition StringCompare(flag, "--verbose") ThenBlock: {
                MvConfig.verbose = 1
            }
            
            IfCondition StringCompare(flag, "--update") ThenBlock: {
                MvConfig.update = 1
            }
            
            i = 1
            WhileLoop LessThan(i, arg_len) {
                flag_char = GetByte(flag, i)
                
                IfCondition EqualTo(flag_char, 102) ThenBlock: {
                    MvConfig.force = 1
                    MvConfig.interactive = 0
                }
                
                IfCondition EqualTo(flag_char, 105) ThenBlock: {
                    MvConfig.interactive = 1
                }
                
                IfCondition EqualTo(flag_char, 110) ThenBlock: {
                    MvConfig.no_clobber = 1
                }
                
                IfCondition EqualTo(flag_char, 118) ThenBlock: {
                    MvConfig.verbose = 1
                }
                
                IfCondition EqualTo(flag_char, 117) ThenBlock: {
                    MvConfig.update = 1
                }
                
                i = Add(i, 1)
            }
            
            Deallocate(flag, Add(arg_len, 1))
        } ElseBlock: {
            arg_start = pos
            arg_len = 0
            
            WhileLoop And(LessThan(pos, 4096), NotEqual(GetByte(args_buffer, pos), 0)) {
                arg_len = Add(arg_len, 1)
                pos = Add(pos, 1)
            }
            
            filename = Allocate(Add(arg_len, 1))
            i = 0
            WhileLoop LessThan(i, arg_len) {
                SetByte(filename, i, GetByte(args_buffer, Add(arg_start, i)))
                i = Add(i, 1)
            }
            SetByte(filename, arg_len, 0)
            
            IfCondition LessThan(source_count, max_sources) ThenBlock: {
                ArraySet(sources, source_count, filename)
                source_count = Add(source_count, 1)
            }
        }
        
        pos = Add(pos, 1)
    }
    
    Deallocate(args_buffer, 4096)
    
    IfCondition LessThan(source_count, 2) ThenBlock: {
        WriteStderr("mv: missing operand")
        IfCondition EqualTo(source_count, 1) ThenBlock: {
            WriteStderr(" after '")
            source = ArrayGet(sources, 0)
            WriteStderr(source)
            WriteStderr("'")
        }
        WriteStderr("\n")
        WriteStderr("Try 'mv --help' for more information.\n")
        ArrayDestroy(sources)
        SystemCall(60, 1)
    }
    
    last_arg = ArrayGet(sources, Subtract(source_count, 1))
    is_dir = IsDirectory(last_arg)
    
    IfCondition GreaterThan(source_count, 2) ThenBlock: {
        IfCondition EqualTo(is_dir, 0) ThenBlock: {
            WriteStderr("mv: target '")
            WriteStderr(last_arg)
            WriteStderr("' is not a directory\n")
            ArrayDestroy(sources)
            SystemCall(60, 1)
        }
        
        i = 0
        WhileLoop LessThan(i, Subtract(source_count, 1)) {
            source = ArrayGet(sources, i)
            basename = GetBasename(source)
            dest = BuildPath(last_arg, basename)
            
            result = RelocateFile(source, dest)
            
            Deallocate(basename, 0)
            Deallocate(dest, 0)
            Deallocate(source, 0)
            i = Add(i, 1)
        }
    } ElseBlock: {
        source = ArrayGet(sources, 0)
        dest = ArrayGet(sources, 1)
        
        IfCondition EqualTo(is_dir, 1) ThenBlock: {
            basename = GetBasename(source)
            final_dest = BuildPath(dest, basename)
            result = RelocateFile(source, final_dest)
            Deallocate(basename, 0)
            Deallocate(final_dest, 0)
        } ElseBlock: {
            result = RelocateFile(source, dest)
        }
        
        Deallocate(source, 0)
        Deallocate(dest, 0)
    }
    
    ArrayDestroy(sources)
    
    IfCondition EqualTo(MvConfig.verbose, 1) ThenBlock: {
        IfCondition GreaterThan(source_count, 2) ThenBlock: {
            WriteStderr("\nðŸ“Š Summary:\n")
            WriteStderr("  Moved: ")
            sum_str = IntToString(MvStats.moved)
            WriteStderr(sum_str)
            Deallocate(sum_str, 0)
            WriteStderr("\n  Skipped: ")
            sum_str = IntToString(MvStats.skipped)
            WriteStderr(sum_str)
            Deallocate(sum_str, 0)
            WriteStderr("\n  Errors: ")
            sum_str = IntToString(MvStats.errors)
            WriteStderr(sum_str)
            Deallocate(sum_str, 0)
            WriteStderr("\n")
        }
    }
    
    exit_code = 0
    IfCondition GreaterThan(MvStats.errors, 0) ThenBlock: {
        exit_code = 1
    }
    
    SystemCall(60, exit_code)
}

RunTask(Main)