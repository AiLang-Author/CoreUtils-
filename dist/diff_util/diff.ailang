// diff.ailang - GNU-Compatible File Comparison Utility
// Usage: diff [OPTION]... FILES
// Compare FILES line by line.
//
// Options:
//   -q, --brief              report only when files differ
//   -u, -U NUM               output NUM (default 3) lines of unified context
//   -i, --ignore-case        ignore case differences
//   -w, --ignore-all-space   ignore all white space
//   -b, --ignore-space-change ignore changes in the amount of white space
//   -B, --ignore-blank-lines ignore changes whose lines are all blank
//   --help                   display this help and exit
//   --version                output version information and exit

FixedPool.DiffConfig {
    "brief": Initialize=0
    "unified": Initialize=0
    "context_lines": Initialize=3
    "ignore_case": Initialize=0
    "ignore_space": Initialize=0
    "ignore_space_change": Initialize=0
    "ignore_blank_lines": Initialize=0
}

FixedPool.DiffConstants {
    "MAX_LINES": Initialize=100000
    "MAX_LINE_LEN": Initialize=8192
}

// ============================================================================
// UTILITY FUNCTIONS
// ============================================================================

Function.WriteStdout {
    Input: str: Address
    Body: {
        len = StringLength(str)
        SystemCall(1, 1, str, len)
    }
}

Function.WriteStderr {
    Input: str: Address
    Body: {
        len = StringLength(str)
        SystemCall(1, 2, str, len)
    }
}

Function.IntToString {
    Input: num: Integer
    Output: Address
    Body: {
        IfCondition EqualTo(num, 0) ThenBlock: {
            str = Allocate(2)
            SetByte(str, 0, 48)
            SetByte(str, 1, 0)
            ReturnValue(str)
        }
        
        is_negative = LessThan(num, 0)
        abs_num = num
        IfCondition EqualTo(is_negative, 1) ThenBlock: {
            abs_num = Subtract(0, num)
        }
        
        temp = abs_num
        digits = 0
        WhileLoop GreaterThan(temp, 0) {
            temp = Divide(temp, 10)
            digits = Add(digits, 1)
        }
        
        total_len = digits
        IfCondition EqualTo(is_negative, 1) ThenBlock: {
            total_len = Add(total_len, 1)
        }
        
        str = Allocate(Add(total_len, 1))
        
        pos = 0
        IfCondition EqualTo(is_negative, 1) ThenBlock: {
            SetByte(str, 0, 45)
            pos = 1
        }
        
        i = Subtract(total_len, 1)
        temp = abs_num
        WhileLoop GreaterThan(temp, 0) {
            digit = Modulo(temp, 10)
            SetByte(str, i, Add(48, digit))
            temp = Divide(temp, 10)
            i = Subtract(i, 1)
        }
        
        SetByte(str, total_len, 0)
        ReturnValue(str)
    }
}

Function.CopyBytes {
    Input: dest: Address
    Input: src: Address
    Input: len: Integer
    Body: {
        i = 0
        WhileLoop LessThan(i, len) {
            b = GetByte(src, i)
            SetByte(dest, i, b)
            i = Add(i, 1)
        }
    }
}

Function.ToLower {
    Input: ch: Integer
    Output: Integer
    Body: {
        IfCondition And(GreaterEqual(ch, 65), LessEqual(ch, 90)) ThenBlock: {
            ReturnValue(Add(ch, 32))
        }
        ReturnValue(ch)
    }
}

Function.IsWhitespace {
    Input: ch: Integer
    Output: Integer
    Body: {
        is_space = EqualTo(ch, 32)
        is_tab = EqualTo(ch, 9)
        is_newline = EqualTo(ch, 10)
        is_return = EqualTo(ch, 13)
        
        ReturnValue(Or(Or(is_space, is_tab), Or(is_newline, is_return)))
    }
}

Function.IsBlankLine {
    Input: line: Address
    Output: Integer
    Body: {
        i = 0
        WhileLoop 1 {
            ch = GetByte(line, i)
            
            IfCondition EqualTo(ch, 0) ThenBlock: {
                ReturnValue(1)
            }
            
            is_ws = IsWhitespace(ch)
            IfCondition EqualTo(is_ws, 0) ThenBlock: {
                ReturnValue(0)
            }
            
            i = Add(i, 1)
        }
        ReturnValue(1)
    }
}

Function.LinesEqual {
    Input: line1: Address
    Input: line2: Address
    Output: Integer
    Body: {
        i = 0
        j = 0
        
        IfCondition EqualTo(DiffConfig.ignore_space, 1) ThenBlock: {
            WhileLoop 1 {
                ch1 = GetByte(line1, i)
                ch2 = GetByte(line2, j)
                
                is_ws1 = IsWhitespace(ch1)
                WhileLoop And(EqualTo(is_ws1, 1), NotEqual(ch1, 0)) {
                    i = Add(i, 1)
                    ch1 = GetByte(line1, i)
                    is_ws1 = IsWhitespace(ch1)
                }
                
                is_ws2 = IsWhitespace(ch2)
                WhileLoop And(EqualTo(is_ws2, 1), NotEqual(ch2, 0)) {
                    j = Add(j, 1)
                    ch2 = GetByte(line2, j)
                    is_ws2 = IsWhitespace(ch2)
                }
                
                IfCondition EqualTo(DiffConfig.ignore_case, 1) ThenBlock: {
                    ch1 = ToLower(ch1)
                    ch2 = ToLower(ch2)
                }
                
                IfCondition NotEqual(ch1, ch2) ThenBlock: {
                    ReturnValue(0)
                }
                
                IfCondition EqualTo(ch1, 0) ThenBlock: {
                    ReturnValue(1)
                }
                
                i = Add(i, 1)
                j = Add(j, 1)
            }
        } ElseBlock: {
            WhileLoop 1 {
                ch1 = GetByte(line1, i)
                ch2 = GetByte(line2, i)
                
                IfCondition EqualTo(DiffConfig.ignore_case, 1) ThenBlock: {
                    ch1 = ToLower(ch1)
                    ch2 = ToLower(ch2)
                }
                
                IfCondition NotEqual(ch1, ch2) ThenBlock: {
                    ReturnValue(0)
                }
                
                IfCondition EqualTo(ch1, 0) ThenBlock: {
                    ReturnValue(1)
                }
                
                i = Add(i, 1)
            }
        }
        
        ReturnValue(1)
    }
}

// ============================================================================
// FILE READING
// ============================================================================

Function.ReadFileLines {
    Input: filename: Address
    Output: Address
    Body: {
        fd = SystemCall(2, filename, 0, 0)
        IfCondition LessThan(fd, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        lines = ArrayCreate(DiffConstants.MAX_LINES)
        line_count = 0
        
        buffer = Allocate(65536)
        line_buffer = Allocate(DiffConstants.MAX_LINE_LEN)
        line_pos = 0
        
        WhileLoop 1 {
            bytes_read = SystemCall(0, fd, buffer, 65536)
            IfCondition LessEqual(bytes_read, 0) ThenBlock: {
                IfCondition GreaterThan(line_pos, 0) ThenBlock: {
                    line = Allocate(Add(line_pos, 1))
                    MemCopy(line, line_buffer, line_pos)
                    SetByte(line, line_pos, 0)
                    ArraySet(lines, line_count, line)
                    line_count = Add(line_count, 1)
                }
                BreakLoop
            }
            
            i = 0
            WhileLoop LessThan(i, bytes_read) {
                ch = GetByte(buffer, i)
                
                IfCondition EqualTo(ch, 10) ThenBlock: {
                    line = Allocate(Add(line_pos, 1))
                    MemCopy(line, line_buffer, line_pos)
                    SetByte(line, line_pos, 0)
                    ArraySet(lines, line_count, line)
                    line_count = Add(line_count, 1)
                    line_pos = 0
                } ElseBlock: {
                    IfCondition LessThan(line_pos, Subtract(DiffConstants.MAX_LINE_LEN, 1)) ThenBlock: {
                        SetByte(line_buffer, line_pos, ch)
                        line_pos = Add(line_pos, 1)
                    }
                }
                
                i = Add(i, 1)
            }
        }
        
        Deallocate(line_buffer, DiffConstants.MAX_LINE_LEN)
        Deallocate(buffer, 65536)
        SystemCall(3, fd)
        
        result = Allocate(16)
        StoreValue(result, line_count)
        StoreValue(Add(result, 8), lines)
        ReturnValue(result)
    }
}

// ============================================================================
// DIFF ALGORITHMS
// ============================================================================

Function.ComputeLCS {
    Input: lines1: Address
    Input: count1: Integer
    Input: lines2: Address
    Input: count2: Integer
    Output: Address
    Body: {
        rows = Add(count1, 1)
        cols = Add(count2, 1)
        table_size = Multiply(rows, cols)
        
        lcs_table = Allocate(Multiply(table_size, 8))
        
        i = 0
        WhileLoop LessThan(i, table_size) {
            StoreValue(Add(lcs_table, Multiply(i, 8)), 0)
            i = Add(i, 1)
        }
        
        i = 1
        WhileLoop LessEqual(i, count1) {
            j = 1
            WhileLoop LessEqual(j, count2) {
                line1 = ArrayGet(lines1, Subtract(i, 1))
                line2 = ArrayGet(lines2, Subtract(j, 1))
                
                equal = LinesEqual(line1, line2)
                
                IfCondition EqualTo(equal, 1) ThenBlock: {
                    idx = Add(Multiply(Subtract(i, 1), cols), Subtract(j, 1))
                    prev_val = Dereference(Add(lcs_table, Multiply(idx, 8)))
                    
                    curr_idx = Add(Multiply(i, cols), j)
                    StoreValue(Add(lcs_table, Multiply(curr_idx, 8)), Add(prev_val, 1))
                } ElseBlock: {
                    left_idx = Add(Multiply(i, cols), Subtract(j, 1))
                    left_val = Dereference(Add(lcs_table, Multiply(left_idx, 8)))
                    
                    top_idx = Add(Multiply(Subtract(i, 1), cols), j)
                    top_val = Dereference(Add(lcs_table, Multiply(top_idx, 8)))
                    
                    max_val = left_val
                    IfCondition GreaterThan(top_val, left_val) ThenBlock: {
                        max_val = top_val
                    }
                    
                    curr_idx = Add(Multiply(i, cols), j)
                    StoreValue(Add(lcs_table, Multiply(curr_idx, 8)), max_val)
                }
                
                j = Add(j, 1)
            }
            i = Add(i, 1)
        }
        
        ReturnValue(lcs_table)
    }
}

// ============================================================================
// OUTPUT FORMATS
// ============================================================================

Function.PrintUnifiedDiff {
    Input: file1: Address
    Input: file2: Address
    Input: lines1: Address
    Input: count1: Integer
    Input: lines2: Address
    Input: count2: Integer
    Body: {
        WriteStdout("--- ")
        WriteStdout(file1)
        WriteStdout("\n")
        WriteStdout("+++ ")
        WriteStdout(file2)
        WriteStdout("\n")
        
        i = 0
        j = 0
        
        WhileLoop Or(LessThan(i, count1), LessThan(j, count2)) {
            IfCondition And(LessThan(i, count1), LessThan(j, count2)) ThenBlock: {
                line1 = ArrayGet(lines1, i)
                line2 = ArrayGet(lines2, j)
                equal = LinesEqual(line1, line2)
                
                IfCondition EqualTo(equal, 1) ThenBlock: {
                    WriteStdout(" ")
                    WriteStdout(line1)
                    WriteStdout("\n")
                    i = Add(i, 1)
                    j = Add(j, 1)
                } ElseBlock: {
                    WriteStdout("-")
                    WriteStdout(line1)
                    WriteStdout("\n")
                    WriteStdout("+")
                    WriteStdout(line2)
                    WriteStdout("\n")
                    i = Add(i, 1)
                    j = Add(j, 1)
                }
            } ElseBlock: {
                IfCondition LessThan(i, count1) ThenBlock: {
                    line1 = ArrayGet(lines1, i)
                    WriteStdout("-")
                    WriteStdout(line1)
                    WriteStdout("\n")
                    i = Add(i, 1)
                } ElseBlock: {
                    line2 = ArrayGet(lines2, j)
                    WriteStdout("+")
                    WriteStdout(line2)
                    WriteStdout("\n")
                    j = Add(j, 1)
                }
            }
        }
    }
}

Function.PrintNormalDiff {
    Input: lines1: Address
    Input: count1: Integer
    Input: lines2: Address
    Input: count2: Integer
    Body: {
        i = 0
        j = 0
        
        WhileLoop Or(LessThan(i, count1), LessThan(j, count2)) {
            IfCondition And(LessThan(i, count1), LessThan(j, count2)) ThenBlock: {
                line1 = ArrayGet(lines1, i)
                line2 = ArrayGet(lines2, j)
                equal = LinesEqual(line1, line2)
                
                IfCondition EqualTo(equal, 0) ThenBlock: {
                    num_str = IntToString(Add(i, 1))
                    WriteStdout(num_str)
                    Deallocate(num_str, 0)
                    WriteStdout("c")
                    num_str = IntToString(Add(j, 1))
                    WriteStdout(num_str)
                    Deallocate(num_str, 0)
                    WriteStdout("\n")
                    
                    WriteStdout("< ")
                    WriteStdout(line1)
                    WriteStdout("\n")
                    WriteStdout("---\n")
                    WriteStdout("> ")
                    WriteStdout(line2)
                    WriteStdout("\n")
                    
                    i = Add(i, 1)
                    j = Add(j, 1)
                } ElseBlock: {
                    i = Add(i, 1)
                    j = Add(j, 1)
                }
            } ElseBlock: {
                IfCondition LessThan(i, count1) ThenBlock: {
                    num_str = IntToString(Add(i, 1))
                    WriteStdout(num_str)
                    Deallocate(num_str, 0)
                    WriteStdout("d")
                    num_str = IntToString(j)
                    WriteStdout(num_str)
                    Deallocate(num_str, 0)
                    WriteStdout("\n")
                    
                    line1 = ArrayGet(lines1, i)
                    WriteStdout("< ")
                    WriteStdout(line1)
                    WriteStdout("\n")
                    
                    i = Add(i, 1)
                } ElseBlock: {
                    num_str = IntToString(i)
                    WriteStdout(num_str)
                    Deallocate(num_str, 0)
                    WriteStdout("a")
                    num_str = IntToString(Add(j, 1))
                    WriteStdout(num_str)
                    Deallocate(num_str, 0)
                    WriteStdout("\n")
                    
                    line2 = ArrayGet(lines2, j)
                    WriteStdout("> ")
                    WriteStdout(line2)
                    WriteStdout("\n")
                    
                    j = Add(j, 1)
                }
            }
        }
    }
}

// ============================================================================
// ARGUMENT PARSING
// ============================================================================

Function.GetArgs {
    Output: Address
    Body: {
        fd = SystemCall(257, -100, "/proc/self/cmdline", 0, 0)
        IfCondition LessThan(fd, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        buffer = Allocate(4096)
        bytes_read = SystemCall(0, fd, buffer, 4096)
        SystemCall(3, fd)
        
        IfCondition LessEqual(bytes_read, 0) ThenBlock: {
            Deallocate(buffer, 4096)
            ReturnValue(0)
        }
        
        ReturnValue(buffer)
    }
}

Function.StringCompare {
    Input: str1: Address
    Input: str2: Address
    Output: Integer
    Body: {
        i = 0
        WhileLoop 1 {
            ch1 = GetByte(str1, i)
            ch2 = GetByte(str2, i)
            
            IfCondition NotEqual(ch1, ch2) ThenBlock: {
                ReturnValue(0)
            }
            
            IfCondition EqualTo(ch1, 0) ThenBlock: {
                ReturnValue(1)
            }
            
            i = Add(i, 1)
        }
        ReturnValue(1)
    }
}

Function.ShowHelp {
    Body: {
        WriteStdout("Usage: diff [OPTION]... FILES\n")
        WriteStdout("Compare FILES line by line.\n")
        WriteStdout("\n")
        WriteStdout("  -q, --brief              report only when files differ\n")
        WriteStdout("  -u, -U NUM               output NUM (default 3) lines of unified context\n")
        WriteStdout("  -i, --ignore-case        ignore case differences in file contents\n")
        WriteStdout("  -w, --ignore-all-space   ignore all white space\n")
        WriteStdout("  -b, --ignore-space-change ignore changes in the amount of white space\n")
        WriteStdout("  -B, --ignore-blank-lines ignore changes where lines are all blank\n")
        WriteStdout("      --help               display this help and exit\n")
        WriteStdout("      --version            output version information and exit\n")
        WriteStdout("\n")
        WriteStdout("FILES are 'FILE1 FILE2'.\n")
        WriteStdout("\n")
        WriteStdout("If a FILE is '-', read standard input.\n")
        WriteStdout("\n")
        WriteStdout("Exit status is 0 if inputs are the same, 1 if different, 2 if trouble.\n")
        WriteStdout("\n")
        WriteStdout("GNU coreutils compatible diff implementation in AiLang.\n")
    }
}

Function.ShowVersion {
    Body: {
        WriteStdout("diff (AiLang coreutils) 1.0\n")
        WriteStdout("Copyright (C) 2025 AiLang Project\n")
        WriteStdout("License: MIT\n")
        WriteStdout("\n")
        WriteStdout("Written in AiLang - A language designed for human and LLM comprehension.\n")
    }
}

// ============================================================================
// MAIN ROUTINE
// ============================================================================

SubRoutine.Main {
    args_buffer = GetArgs()
    
    IfCondition EqualTo(args_buffer, 0) ThenBlock: {
        WriteStderr("diff: failed to read arguments\n")
        SystemCall(60, 2)
    }
    
    pos = 0
    WhileLoop NotEqual(GetByte(args_buffer, pos), 0) {
        pos = Add(pos, 1)
    }
    pos = Add(pos, 1)
    
    file1 = 0
    file2 = 0
    
    WhileLoop LessThan(pos, 4096) {
        ch = GetByte(args_buffer, pos)
        IfCondition EqualTo(ch, 0) ThenBlock: {
            BreakLoop
        }
        
        first = GetByte(args_buffer, pos)
        
        IfCondition EqualTo(first, 45) ThenBlock: {
            arg_start = pos
            arg_len = 0
            
            WhileLoop And(LessThan(pos, 4096), NotEqual(GetByte(args_buffer, pos), 0)) {
                arg_len = Add(arg_len, 1)
                pos = Add(pos, 1)
            }
            
            flag = Allocate(Add(arg_len, 1))
            i = 0
            WhileLoop LessThan(i, arg_len) {
                SetByte(flag, i, GetByte(args_buffer, Add(arg_start, i)))
                i = Add(i, 1)
            }
            SetByte(flag, arg_len, 0)
            
            IfCondition StringCompare(flag, "--help") ThenBlock: {
                ShowHelp()
                Deallocate(flag, Add(arg_len, 1))
                Deallocate(args_buffer, 4096)
                SystemCall(60, 0)
            }
            
            IfCondition StringCompare(flag, "--version") ThenBlock: {
                ShowVersion()
                Deallocate(flag, Add(arg_len, 1))
                Deallocate(args_buffer, 4096)
                SystemCall(60, 0)
            }
            
            IfCondition StringCompare(flag, "--brief") ThenBlock: {
                DiffConfig.brief = 1
            }
            
            IfCondition StringCompare(flag, "--ignore-case") ThenBlock: {
                DiffConfig.ignore_case = 1
            }
            
            IfCondition StringCompare(flag, "--ignore-all-space") ThenBlock: {
                DiffConfig.ignore_space = 1
            }
            
            second = GetByte(flag, 1)
            
            IfCondition EqualTo(second, 113) ThenBlock: {
                DiffConfig.brief = 1
            }
            
            IfCondition EqualTo(second, 117) ThenBlock: {
                DiffConfig.unified = 1
            }
            
            IfCondition EqualTo(second, 85) ThenBlock: {
                DiffConfig.unified = 1
            }
            
            IfCondition EqualTo(second, 105) ThenBlock: {
                DiffConfig.ignore_case = 1
            }
            
            IfCondition EqualTo(second, 119) ThenBlock: {
                DiffConfig.ignore_space = 1
            }
            
            IfCondition EqualTo(second, 98) ThenBlock: {
                DiffConfig.ignore_space_change = 1
            }
            
            IfCondition EqualTo(second, 66) ThenBlock: {
                DiffConfig.ignore_blank_lines = 1
            }
            
            Deallocate(flag, Add(arg_len, 1))
        } ElseBlock: {
            file_start = pos
            file_len = 0
            
            WhileLoop And(LessThan(pos, 4096), NotEqual(GetByte(args_buffer, pos), 0)) {
                file_len = Add(file_len, 1)
                pos = Add(pos, 1)
            }
            
            filename = Allocate(Add(file_len, 1))
            i = 0
            WhileLoop LessThan(i, file_len) {
                SetByte(filename, i, GetByte(args_buffer, Add(file_start, i)))
                i = Add(i, 1)
            }
            SetByte(filename, file_len, 0)
            
            IfCondition EqualTo(file1, 0) ThenBlock: {
                file1 = filename
            } ElseBlock: {
                file2 = filename
            }
        }
        
        pos = Add(pos, 1)
    }
    
    Deallocate(args_buffer, 4096)
    
    IfCondition Or(EqualTo(file1, 0), EqualTo(file2, 0)) ThenBlock: {
        WriteStderr("diff: missing operand after '")
        IfCondition NotEqual(file1, 0) ThenBlock: {
            WriteStderr(file1)
        }
        WriteStderr("'\n")
        WriteStderr("diff: Try 'diff --help' for more information.\n")
        SystemCall(60, 2)
    }
    
    result1 = ReadFileLines(file1)
    IfCondition EqualTo(result1, 0) ThenBlock: {
        WriteStderr("diff: ")
        WriteStderr(file1)
        WriteStderr(": No such file or directory\n")
        SystemCall(60, 2)
    }
    
    result2 = ReadFileLines(file2)
    IfCondition EqualTo(result2, 0) ThenBlock: {
        WriteStderr("diff: ")
        WriteStderr(file2)
        WriteStderr(": No such file or directory\n")
        SystemCall(60, 2)
    }
    
    count1 = Dereference(result1)
    lines1 = Dereference(Add(result1, 8))
    count2 = Dereference(result2)
    lines2 = Dereference(Add(result2, 8))
    
    IfCondition EqualTo(DiffConfig.brief, 1) ThenBlock: {
        different = 0
        
        IfCondition NotEqual(count1, count2) ThenBlock: {
            different = 1
        } ElseBlock: {
            i = 0
            WhileLoop LessThan(i, count1) {
                line1 = ArrayGet(lines1, i)
                line2 = ArrayGet(lines2, i)
                equal = LinesEqual(line1, line2)
                
                IfCondition EqualTo(equal, 0) ThenBlock: {
                    different = 1
                    BreakLoop
                }
                
                i = Add(i, 1)
            }
        }
        
        IfCondition EqualTo(different, 1) ThenBlock: {
            WriteStdout("Files ")
            WriteStdout(file1)
            WriteStdout(" and ")
            WriteStdout(file2)
            WriteStdout(" differ\n")
            SystemCall(60, 1)
        }
        
        SystemCall(60, 0)
    }
    
    IfCondition EqualTo(DiffConfig.unified, 1) ThenBlock: {
        PrintUnifiedDiff(file1, file2, lines1, count1, lines2, count2)
    } ElseBlock: {
        PrintNormalDiff(lines1, count1, lines2, count2)
    }
    
    identical = 1
    IfCondition NotEqual(count1, count2) ThenBlock: {
        identical = 0
    } ElseBlock: {
        i = 0
        WhileLoop LessThan(i, count1) {
            line1 = ArrayGet(lines1, i)
            line2 = ArrayGet(lines2, i)
            equal = LinesEqual(line1, line2)
            
            IfCondition EqualTo(equal, 0) ThenBlock: {
                identical = 0
                BreakLoop
            }
            
            i = Add(i, 1)
        }
    }
    
    IfCondition EqualTo(identical, 1) ThenBlock: {
        SystemCall(60, 0)
    } ElseBlock: {
        SystemCall(60, 1)
    }
}

RunTask(Main)