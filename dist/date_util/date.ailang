// date.ailang - Print current date and time (FULLY CORRECT)

Function.WriteStdout {
    Input: str: Address
    Body: {
        len = StringLength(str)
        SystemCall(1, 1, str, len)
    }
}

Function.WriteNumber {
    Input: num: Integer
    Input: width: Integer
    Body: {
        temp = num
        digits = 0
        
        IfCondition EqualTo(num, 0) ThenBlock: {
            digits = 1
        } ElseBlock: {
            WhileLoop GreaterThan(temp, 0) {
                temp = Divide(temp, 10)
                digits = Add(digits, 1)
            }
        }
        
        padding = Subtract(width, digits)
        WhileLoop GreaterThan(padding, 0) {
            WriteStdout("0")
            padding = Subtract(padding, 1)
        }
        
        IfCondition EqualTo(num, 0) ThenBlock: {
            WriteStdout("0")
            ReturnValue(0)
        }
        
        buffer = Allocate(16)
        count = 0
        temp = num
        
        WhileLoop GreaterThan(temp, 0) {
            digit = Modulo(temp, 10)
            SetByte(buffer, count, Add(48, digit))
            count = Add(count, 1)
            temp = Divide(temp, 10)
        }
        
        i = Subtract(count, 1)
        WhileLoop GreaterEqual(i, 0) {
            SystemCall(1, 1, Add(buffer, i), 1)
            i = Subtract(i, 1)
        }
        
        Deallocate(buffer, 16)
    }
}

Function.IsLeapYear {
    Input: year: Integer
    Output: Integer
    Body: {
        IfCondition NotEqual(Modulo(year, 4), 0) ThenBlock: {
            ReturnValue(0)
        }
        
        IfCondition EqualTo(Modulo(year, 100), 0) ThenBlock: {
            IfCondition NotEqual(Modulo(year, 400), 0) ThenBlock: {
                ReturnValue(0)
            }
        }
        
        ReturnValue(1)
    }
}

Function.DaysInMonth {
    Input: month: Integer
    Input: year: Integer
    Output: Integer
    Body: {
        IfCondition EqualTo(month, 2) ThenBlock: {
            is_leap = IsLeapYear(year)
            IfCondition EqualTo(is_leap, 1) ThenBlock: {
                ReturnValue(29)
            }
            ReturnValue(28)
        }
        
        IfCondition Or(EqualTo(month, 4), Or(EqualTo(month, 6), Or(EqualTo(month, 9), EqualTo(month, 11)))) ThenBlock: {
            ReturnValue(30)
        }
        
        ReturnValue(31)
    }
}

Function.GetMonthName {
    Input: month: Integer
    Output: Address
    Body: {
        IfCondition EqualTo(month, 1) ThenBlock: { ReturnValue("Jan") }
        IfCondition EqualTo(month, 2) ThenBlock: { ReturnValue("Feb") }
        IfCondition EqualTo(month, 3) ThenBlock: { ReturnValue("Mar") }
        IfCondition EqualTo(month, 4) ThenBlock: { ReturnValue("Apr") }
        IfCondition EqualTo(month, 5) ThenBlock: { ReturnValue("May") }
        IfCondition EqualTo(month, 6) ThenBlock: { ReturnValue("Jun") }
        IfCondition EqualTo(month, 7) ThenBlock: { ReturnValue("Jul") }
        IfCondition EqualTo(month, 8) ThenBlock: { ReturnValue("Aug") }
        IfCondition EqualTo(month, 9) ThenBlock: { ReturnValue("Sep") }
        IfCondition EqualTo(month, 10) ThenBlock: { ReturnValue("Oct") }
        IfCondition EqualTo(month, 11) ThenBlock: { ReturnValue("Nov") }
        ReturnValue("Dec")
    }
}

Function.GetDayName {
    Input: day_of_week: Integer
    Output: Address
    Body: {
        // 0=Sun, 1=Mon, 2=Tue, 3=Wed, 4=Thu, 5=Fri, 6=Sat
        IfCondition EqualTo(day_of_week, 0) ThenBlock: { ReturnValue("Sun") }
        IfCondition EqualTo(day_of_week, 1) ThenBlock: { ReturnValue("Mon") }
        IfCondition EqualTo(day_of_week, 2) ThenBlock: { ReturnValue("Tue") }
        IfCondition EqualTo(day_of_week, 3) ThenBlock: { ReturnValue("Wed") }
        IfCondition EqualTo(day_of_week, 4) ThenBlock: { ReturnValue("Thu") }
        IfCondition EqualTo(day_of_week, 5) ThenBlock: { ReturnValue("Fri") }
        ReturnValue("Sat")
    }
}

SubRoutine.Main {
    // Get Unix timestamp (UTC)
    timestamp_utc = SystemCall(201, 0)
    
    // Adjust for EST (UTC - 5 hours = -18000 seconds)
    timestamp = Subtract(timestamp_utc, 18000)
    
    // Calculate days since epoch
    days_since_epoch = Divide(timestamp, 86400)
    seconds_today = Modulo(timestamp, 86400)
    
    // Handle negative seconds (if time adjustment went backwards)
    IfCondition LessThan(seconds_today, 0) ThenBlock: {
        seconds_today = Add(seconds_today, 86400)
        days_since_epoch = Subtract(days_since_epoch, 1)
    }
    
    // Day of week: Jan 1, 1970 was Thursday (4)
    // So day 0 (Jan 1, 1970) should be 4
    day_of_week = Modulo(Add(days_since_epoch, 4), 7)
    
    // Time of day
    hours = Divide(seconds_today, 3600)
    minutes = Divide(Modulo(seconds_today, 3600), 60)
    seconds = Modulo(seconds_today, 60)
    
    // Calculate year, month, day
    year = 1970
    days_left = days_since_epoch
    
    // Count through years
    WhileLoop 1 {
        days_in_year = 365
        is_leap = IsLeapYear(year)
        IfCondition EqualTo(is_leap, 1) ThenBlock: {
            days_in_year = 366
        }
        
        IfCondition LessThan(days_left, days_in_year) ThenBlock: {
            BreakLoop
        }
        
        days_left = Subtract(days_left, days_in_year)
        year = Add(year, 1)
    }
    
    // Count through months
    month = 1
    WhileLoop LessEqual(month, 12) {
        days_in_month = DaysInMonth(month, year)
        
        IfCondition LessThan(days_left, days_in_month) ThenBlock: {
            BreakLoop
        }
        
        days_left = Subtract(days_left, days_in_month)
        month = Add(month, 1)
    }
    
    day = Add(days_left, 1)
    
    // Output: Thu Nov 14 22:55:30 EST 2025
    WriteStdout(GetDayName(day_of_week))
    WriteStdout(" ")
    WriteStdout(GetMonthName(month))
    WriteStdout(" ")
    WriteNumber(day, 2)
    WriteStdout(" ")
    WriteNumber(hours, 2)
    WriteStdout(":")
    WriteNumber(minutes, 2)
    WriteStdout(":")
    WriteNumber(seconds, 2)
    WriteStdout(" EST ")
    WriteNumber(year, 4)
    WriteStdout("\n")
    
    SystemCall(60, 0)
}

RunTask(Main)