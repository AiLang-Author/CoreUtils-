// echo.ailang - POSIX echo with GNU extensions
// Supports -n, -e, -E flags and escape sequences
// Target: <10KB binary, 100% compatibility

FixedPool.EchoConfig {
    "suppress_newline": Initialize=0
    "interpret_escapes": Initialize=0
    "stop_on_backslash_c": Initialize=0
}

FixedPool.EchoConstants {
    "BUFFER_SIZE": Initialize=4096
    "MAX_ARGS": Initialize=100
}

// === OUTPUT BUFFERING ===

FixedPool.OutputBuf {
    "buf": Initialize=0
    "pos": Initialize=0
    "cap": Initialize=4096
}

SubRoutine.InitBuffer {
    OutputBuf.buf = Allocate(OutputBuf.cap)
    OutputBuf.pos = 0
}

SubRoutine.FlushBuffer {
    IfCondition GreaterThan(OutputBuf.pos, 0) ThenBlock: {
        SystemCall(1, 1, OutputBuf.buf, OutputBuf.pos)
        OutputBuf.pos = 0
    }
}

Function.WriteBuffered {
    Input: str: Address
    Body: {
        // Cache length calculation
        len = 0
        WhileLoop NotEqual(GetByte(str, len), 0) {
            len = Add(len, 1)
        }
        
        remaining = Subtract(OutputBuf.cap, OutputBuf.pos)
        IfCondition GreaterThan(len, remaining) ThenBlock: {
            RunTask(FlushBuffer)
        }
        i = 0
        WhileLoop LessThan(i, len) {
            ch = GetByte(str, i)
            SetByte(OutputBuf.buf, Add(OutputBuf.pos, i), ch)
            i = Add(i, 1)
        }
        OutputBuf.pos = Add(OutputBuf.pos, len)
    }
}

Function.WriteChar {
    Input: ch: Integer
    Body: {
        remaining = Subtract(OutputBuf.cap, OutputBuf.pos)
        IfCondition LessEqual(remaining, 0) ThenBlock: {
            RunTask(FlushBuffer)
        }
        SetByte(OutputBuf.buf, OutputBuf.pos, ch)
        OutputBuf.pos = Add(OutputBuf.pos, 1)
    }
}

// === STRING UTILITIES ===

Function.StrEquals {
    Input: str1: Address
    Input: str2: Address
    Output: Integer
    Body: {
        i = 0
        WhileLoop 1 {
            ch1 = GetByte(str1, i)
            ch2 = GetByte(str2, i)
            
            IfCondition NotEqual(ch1, ch2) ThenBlock: {
                ReturnValue(0)
            }
            
            IfCondition EqualTo(ch1, 0) ThenBlock: {
                ReturnValue(1)
            }
            
            i = Add(i, 1)
        }
        ReturnValue(0)
    }
}

Function.IsFlag {
    Input: str: Address
    Output: Integer
    Body: {
        first = GetByte(str, 0)
        second = GetByte(str, 1)
        
        // Must start with '-' and have at least one more char
        IfCondition And(EqualTo(first, 45), NotEqual(second, 0)) ThenBlock: {
            ReturnValue(1)
        }
        ReturnValue(0)
    }
}

// === ESCAPE SEQUENCE HANDLING ===

Function.ParseOctal {
    Input: str: Address
    Input: pos: Integer
    Output: Integer
    Body: {
        // Parse up to 3 octal digits starting at position pos
        value = 0
        i = pos
        
        // First digit
        ch = GetByte(str, i)
        IfCondition And(GreaterEqual(ch, 48), LessEqual(ch, 55)) ThenBlock: {
            digit = Subtract(ch, 48)
            value = digit
            i = Add(i, 1)
            
            // Second digit
            ch = GetByte(str, i)
            IfCondition And(GreaterEqual(ch, 48), LessEqual(ch, 55)) ThenBlock: {
                digit = Subtract(ch, 48)
                value = Add(Multiply(value, 8), digit)
                i = Add(i, 1)
                
                // Third digit
                ch = GetByte(str, i)
                IfCondition And(GreaterEqual(ch, 48), LessEqual(ch, 55)) ThenBlock: {
                    digit = Subtract(ch, 48)
                    value = Add(Multiply(value, 8), digit)
                    i = Add(i, 1)
                }
            }
        }
        
        // Calculate how many digits we parsed
        count = Subtract(i, pos)
        
        // Return: value + (count * 256)
        result = Add(BitwiseAnd(value, 255), Multiply(count, 256))
        ReturnValue(result)
    }
}

Function.ParseHex {
    Input: str: Address
    Input: pos: Integer
    Output: Integer
    Body: {
        // Parse up to 2 hex digits starting at position pos
        value = 0
        i = pos
        
        // First digit
        ch = GetByte(str, i)
        digit = -1
        
        IfCondition And(GreaterEqual(ch, 48), LessEqual(ch, 57)) ThenBlock: {
            digit = Subtract(ch, 48)
        } ElseBlock: {
            IfCondition And(GreaterEqual(ch, 65), LessEqual(ch, 70)) ThenBlock: {
                digit = Subtract(ch, 55)
            } ElseBlock: {
                IfCondition And(GreaterEqual(ch, 97), LessEqual(ch, 102)) ThenBlock: {
                    digit = Subtract(ch, 87)
                }
            }
        }
        
        IfCondition GreaterEqual(digit, 0) ThenBlock: {
            value = digit
            i = Add(i, 1)
            
            // Second digit
            ch = GetByte(str, i)
            digit = -1
            
            IfCondition And(GreaterEqual(ch, 48), LessEqual(ch, 57)) ThenBlock: {
                digit = Subtract(ch, 48)
            } ElseBlock: {
                IfCondition And(GreaterEqual(ch, 65), LessEqual(ch, 70)) ThenBlock: {
                    digit = Subtract(ch, 55)
                } ElseBlock: {
                    IfCondition And(GreaterEqual(ch, 97), LessEqual(ch, 102)) ThenBlock: {
                        digit = Subtract(ch, 87)
                    }
                }
            }
            
            IfCondition GreaterEqual(digit, 0) ThenBlock: {
                value = Add(Multiply(value, 16), digit)
                i = Add(i, 1)
            }
        }
        
        // Calculate how many digits we parsed
        count = Subtract(i, pos)
        
        // Return: value + (count * 256)
        result = Add(BitwiseAnd(value, 255), Multiply(count, 256))
        ReturnValue(result)
    }
}

Function.ProcessEscapeSequence {
    Input: str: Address
    Input: pos: Integer
    Output: Integer
    Body: {
        // Returns: character to output (low byte) + chars consumed (high byte)
        // Special: if char is 256+, it means \c (suppress rest)
        
        ch = GetByte(str, pos)
        
        // \\ - backslash
        IfCondition EqualTo(ch, 92) ThenBlock: {
            ReturnValue(Add(92, 256))
        }
        
        // \a - alert (BEL)
        IfCondition EqualTo(ch, 97) ThenBlock: {
            ReturnValue(Add(7, 256))
        }
        
        // \b - backspace
        IfCondition EqualTo(ch, 98) ThenBlock: {
            ReturnValue(Add(8, 256))
        }
        
        // \c - suppress further output
        IfCondition EqualTo(ch, 99) ThenBlock: {
            EchoConfig.stop_on_backslash_c = 1
            ReturnValue(512)  // Special marker, no output
        }
        
        // \e - escape
        IfCondition EqualTo(ch, 101) ThenBlock: {
            ReturnValue(Add(27, 256))
        }
        
        // \f - form feed
        IfCondition EqualTo(ch, 102) ThenBlock: {
            ReturnValue(Add(12, 256))
        }
        
        // \n - newline
        IfCondition EqualTo(ch, 110) ThenBlock: {
            ReturnValue(Add(10, 256))
        }
        
        // \r - carriage return
        IfCondition EqualTo(ch, 114) ThenBlock: {
            ReturnValue(Add(13, 256))
        }
        
        // \t - tab
        IfCondition EqualTo(ch, 116) ThenBlock: {
            ReturnValue(Add(9, 256))
        }
        
        // \v - vertical tab
        IfCondition EqualTo(ch, 118) ThenBlock: {
            ReturnValue(Add(11, 256))
        }
        
        // \0 - octal (special case: \0NNN)
        IfCondition EqualTo(ch, 48) ThenBlock: {
            result = ParseOctal(str, Add(pos, 1))
            
            // Check if we got a valid result (count > 0)
            // Result format: value + (count * 256)
            // If result < 256, then count was 0
            IfCondition GreaterEqual(result, 256) ThenBlock: {
                value = Modulo(result, 256)
                count = Divide(result, 256)
                // Return: value + (1 + count)*256
                // The 1 is for the '0' itself, count is digits parsed
                ReturnValue(Add(value, Multiply(Add(count, 1), 256)))
            } ElseBlock: {
                // \0 with no following digits - output NULL byte
                ReturnValue(Add(0, 256))
            }
        }
        
        // \x - hexadecimal
        IfCondition EqualTo(ch, 120) ThenBlock: {
            result = ParseHex(str, Add(pos, 1))
            
            // Check if we got a valid result (count > 0)
            IfCondition GreaterEqual(result, 256) ThenBlock: {
                value = Modulo(result, 256)
                count = Divide(result, 256)
                // Return: value + (1 + count)*256
                // The 1 is for the 'x' itself, count is digits parsed
                ReturnValue(Add(value, Multiply(Add(count, 1), 256)))
            } ElseBlock: {
                // \x with no following hex digits - output 'x' literally
                ReturnValue(Add(120, 256))
            }
        }
        
        // Unknown escape - print literal backslash then the character
        // This is GNU behavior
        WriteChar(92)
        ReturnValue(Add(ch, 256))
    }
}

Function.ProcessString {
    Input: str: Address
    Body: {
        // Fast path: if no escape mode, write directly!
        IfCondition EqualTo(EchoConfig.interpret_escapes, 0) ThenBlock: {
            WriteBuffered(str)
            ReturnValue(0)
        }
        
        i = 0
        len = 0
        WhileLoop NotEqual(GetByte(str, len), 0) {
            len = Add(len, 1)
        }
        
        WhileLoop LessThan(i, len) {
            // Check if we hit \c
            IfCondition EqualTo(EchoConfig.stop_on_backslash_c, 1) ThenBlock: {
                BreakLoop
            }
            
            ch = GetByte(str, i)
            
            // Check for backslash if escape mode enabled
            IfCondition And(EqualTo(EchoConfig.interpret_escapes, 1), EqualTo(ch, 92)) ThenBlock: {
                // Next position has the escape char
                next_pos = Add(i, 1)
                
                IfCondition LessThan(next_pos, len) ThenBlock: {
                    result = ProcessEscapeSequence(str, next_pos)
                    output_char = Modulo(result, 256)
                    chars_consumed = Divide(result, 256)
                    
                    // Check if \c (result == 512 means suppress)
                    IfCondition NotEqual(result, 512) ThenBlock: {
                        WriteChar(output_char)
                    }
                    
                    // Skip the backslash (1) + escape sequence chars (chars_consumed)
                    i = Add(i, Add(chars_consumed, 1))
                } ElseBlock: {
                    // Backslash at end of string, print it literally
                    WriteChar(92)
                    i = Add(i, 1)
                }
            } ElseBlock: {
                // Regular character
                WriteChar(ch)
                i = Add(i, 1)
            }
        }
    }
}

// === FLAG PARSING ===

Function.ParseFlags {
    Input: arg: Address
    Output: Integer
    Body: {
        // Returns 1 if valid flag, 0 if not
        
        // Check if starts with '-'
        first = GetByte(arg, 0)
        IfCondition NotEqual(first, 45) ThenBlock: {
            ReturnValue(0)
        }
        
        // Check for "--" (stop flag parsing)
        second = GetByte(arg, 1)
        IfCondition And(EqualTo(second, 45), EqualTo(GetByte(arg, 2), 0)) ThenBlock: {
            ReturnValue(2)  // Special marker: stop parsing
        }
        
        // Parse flag characters
        i = 1
        has_valid_flag = 0
        
        WhileLoop NotEqual(GetByte(arg, i), 0) {
            flag_char = GetByte(arg, i)
            
            // -n: suppress newline
            IfCondition EqualTo(flag_char, 110) ThenBlock: {
                EchoConfig.suppress_newline = 1
                has_valid_flag = 1
            } ElseBlock: {
                // -e: enable escape sequences
                IfCondition EqualTo(flag_char, 101) ThenBlock: {
                    EchoConfig.interpret_escapes = 1
                    has_valid_flag = 1
                } ElseBlock: {
                    // -E: disable escape sequences (explicit, no-op since default)
                    IfCondition EqualTo(flag_char, 69) ThenBlock: {
                        EchoConfig.interpret_escapes = 0
                        has_valid_flag = 1
                    } ElseBlock: {
                        // Unknown flag - not a valid flag string
                        ReturnValue(0)
                    }
                }
            }
            
            i = Add(i, 1)
        }
        
        ReturnValue(has_valid_flag)
    }
}

// === ARGUMENT PARSING ===

Function.GetArgs {
    Output: Address
    Body: {
        cmdline_path = "/proc/self/cmdline"
        fd = SystemCall(257, -100, cmdline_path, 0, 0)
        
        IfCondition LessThan(fd, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        buffer = Allocate(4096)
        bytes_read = SystemCall(0, fd, buffer, 4096)
        SystemCall(3, fd)
        
        IfCondition LessEqual(bytes_read, 0) ThenBlock: {
            Deallocate(buffer, 4096)
            ReturnValue(0)
        }
        
        ReturnValue(buffer)
    }
}

// === MAIN PROGRAM ===

SubRoutine.Main {
    RunTask(InitBuffer)
    
    args_buffer = GetArgs()
    
    // If no args, just print newline
    IfCondition EqualTo(args_buffer, 0) ThenBlock: {
        WriteChar(10)
        RunTask(FlushBuffer)
        HaltProgram()
    }
    
    // Skip program name (first null-terminated string)
    pos = 0
    WhileLoop NotEqual(GetByte(args_buffer, pos), 0) {
        pos = Add(pos, 1)
    }
    pos = Add(pos, 1)
    
    // Parse flags
    stop_flag_parsing = 0
    first_arg = 1
    
    WhileLoop LessThan(pos, 4096) {
        ch = GetByte(args_buffer, pos)
        IfCondition EqualTo(ch, 0) ThenBlock: {
            BreakLoop
        }
        
        // Get argument start and length
        arg_start = pos
        arg_len = 0
        
        WhileLoop And(LessThan(pos, 4096), NotEqual(GetByte(args_buffer, pos), 0)) {
            arg_len = Add(arg_len, 1)
            pos = Add(pos, 1)
        }
        
        // Use pointer directly into args_buffer (no copy!)
        arg = Add(args_buffer, arg_start)
        
        // Try to parse as flag (only if we haven't stopped flag parsing)
        is_flag = 0
        IfCondition EqualTo(stop_flag_parsing, 0) ThenBlock: {
            flag_result = ParseFlags(arg)
            
            IfCondition EqualTo(flag_result, 2) ThenBlock: {
                // Hit "--", stop flag parsing AND output the "--"
                stop_flag_parsing = 1
                is_flag = 0  // Treat as regular text to output
            } ElseBlock: {
                IfCondition EqualTo(flag_result, 1) ThenBlock: {
                    is_flag = 1
                }
            }
        }
        
        // If not a flag, process as text
        IfCondition EqualTo(is_flag, 0) ThenBlock: {
            // Add space before argument (except first)
            IfCondition EqualTo(first_arg, 0) ThenBlock: {
                WriteChar(32)
            }
            first_arg = 0
            
            ProcessString(arg)
            
            // Check if \c was encountered
            IfCondition EqualTo(EchoConfig.stop_on_backslash_c, 1) ThenBlock: {
                BreakLoop
            }
        }
        
        // No need to deallocate - we're using pointer into args_buffer!
        pos = Add(pos, 1)
    }
    
    Deallocate(args_buffer, 4096)
    
    // Print trailing newline unless suppressed
    IfCondition EqualTo(EchoConfig.suppress_newline, 0) ThenBlock: {
        IfCondition EqualTo(EchoConfig.stop_on_backslash_c, 0) ThenBlock: {
            WriteChar(10)
        }
    }
    
    RunTask(FlushBuffer)
    Deallocate(OutputBuf.buf, OutputBuf.cap)
    HaltProgram()
}

RunTask(Main)