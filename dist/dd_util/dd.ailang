// dd.ailang - Convert and copy a file
// Usage: dd [OPERAND]...

FixedPool.DdConfig {
    "block_size": Initialize=512
    "count": Initialize=-1
    "skip": Initialize=0
    "seek": Initialize=0
    "input_file": Initialize=0
    "output_file": Initialize=0
}

FixedPool.DdStats {
    "records_in": Initialize=0
    "records_out": Initialize=0
    "bytes_copied": Initialize=0
}

Function.WriteStdout {
    Input: buffer: Address
    Input: len: Integer
    Body: {
        SystemCall(1, 1, buffer, len)
    }
}

Function.WriteStderr {
    Input: buffer: Address
    Input: len: Integer
    Body: {
        SystemCall(1, 2, buffer, len)
    }
}

Function.GetStringLength {
    Input: str: Address
    Output: Integer
    Body: {
        len = 0
        WhileLoop NotEqual(GetByte(str, len), 0) {
            len = Add(len, 1)
        }
        ReturnValue(len)
    }
}

Function.ConvertNumberToString {
    Input: num: Integer
    Output: Address
    Body: {
        buffer = Allocate(32)
        
        IfCondition EqualTo(num, 0) ThenBlock: {
            SetByte(buffer, 0, 48)
            SetByte(buffer, 1, 0)
            ReturnValue(buffer)
        }
        
        is_neg = 0
        IfCondition LessThan(num, 0) ThenBlock: {
            is_neg = 1
            num = Subtract(0, num)
        }
        
        pos = 0
        temp = Allocate(32)
        
        WhileLoop GreaterThan(num, 0) {
            digit = Modulo(num, 10)
            SetByte(temp, pos, Add(48, digit))
            pos = Add(pos, 1)
            num = Divide(num, 10)
        }
        
        write_pos = 0
        IfCondition NotEqual(is_neg, 0) ThenBlock: {
            SetByte(buffer, 0, 45)
            write_pos = 1
        }
        
        i = Subtract(pos, 1)
        WhileLoop GreaterEqual(i, 0) {
            ch = GetByte(temp, i)
            SetByte(buffer, write_pos, ch)
            write_pos = Add(write_pos, 1)
            i = Subtract(i, 1)
        }
        
        SetByte(buffer, write_pos, 0)
        Deallocate(temp, 32)
        
        ReturnValue(buffer)
    }
}

// Parse numeric value from string
Function.ParseNumeric {
    Input: str: Address
    Output: Integer
    Body: {
        result = 0
        i = 0
        
        WhileLoop LessThan(i, 20) {
            ch = GetByte(str, i)
            
            IfCondition EqualTo(ch, 0) ThenBlock: {
                BreakLoop
            }
            
            // Check if digit
            IfCondition Or(LessThan(ch, 48), GreaterThan(ch, 57)) ThenBlock: {
                BreakLoop
            }
            
            digit = Subtract(ch, 48)
            result = Add(Multiply(result, 10), digit)
            i = Add(i, 1)
        }
        
        ReturnValue(result)
    }
}

// Compare strings up to n characters
Function.StringCompareN {
    Input: s1: Address
    Input: s2: Address
    Input: n: Integer
    Output: Integer
    Body: {
        i = 0
        
        WhileLoop LessThan(i, n) {
            c1 = GetByte(s1, i)
            c2 = GetByte(s2, i)
            
            IfCondition NotEqual(c1, c2) ThenBlock: {
                ReturnValue(1)
            }
            
            i = Add(i, 1)
        }
        
        ReturnValue(0)
    }
}

// Find character in string
Function.FindChar {
    Input: str: Address
    Input: ch: Integer
    Output: Integer
    Body: {
        i = 0
        
        WhileLoop LessThan(i, 1000) {
            current = GetByte(str, i)
            
            IfCondition EqualTo(current, 0) ThenBlock: {
                ReturnValue(-1)
            }
            
            IfCondition EqualTo(current, ch) ThenBlock: {
                ReturnValue(i)
            }
            
            i = Add(i, 1)
        }
        
        ReturnValue(-1)
    }
}

// Parse dd operand (key=value)
Function.ParseOperand {
    Input: operand: Address
    Body: {
        // Find '=' sign
        eq_pos = FindChar(operand, 61)
        
        IfCondition LessThan(eq_pos, 0) ThenBlock: {
            WriteStderr("dd: invalid operand '", 21)
            WriteStderr(operand, GetStringLength(operand))
            WriteStderr("'\n", 2)
            ReturnVoid
        }
        
        // Extract key and value
        value_start = Add(operand, Add(eq_pos, 1))
        
        // Check key type
        // if=
        IfCondition EqualTo(StringCompareN(operand, "if", 2), 0) ThenBlock: {
            IfCondition EqualTo(eq_pos, 2) ThenBlock: {
                DdConfig.input_file = value_start
            }
        }
        
        // of=
        IfCondition EqualTo(StringCompareN(operand, "of", 2), 0) ThenBlock: {
            IfCondition EqualTo(eq_pos, 2) ThenBlock: {
                DdConfig.output_file = value_start
            }
        }
        
        // bs=
        IfCondition EqualTo(StringCompareN(operand, "bs", 2), 0) ThenBlock: {
            IfCondition EqualTo(eq_pos, 2) ThenBlock: {
                DdConfig.block_size = ParseNumeric(value_start)
            }
        }
        
        // count=
        IfCondition EqualTo(StringCompareN(operand, "count", 5), 0) ThenBlock: {
            IfCondition EqualTo(eq_pos, 5) ThenBlock: {
                DdConfig.count = ParseNumeric(value_start)
            }
        }
        
        // skip=
        IfCondition EqualTo(StringCompareN(operand, "skip", 4), 0) ThenBlock: {
            IfCondition EqualTo(eq_pos, 4) ThenBlock: {
                DdConfig.skip = ParseNumeric(value_start)
            }
        }
        
        // seek=
        IfCondition EqualTo(StringCompareN(operand, "seek", 4), 0) ThenBlock: {
            IfCondition EqualTo(eq_pos, 4) ThenBlock: {
                DdConfig.seek = ParseNumeric(value_start)
            }
        }
    }
}

// Print statistics
Function.PrintStats {
    Body: {
        // Records in
        WriteStderr("\n", 1)
        records_in_str = ConvertNumberToString(DdStats.records_in)
        WriteStderr(records_in_str, GetStringLength(records_in_str))
        WriteStderr("+0 records in\n", 14)
        Deallocate(records_in_str, 32)
        
        // Records out
        records_out_str = ConvertNumberToString(DdStats.records_out)
        WriteStderr(records_out_str, GetStringLength(records_out_str))
        WriteStderr("+0 records out\n", 15)
        Deallocate(records_out_str, 32)
        
        // Bytes copied
        bytes_str = ConvertNumberToString(DdStats.bytes_copied)
        WriteStderr(bytes_str, GetStringLength(bytes_str))
        WriteStderr(" bytes (", 8)
        
        // Calculate KB/MB
        kb = Divide(DdStats.bytes_copied, 1024)
        IfCondition GreaterThan(kb, 1024) ThenBlock: {
            mb = Divide(kb, 1024)
            mb_str = ConvertNumberToString(mb)
            WriteStderr(mb_str, GetStringLength(mb_str))
            WriteStderr(" MB", 3)
            Deallocate(mb_str, 32)
        } ElseBlock: {
            kb_str = ConvertNumberToString(kb)
            WriteStderr(kb_str, GetStringLength(kb_str))
            WriteStderr(" KB", 3)
            Deallocate(kb_str, 32)
        }
        
        WriteStderr(") copied\n", 9)
        Deallocate(bytes_str, 32)
    }
}

// Print help
Function.PrintHelp {
    Body: {
        WriteStdout("Usage: dd [OPERAND]...\n", 23)
        WriteStdout("  or:  dd OPTION\n", 17)
        WriteStdout("Copy a file, converting and formatting according to the operands.\n\n", 68)
        WriteStdout("  bs=BYTES        read and write up to BYTES bytes at a time\n", 63)
        WriteStdout("  count=N         copy only N input blocks\n", 44)
        WriteStdout("  if=FILE         read from FILE instead of stdin\n", 51)
        WriteStdout("  of=FILE         write to FILE instead of stdout\n", 51)
        WriteStdout("  seek=N          skip N obs-sized blocks at start of output\n", 63)
        WriteStdout("  skip=N          skip N ibs-sized blocks at start of input\n", 62)
        WriteStdout("      --help      display this help and exit\n", 47)
        WriteStdout("\n", 1)
        WriteStdout("N and BYTES may be followed by the following multiplicative suffixes:\n", 71)
        WriteStdout("c=1, w=2, b=512, kB=1000, K=1024, MB=1000*1000, M=1024*1024, xM=M,\n", 68)
        WriteStdout("GB=1000*1000*1000, G=1024*1024*1024, and so on for T, P, E, Z, Y.\n\n", 70)
        WriteStdout("Examples:\n", 10)
        WriteStdout("  dd if=/dev/zero of=file.txt bs=1M count=10\n", 45)
        WriteStdout("  dd if=input.txt of=output.txt bs=4096\n", 40)
    }
}

Function.GetArgs {
    Output: Address
    Body: {
        fd = SystemCall(257, -100, "/proc/self/cmdline", 0, 0)
        IfCondition LessThan(fd, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        buffer = Allocate(4096)
        bytes_read = SystemCall(0, fd, buffer, 4096)
        SystemCall(3, fd)
        
        IfCondition LessEqual(bytes_read, 0) ThenBlock: {
            Deallocate(buffer, 4096)
            ReturnValue(0)
        }
        
        ReturnValue(buffer)
    }
}

SubRoutine.Main {
    args_buffer = GetArgs()
    
    IfCondition EqualTo(args_buffer, 0) ThenBlock: {
        WriteStderr("dd: cannot read arguments\n", 26)
        SystemCall(60, 1)
    }
    
    // Skip program name
    pos = 0
    WhileLoop NotEqual(GetByte(args_buffer, pos), 0) {
        pos = Add(pos, 1)
    }
    pos = Add(pos, 1)
    
    // Check for --help
    first_arg = Add(args_buffer, pos)
    IfCondition EqualTo(StringCompareN(first_arg, "--help", 6), 0) ThenBlock: {
        PrintHelp()
        Deallocate(args_buffer, 4096)
        SystemCall(60, 0)
    }
    
    // Parse operands
    WhileLoop LessThan(pos, 4096) {
        ch = GetByte(args_buffer, pos)
        IfCondition EqualTo(ch, 0) ThenBlock: {
            BreakLoop
        }
        
        operand_start = Add(args_buffer, pos)
        ParseOperand(operand_start)
        
        // Skip to next argument
        WhileLoop NotEqual(GetByte(args_buffer, pos), 0) {
            pos = Add(pos, 1)
        }
        pos = Add(pos, 1)
    }
    
    // Open input file (or use stdin)
    input_fd = 0
    IfCondition NotEqual(DdConfig.input_file, 0) ThenBlock: {
        input_fd = SystemCall(2, DdConfig.input_file, 0)
        
        IfCondition LessThan(input_fd, 0) ThenBlock: {
            WriteStderr("dd: failed to open '", 20)
            WriteStderr(DdConfig.input_file, GetStringLength(DdConfig.input_file))
            WriteStderr("': No such file or directory\n", 29)
            Deallocate(args_buffer, 4096)
            SystemCall(60, 1)
        }
    }
    
    // Open output file (or use stdout)
    output_fd = 1
    IfCondition NotEqual(DdConfig.output_file, 0) ThenBlock: {
        // O_WRONLY | O_CREAT | O_TRUNC = 1 | 64 | 512 = 577
        output_fd = SystemCall(2, DdConfig.output_file, 577, 420)
        
        IfCondition LessThan(output_fd, 0) ThenBlock: {
            WriteStderr("dd: failed to open '", 20)
            WriteStderr(DdConfig.output_file, GetStringLength(DdConfig.output_file))
            WriteStderr("': Permission denied\n", 21)
            IfCondition NotEqual(input_fd, 0) ThenBlock: {
                SystemCall(3, input_fd)
            }
            Deallocate(args_buffer, 4096)
            SystemCall(60, 1)
        }
    }
    
    // Skip blocks if needed
    IfCondition GreaterThan(DdConfig.skip, 0) ThenBlock: {
        skip_bytes = Multiply(DdConfig.skip, DdConfig.block_size)
        // lseek syscall: 8
        SystemCall(8, input_fd, skip_bytes, 0)
    }
    
    // Seek output if needed
    IfCondition GreaterThan(DdConfig.seek, 0) ThenBlock: {
        seek_bytes = Multiply(DdConfig.seek, DdConfig.block_size)
        SystemCall(8, output_fd, seek_bytes, 0)
    }
    
    // Allocate buffer
    buffer = Allocate(DdConfig.block_size)
    
    // Copy loop
    blocks_copied = 0
    
    WhileLoop LessThan(0, 1) {
        // Check count limit
        IfCondition GreaterEqual(DdConfig.count, 0) ThenBlock: {
            IfCondition GreaterEqual(blocks_copied, DdConfig.count) ThenBlock: {
                BreakLoop
            }
        }
        
        // Read block
        bytes_read = SystemCall(0, input_fd, buffer, DdConfig.block_size)
        
        IfCondition LessEqual(bytes_read, 0) ThenBlock: {
            BreakLoop
        }
        
        DdStats.records_in = Add(DdStats.records_in, 1)
        
        // Write block
        bytes_written = SystemCall(1, output_fd, buffer, bytes_read)
        
        IfCondition LessThan(bytes_written, 0) ThenBlock: {
            WriteStderr("dd: error writing to output\n", 28)
            BreakLoop
        }
        
        DdStats.records_out = Add(DdStats.records_out, 1)
        DdStats.bytes_copied = Add(DdStats.bytes_copied, bytes_written)
        
        blocks_copied = Add(blocks_copied, 1)
    }
    
    // Cleanup
    Deallocate(buffer, DdConfig.block_size)
    
    IfCondition NotEqual(input_fd, 0) ThenBlock: {
        SystemCall(3, input_fd)
    }
    
    IfCondition NotEqual(output_fd, 1) ThenBlock: {
        SystemCall(3, output_fd)
    }
    
    // Print statistics
    PrintStats()
    
    Deallocate(args_buffer, 4096)
    SystemCall(60, 0)
}

RunTask(Main)