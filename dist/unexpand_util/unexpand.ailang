// unexpand.ailang - Convert spaces to tabs
// Usage: unexpand [OPTION]... [FILE]...

FixedPool.UnexpandConfig {
    "tab_size": Initialize=8
    "all_blanks": Initialize=0
}

Function.WriteStdout {
    Input: buffer: Address
    Input: len: Integer
    Body: {
        SystemCall(1, 1, buffer, len)
    }
}

Function.WriteStderr {
    Input: buffer: Address
    Input: len: Integer
    Body: {
        SystemCall(1, 2, buffer, len)
    }
}

Function.GetStringLength {
    Input: str: Address
    Output: Integer
    Body: {
        len = 0
        WhileLoop NotEqual(GetByte(str, len), 0) {
            len = Add(len, 1)
        }
        ReturnValue(len)
    }
}

Function.ParseNumeric {
    Input: str: Address
    Output: Integer
    Body: {
        result = 0
        i = 0
        
        WhileLoop LessThan(i, 20) {
            ch = GetByte(str, i)
            
            IfCondition EqualTo(ch, 0) ThenBlock: {
                BreakLoop
            }
            
            IfCondition Or(LessThan(ch, 48), GreaterThan(ch, 57)) ThenBlock: {
                BreakLoop
            }
            
            digit = Subtract(ch, 48)
            result = Add(Multiply(result, 10), digit)
            i = Add(i, 1)
        }
        
        ReturnValue(result)
    }
}

// Convert spaces to tabs in a file
Function.UnexpandFile {
    Input: fd: Integer
    Body: {
        buffer = Allocate(8192)
        output = Allocate(8192)
        column = 0
        space_count = 0
        line_start = 1
        
        WhileLoop LessThan(0, 1) {
            bytes_read = SystemCall(0, fd, buffer, 8192)
            
            IfCondition LessEqual(bytes_read, 0) ThenBlock: {
                BreakLoop
            }
            
            // Process each character
            i = 0
            out_pos = 0
            
            WhileLoop LessThan(i, bytes_read) {
                ch = GetByte(buffer, i)
                
                IfCondition EqualTo(ch, 32) ThenBlock: {
                    // Space character
                    space_count = Add(space_count, 1)
                    column = Add(column, 1)
                    
                    // Check if we should convert to tab
                    IfCondition EqualTo(Modulo(column, UnexpandConfig.tab_size), 0) ThenBlock: {
                        // Convert spaces to tab (only at line start or if -a flag)
                        IfCondition Or(NotEqual(line_start, 0), NotEqual(UnexpandConfig.all_blanks, 0)) ThenBlock: {
                            SetByte(output, out_pos, 9)
                            out_pos = Add(out_pos, 1)
                            space_count = 0
                        } ElseBlock: {
                            // Output accumulated spaces
                            j = 0
                            WhileLoop LessThan(j, space_count) {
                                SetByte(output, out_pos, 32)
                                out_pos = Add(out_pos, 1)
                                j = Add(j, 1)
                            }
                            space_count = 0
                        }
                    }
                } ElseBlock: {
                    // Non-space character
                    
                    // Output any accumulated spaces first
                    j = 0
                    WhileLoop LessThan(j, space_count) {
                        SetByte(output, out_pos, 32)
                        out_pos = Add(out_pos, 1)
                        j = Add(j, 1)
                    }
                    space_count = 0
                    
                    // Output the character
                    SetByte(output, out_pos, ch)
                    out_pos = Add(out_pos, 1)
                    
                    // Reset column on newline
                    IfCondition EqualTo(ch, 10) ThenBlock: {
                        column = 0
                        line_start = 1
                    } ElseBlock: {
                        column = Add(column, 1)
                        line_start = 0
                    }
                }
                
                // Flush if buffer full
                IfCondition GreaterEqual(out_pos, 8000) ThenBlock: {
                    WriteStdout(output, out_pos)
                    out_pos = 0
                }
                
                i = Add(i, 1)
            }
            
            // Flush remaining output
            IfCondition GreaterThan(out_pos, 0) ThenBlock: {
                WriteStdout(output, out_pos)
            }
        }
        
        Deallocate(buffer, 8192)
        Deallocate(output, 8192)
    }
}

Function.PrintHelp {
    Body: {
        WriteStdout("Usage: unexpand [OPTION]... [FILE]...\n", 39)
        WriteStdout("Convert blanks in each FILE to tabs, writing to standard output.\n", 67)
        WriteStdout("With no FILE, or when FILE is -, read standard input.\n\n", 56)
        WriteStdout("  -a, --all       convert all blanks, instead of just initial blanks\n", 71)
        WriteStdout("  -t, --tabs=N    have tabs N characters apart instead of 8\n", 62)
        WriteStdout("      --help      display this help and exit\n", 47)
        WriteStdout("\n", 1)
        WriteStdout("Examples:\n", 10)
        WriteStdout("  unexpand file.txt          Convert initial spaces to tabs\n", 62)
        WriteStdout("  unexpand -a file.txt       Convert all spaces to tabs\n", 58)
        WriteStdout("  unexpand -t 4 file.txt     Use 4-space tabs\n", 48)
    }
}

Function.GetArgs {
    Output: Address
    Body: {
        fd = SystemCall(257, -100, "/proc/self/cmdline", 0, 0)
        IfCondition LessThan(fd, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        buffer = Allocate(4096)
        bytes_read = SystemCall(0, fd, buffer, 4096)
        SystemCall(3, fd)
        
        IfCondition LessEqual(bytes_read, 0) ThenBlock: {
            Deallocate(buffer, 4096)
            ReturnValue(0)
        }
        
        ReturnValue(buffer)
    }
}

SubRoutine.Main {
    args_buffer = GetArgs()
    
    IfCondition EqualTo(args_buffer, 0) ThenBlock: {
        WriteStderr("unexpand: cannot read arguments\n", 32)
        SystemCall(60, 1)
    }
    
    // Skip program name
    pos = 0
    WhileLoop NotEqual(GetByte(args_buffer, pos), 0) {
        pos = Add(pos, 1)
    }
    pos = Add(pos, 1)
    
    // Parse options
    has_files = 0
    show_help = 0
    
    WhileLoop LessThan(pos, 4096) {
        ch = GetByte(args_buffer, pos)
        IfCondition EqualTo(ch, 0) ThenBlock: {
            BreakLoop
        }
        
        IfCondition EqualTo(ch, 45) ThenBlock: {
            next_ch = GetByte(args_buffer, Add(pos, 1))
            
            // --help
            IfCondition EqualTo(next_ch, 45) ThenBlock: {
                show_help = 1
            }
            
            // -a (all blanks)
            IfCondition EqualTo(next_ch, 97) ThenBlock: {
                UnexpandConfig.all_blanks = 1
            }
            
            // -t (tab size)
            IfCondition EqualTo(next_ch, 116) ThenBlock: {
                // Skip to next arg for number
                WhileLoop NotEqual(GetByte(args_buffer, pos), 0) {
                    pos = Add(pos, 1)
                }
                pos = Add(pos, 1)
                
                num_str = Add(args_buffer, pos)
                UnexpandConfig.tab_size = ParseNumeric(num_str)
            }
            
            // Skip to next argument
            WhileLoop NotEqual(GetByte(args_buffer, pos), 0) {
                pos = Add(pos, 1)
            }
            pos = Add(pos, 1)
        } ElseBlock: {
            has_files = 1
            BreakLoop
        }
    }
    
    // Show help if requested
    IfCondition NotEqual(show_help, 0) ThenBlock: {
        PrintHelp()
        Deallocate(args_buffer, 4096)
        SystemCall(60, 0)
    }
    
    // Process files or stdin
    IfCondition EqualTo(has_files, 0) ThenBlock: {
        // Read from stdin
        UnexpandFile(0)
    } ElseBlock: {
        // Process each file
        WhileLoop LessThan(pos, 4096) {
            ch = GetByte(args_buffer, pos)
            IfCondition EqualTo(ch, 0) ThenBlock: {
                BreakLoop
            }
            
            IfCondition NotEqual(ch, 45) ThenBlock: {
                file_path = Add(args_buffer, pos)
                
                // Open file
                fd = SystemCall(2, file_path, 0)
                
                IfCondition LessThan(fd, 0) ThenBlock: {
                    WriteStderr("unexpand: cannot open '", 23)
                    WriteStderr(file_path, GetStringLength(file_path))
                    WriteStderr("'\n", 2)
                } ElseBlock: {
                    UnexpandFile(fd)
                    SystemCall(3, fd)
                }
            }
            
            // Skip to next argument
            WhileLoop NotEqual(GetByte(args_buffer, pos), 0) {
                pos = Add(pos, 1)
            }
            pos = Add(pos, 1)
        }
    }
    
    Deallocate(args_buffer, 4096)
    SystemCall(60, 0)
}

RunTask(Main)